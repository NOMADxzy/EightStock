## JAVA

### 一、基础

- 面向过程：就是具体化的一步一步的去实现，优点 就是性能比较快因为不需要进行实例化。 缺点就是不容易进行维护，扩展和复用
- 面向对象：因为面向对象的三大特点就是 封装、继承和多态

#### 面向对象（OOP）

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f3030377338484a556c79316735773339666d3232676a333076773068793133792e6a7067.jpeg)

##### 3.1、封装

定义：使用对象封装一些变量和函数

作用：复用和信息隐藏，封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

##### 3.2、抽象

抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。

##### 3.3、继承

定义：一个类获取另外一个类属性和方法的一种方式

作用：代码复用，继承，就是可以使用已创建好的类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

##### 3.4、多态

定义：同一个操作，作用于不用的对象，会有不同的行为

作用：具有可拓展性详解：多态首先是建立在继承的基础上的，先有继承才能有多态。多态是指不同的子类在继承父类后分别都重写覆盖了父类的方法，即父类同一个方法，在继承的子类中表现出不同的形式。js天生就具备多态的特性(弱类型语言)

原理：靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定

```markdown
## AOP和OOP
OOP主要功能封装、继承、多态，AOP它是将系统分解为不同的关注点(不同的切面)。

OOP，我们会根据业务将应用划分为多个不同的业务模块，每个模块的核心功能只为某个核心业务提供服务，如学生宿舍管理系统，学生管理、班级管理、房间管理，分别学生、班级、房间服务的。
除此之外，还会有一些非业务的通用功能，如日志、权限、事务管理等。它们和业务无关，但是几乎所有的模块都会用到它。因此这些通用功能会散布在不同的业务模块中。此时会有很多重复性的代码，不理模块的复用。
为了解决这个问题，AOP(面向切面编程)就出来了，它是把非业务的通用功能抽取出来单独维护，并通过声明的方式(定义切入点)去指定这些功能以何种方式(通知类型)作用在哪里(方法连接点--目标方法)，而不是直接在模块的代码中去直接添加。
```



#### 数据类型

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/fc1f4134970a304e051fda77fdc5bc8cc9175c10.png)

##### 基本数据类型

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/09aefb43c53846f39034e786af458f25.png)

###### 为什么float=3.4报错

3.4 默认是浮点double类型的，如果赋值给float是[向下转型](https://so.csdn.net/so/search?q=向下转型&spm=1001.2101.3001.7020)，会出现精度缺失，，需要强制转换

###### Switch支持的数据类型？

byte、short、int、char 、 enum 、 String

##### 基本类型与包装类的区别

```markdown
## 存储位置不同：
基本数据类型直接将值放在栈中；（非static的成员变量存在堆中）
包装类型是把对象放在堆中，然后通过对象的引用来调用他们 ；
## 初始值不同：
int的初始值为 0 、 boolean的初始值为false ；
包装类型的初始值为null ；
## 使用方式不同：
基本数据类型直接赋值使用就好；
在集合如 coolectionMap 中只能使用包装类型；包装类型可以使用在泛型中
```
##### 基本类型与包装类的相互转换

```markdown
## 手动转换
基本数据类型 → 包装类：
    通过对应包装类的构造方法实现（Integer.valueOf(10)），除了Character外，其他包装类都可以传入一个字符串参数构建包装类对象。
包装类 → 基本数据类型
    通过包装类的实例方法 xxxValue() 实现; // xxx表示包装类对应的基本数据类型
## 自动装箱&自动拆箱（jdk1.5以后）
基本类型添加到集合中时，进行自动装箱
包装类型在涉及到运算的时候，“加，减，乘， 除” 以及 “比较 equals,compareTo”，进行自动拆箱
```
##### 包装类型的缓存机制

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2); // 输出 False
```

#### Runtime

运行时，是一个封装了JVM的类。每一个JAVA程序实际上都是启动了一个JVM进程，每一个JVM进程都对应一个Runtime实例，此实例是由JVM为其实例化的。所以我们不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime  方法获取当前Runtime运行时对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。

#### 1.接口和抽象类的区别

（1）抽象类可以有构造方法、普通成员变量，而接口没有

（2）抽象类可以有抽象方法和具体方法、静态方法，接口只能有抽象方法public abstract

（3）抽象类的成员4种权限修饰符都可以修饰，接口只能用public

（4）类只能继承一个抽象类，可以实现多个接口。

```
接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。
抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。
```

#### 2.重载和重写的区别

重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同

重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法；声明异常范围要小于父类方法；final和private修饰的方法不可重写。

#### 3.==和equals的区别

-  ==可用于基本类型和引用类型：当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同。
- 基本类型没有equals方法，equals只比较值（对象中的内容）是否相同（相同返回true）。
- 一个类如果没有定义equals方法，它将默认继承Object中的equals方法，返回值与==方法相同。

```java
boolean equals(Object o){
	return this==o;
}
```

#### 4.异常处理机制

try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常

（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行（任何执行try 或者catch中的return语句之前,都会先执行finally语句,如果finally存在的话）

（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止

#### 5.HashMap原理

- HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全

- HashMap的扩容机制：

HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树

- HashMap存取原理：

（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置

（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表

- 为什么不一开始就使用红黑树？

​		因为直接采用红黑树的话每次加入元素需要进行平衡，而在超过8时再旋转变为红黑树可以达成平衡，因为大部分哈希槽的元素个数正态分布在8个左右，所以此时变为红黑树也满足了查找的效率。

```
- 想要线程安全的哈希表
（1）使用ConcurrentHashMap
（2）使用HashTable
（3）Collections.synchronizedHashMap()方法
```

#### 6.HashTable与HashMap的区别

- （1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低

- （2）HashTable的Key不允许为null

- （3）HashTable只对key进行一次hash，HashMap进行了两次Hash

- （4）HashTable底层使用的数组加链表

#### ConcurrenHashMap与HashTable的区别

ConcurrentHashMap性能更高，它基于分段锁+CAS 保证线程安全，分段锁基于 synchronized 实现，**它仅仅锁住某个数组的某个槽位，而不是整个数组**

1. ConcurrentHashMap 没有大量使用 `synchronsize` 这种重量级锁。而是在一些关键位置使用乐观锁(CAS), 线程可以无阻塞的运行。
2. ConcurrentHashMap读方法没有加锁
3. ConcurrentHashMap扩容时老数据的转移是并发执行的，这样扩容的效率更高。

#### 7.ArrayList和LinkedList的区别

ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；

因为数组有索引，所以ArrayList查找数据更快，但是添加数据效率更低

LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高

```
如何保证ArrayList的线程安全？
（1）使用collentions.synchronizedList（）方法为ArrayList加锁
（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢
```

```
Queue<Integer> queue = new LinkedList<>();,

在Queue接口中， poll() 和 remove() 方法都用于从队列中移除并返回队头的元素。
如果队列为空，即没有元素可供移除时, pol0 方法会返回null。它是一个安全的方法不会抛出异常。
remove()在没有元素可供移除时，会抛出NoSuchElementException 异常。
```

#### 8.String、StringBuffer、StringBuilder的区别

- 都是final修饰的类，都不允许继承
- String 由 char[] 数组构成，长度不可变，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象，如果string在编译时就可以确定是常量，则自动拼接。

- StringBuffer线程安全，StringBuilder线程不安全，它们所有方法都相同，前者添加了synchronized修饰，后者有更好的性能。

- 操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer

```markdown
## String不可变的好处
- 提高效率:比如一个字符串Stirngs1=“abc”,“abc”被放到常量池里面去了，我再String s2="abc"并不会复制字符串“abc”,只会多个引用指向原来那个常量，这样就提高了效率，而这一前提是string不可变，如果可变，那么多个引用指向同一个字符串常量，我就可以通过一个引用改变字符串，然后其他引用就被影响了
- 安全:string常被用来表示url，文件路径，如果string可变，或存在安全隐患
- string不可变，那么他的hashcode就一样，不用每次重新计算了
## 字符串常量池
字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。
当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

## new String("abc")
使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。
    "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
    而使用 new 的方式会在堆中创建一个字符串对象。
String重写了Object类的hashcode和toString方法

## String + 的原理
String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程是： String c = new StringBuilder("xxyy ").append(a).append("zz").append("mm").append(b).toString();
底层通过 StringBuilder实现
```



#### 9.JAVA权限修饰符

![点击查看图片来源](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR19GaXNoMDMxMw==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

#### 10.JAVA反射机制

反射(Reflection)，是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展。

##### 使用方法

| 操作                                           | 说明                                                         |
| ---------------------------------------------- | :----------------------------------------------------------- |
| getName()                                      | 获得类的完整名字                                             |
| getFields()                                    | 获得类的public类型的属性                                     |
| getDeclaredFields()                            | 获得类的所有属性。包括private 声明的和继承类                 |
| getMethod(String name, Class[] parameterTypes) | 获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。 |
| newInstance()                                  | 通过类的不带参数的构造方法创建这个类的一个对象               |
| getSuperClass()                                | 用于返回表示该 Class 表示的任何类、接口、原始类型或任何 void 类型的超类的Class(即父类)。 |

##### 应用场景

1. 框架中：Hibernate、Spring等框架中都有使用反射技术。比如，在Hibernate中对象持久化就需要将对象转化为实体类，然后存储到数据库中，就需要通过反射来动态创建实体类对象、获取类的属性和方法等。
2. 动态代理：在Java中，代理模式非常常见。如果要在程序运行期间动态的创建代理对象，就需要通过反射获取类、方法等信息。
3. 序列化和反序列化：在Java中，序列化和反序列化都需要使用到反射技术。序列化会将对象转化成字节流，反序列化则将字节流还原为对象。在这个过程中，需要借助反射技术来获取对象的属性信息。
4. 单元测试：在JUnit等测试框架中，测试类会通过反射获取被测试类的信息并执行测试方法。
5. 动态的加载类：Java中的ClassLoader就是通过反射实现的。ClassLoader可以在程序运行期间动态的加载类，从而扩展程序功能。

##### 实现方式

```java
Class c1=Foo.class；
Class c2 = foo1.getClass();
c3=Class.forName("Foo的相对路径");
```

#### 11.java 中 stream api 和 channel api 的区别

- stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）
- stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用

#### 12.ArrayList和LinkedList区别

- ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固 定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会  涉及到元素的移动
- LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历
- 遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需 要对list重新进行遍历，性能消耗极大。

#### 13HashMap和HashTable有什么区别？其底层实现是什么？

- （1） HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；
- （2） HashMap允许key和value为null，而HashTable不允许

##### 底层实现：数组+链表实现

jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

- 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，
- 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，
- 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表
- key为null，存在下标0的位置

#### 14.Java中的异常体系

Java中的所有异常都来自顶级父类Throwable(万物即可抛)，有两个子类:Error、 Exception 

- Error是程序无法处理的错误（Out OfMemoryεror、 Thread Death），一旦出现这个错误，大多数情况下程序将被迫停止运行。
- Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常：

```
RunTimeException常常发生在程序运行过程中，具有不确症性,主要是由于程序的逻辑引起的,难以排查，如除0的产生的异常,会导致程序当前线程执行失败。
CheckedException常常发生在程序编译过程中，必须要使用ry- catch(或者 throws)否则编译不通过,会导致程序编译不通过。
```

#### 15.Java中final关键字

根据修饰变量的作用范围，final会有不同的特性：
 ● **final修饰局部变量时**，在使用之前必须被赋值一次才能使用；
 ● **final修饰成员变量时**，如果在声明时没有赋值，则叫做“空白final变量”，空白final变量必须在构造方法或静态代码块中进行初始化。
根据修饰变量的数据类型，比如在修饰基本类型和引用类型的变量时，final也有不同的特性：
 ● **final修饰基本类型的变量时**，不能把基本类型的值重新赋值，因此基本类型的变量值不能被改变。
 ● **final修饰引用类型的变量时**，final只会保证引用类型的变量所引用的地址不会改变，即保证该变量会一直引用同一个对象。因为引用类型的变量保存的仅仅是一个引用地址，所以final修饰引用类型的变量时，该变量会一直引用同一个对象，**但这个对象本身的成员和数据是完全可以发生改变的。**

```markdown
- java.lang.String类是final类型的,不可以继承
- final, finally, finalize的区别。
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成final类型。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用
```

#### 16.静态变量和实例变量、static和final

在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f3030377338484a556c7931673578627562303663646a33306d6e30386c676f742e6a7067.jpeg)

```markdown
## final的好处
1.final关键字提高了性能。JVM和Java应用都会缓存final变量。 
2.final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 
3.使用final关键字，JVM会对方法、变量及类进行优化。
```

#### 17.ArrayList和Vector的区别

（1）同步性：

Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。

备注：对于Vector&ArrayList、Hashtable&HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。

（2）数据增长：

即Vector增长原来的一倍，ArrayList增加原来的0.5倍，ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。

```markdown
## List和Map区别
一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合
List中存储的数据是有顺序，并且允许重复；
Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
List，Set继承Collection接口
```

#### 18.Java创建对象的4种方式

- 1.使用new创建对象 使用new关键字创建对象应该是最常见的一种方式，但我们应该知道，使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。
- 2.使用反射的机制创建对象 使用Class类的newInstance方法
- 3.采用clone clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。要调用clone方法需要实现Cloneable接口
- 4.采用序列化机制 使用序列化时，要实现实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。

#### 19.Object有哪些方法

hashcode()、equals()、toString()、getClass()、wait、notify()、notifyAll()、finalize()、clone()

#### 20.JAVA浅拷贝与深拷贝

（1）浅拷贝实现方式：类实现Cloneable接口，并且重写clone()方法。BeanUtils.cloneBean(Object obj)

（2）深拷贝：主要是针对类内部的复杂引用变量。两种方式：1)复杂引用也实现Cloneable，并重写clone（）方法，然后在父对象重写的clone方法中将该复杂引用指向克隆后的引用  2）直接将需要克隆的对象进行序列化，然后反序列化就可以得到一个深拷贝的对象。SerializationUtils.clone(T object)

#### 21.成员变量和局部变量的区别

**语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

**存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

**生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

**默认值**：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

```markdown
## 为什么成员变量有默认值，局部变量必须手动赋值？
如果没有默认值，变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。
成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。
成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。

##  静态方法为什么不能调用非静态成员?
1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。
```

#### 22.Java的动态代理

Java代理模式是一种结构型设计模式，它允许通过创建一个代理对象来间接访问另一个对象，从而控制对原始对象的访问。

包括两个主要组件：代理类和实际的对象。当客户端调用代理对象的方法时，代理对象会将请求转发到实际对象，并在必要时添加额外的功能。这些额外的功能可以是日志记录、安全性检查、缓存等等。

```markdown
静态代理：需要手动编写代理类，代理对象和原始对象都需要实现相同的接口。
动态代理：使用Java反射机制自动生成代理类，在运行时绑定原始对象和代理对象，无需手动编写代理类，但原始对象必须实现接口。
动态代理更加灵活，代理类在程序运行时创建。
## 动态代理应用场景
常见的各种开源框架如：Spring AOP、retrofit（create() 方法）、注解（如wmrouter）、加事务、加权限、加日志
```

#### 23.Java迭代器

Java迭代器（Iterator）是 Java 集合框架中的一种机制，是一种用于遍历集合（如列表、集合和映射等）的接口。

它提供了一种统一的方式来访问集合中的元素，而不需要了解底层集合的具体实现细节。

- **next()** - 返回迭代器的下一个元素，并将迭代器的指针移到下一个位置。
- **hasNext()** -  用于判断集合中是否还有下一个元素可以访问。
- **remove()** - 从集合中删除迭代器最后访问的元素（可选操作）。

```markdown
## Iterator 和 ListIterator 的区别
Iterator可以迭代所有集合;ListIterator只能用于List及其子类
ListIterator有add方法，可以向List中添加对象;Iterator不能
ListIterator有hasPrevious()和previous()方法，可以实现逆向遍历;Iterator不可以
ListIterator有 nextIndex() 和previousIndex()方法，可定位当前索引的位置;Iterator不可以
ListIterator有set()方法，可以实现对List的修改;Iterator仅能遍历，不能修改。
```

### 二、Java多线程

#### 线程池

##### 线程池原理

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/c83d70cf3bc79f3d57910653b60ae21d738b299c.jpeg)

创建方式：newFixedThreadPool (固定数目线程的线程池)、newCachedThreadPool(可缓存线程的线程池)、newSingleThreadExecutor(单线程的线程池)、newScheduledThreadPool(定时及周期执行的线程池)、new ThreadPoolExecutor() （自定义的方式创建）

```markdown
## 线程池七大参数
- corePoolSize（核心线程数）
线程池当中线程数最基本上的数量：只有当工作任务队列满了才会有新的线程被创建出来，此时线程数才会大于该值

- maximumPoolSize（最大线程数）
线程池中允许的最大线程数：当前任务队列满了并且小于该值的时候线程才会被创建，否则交给拒绝策略

- 最大线程的存活时间：如果当前线程空闲且线程数量大于核心数则线程销毁的超时时间

- unit 时间单位

- 阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列

- 线程工厂：用于生产线程

- 任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争

## 线程池的好处
1⃣️降低资源消耗
2⃣️提高响应速度
3⃣️使线程便于管理
```

##### 线程提交后的执行过程

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/060828381f30e924a34e6fad47a3410a1f95f7ff.jpeg)

a.如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务!
b.如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。
c.如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务;
d.如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者"我不能再接受任务了"

##### 五种阻塞队列

- ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。
- LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列
- DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。
- PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；
- SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。

##### 线程创建方式

- (1)继承 Tread 类
- (2)实现 Runnable 接口
- (3)实现 Callable 接口：带有返回值

##### ThreadLocal关键字

- 主要用于线程本地化存储，即只有本线程才能对该变量进行查看或者修改
- 使用时需要注意，在不使用该变量的时候，一定要调用`remove`方法删除变量，否则可能会造成内存泄露的问题
- ThreadLocal 是由 ThreadLocalMap 实现

##### volatile关键字

1. 可见性：使用volatile关键字会强制将修改的值立即写入主存；

```java
//线程1
boolean stop = false;
while(!stop){
	doSomething();
}
//线程2
stop = true;
```

2. 确保有序性：利用volatile的变量保证线程的执行顺序

```java
volatile boolean inited = false;
//线程1:
context = loadContext(); 
inited = true; 
//线程2:
while(!inited ){
	sleep()
}
doSomethingwithconfig(context);
```

#### CAS锁（CompareAndSet）

是多线程情况下,线程安全的执行机制，CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。

```markdown
1、在没有指定线程的优先级的时候，线程都带有普通的优先级。
2、线程的优先级可以分为1到10；10代表最高的优先级，1代表最低的优先级，普通优先级是5。
3、优先级最高的线程在运行时给予优先，但不能保证线程启动后立刻就进入运行状态。
4、与线程池中等待的线程相比，正在运行的线程拥有更高的优先级。
5、由调度程序来决定执行哪一个线程。
6、用setProperty()来设定用线程的优先级。
7、在线程的start()方法调用之前，应该指定线程的优先级。
```

#### AQS同步机制（AbstractQueuedSynchronizer）

AQS的核心思想是：通过一个volatile修饰的int属性state代表同步状态，例如0是无锁状态，1是上锁状态。多线程竞争资源时，通过CAS的方式来修改state，例如从0修改为1，修改成功的线程即为资源竞争成功的线程，将其设为exclusiveOwnerThread，也称【工作线程】，资源竞争失败的线程会被放入一个FIFO的队列中并挂起休眠，当exclusiveOwnerThread线程释放资源后，会从队列中唤醒线程继续工作，循环往复。

#### Synchronized 锁

在Java中，synchronized是一种关键字，用于实现线程同步。它可以用于方法或代码块，用于保证同一时间只有一个线程可以执行被synchronized修饰的代码。

synchronized的锁机制有两种使用方式：

1. 同步方法：可以在方法声明中使用synchronized关键字。当一个线程调用同步方法时，会自动获取该方法所属对象的锁，其他线程将被阻塞，直到该线程释放锁为止。
2. 同步代码块：使用synchronized关键字可以修饰一段代码块。当一个线程进入synchronized代码块时，它会尝试获取锁，如果锁已经被其他线程获取，那么该线程将被阻塞，直到锁被释放。

```markdown
synchronized锁是基于对象的，每个对象都有一个关联的锁。当多个线程同时访问某个对象的同步方法或同步代码块时，它们会竞争该对象的锁。
    1.如果synchronized锁加在实例方法上，则默认使用的是this锁
    2.如果synchronized锁加载静态方法上，则默认使用的是  类名.class  锁（Java反射技术中说到一个class文件只会在jvm中存在一份）

另外，要注意避免过多地使用synchronized，因为过多的同步操作可能会导致性能下降。在某些情况下，可以考虑使用更灵活的并发工具，如Lock和Condition接口
```

对象头：

![835de3c09bc24730bf761524461dd19a](https://gitee.com/xu_zuyun/picgo/raw/master/img/835de3c09bc24730bf761524461dd19a.png)

自旋：**线程会一直循环检查该锁是否被释放，直到获取到该锁为止。这个循环等待的过程被称为自旋**

1）偏向锁

只有一个线程争抢锁资源的时候.将线程拥有者标识为当前线程。引入了偏向锁目的是来尽可能减少无竞争情况下的同步操作开销。当一个线程访问同步块并获取对象的锁时，会将锁的标记记录在线程的栈帧中，并将对象头中的Thread ID设置为当前线程的ID。此后，当这个线程再次请求相同对象的锁时，虚拟机会使用已经记录的锁标记，而不需要再次进入同步块。

```
偏向锁（Biased Locking）就是为了在无竞争的情况下减少同步操作的开销。它通过记录线程ID来避免对锁的加锁和解锁操作，提高了单线程访问同步代码块时的性能。
```

2）轻量级锁（自旋锁）

一个或多个线程通过CAS去争抢锁,如果抢不到则一直自旋。虚拟机会将对象的Mark Word复制到线程的栈帧中作为锁记录，并尝试使用CAS（Compare and Set）操作尝试获取锁。如果CAS成功，则表示线程获取了轻量级锁，并继续执行同步块。如果CAS失败，说明有竞争，虚拟机会通过自旋（spinning）等待其他线程释放锁

```
轻量级锁是为了减少线程切换的开销。它使用CAS（Compare and Set）操作来尝试获取锁，如果成功则可以继续执行同步块，无需线程切换；如果失败，则会进行自旋操作等待锁的释放。自旋操作避免了线程挂起和切换的开销，提高了多线程竞争时的性能。
使用对象头中的一部分位来存储线程ID和锁标记，不需要额外的内存存储锁的状态。相对于传统的重量级锁，它能够节省内存消耗。
```

3）重量级锁

如果自旋等待不成功，虚拟机会将轻量级锁升级为重量级锁。在这种状态下，虚拟机会将线程阻塞，并使用操作系统的互斥量来实现锁的释放和获取。

需要注意的是，锁的升级是逐级升级的过程，而不会存在降级。换句话说，一旦锁升级到更高级别，就不会回到低级别。

##### 升级过程：

- 1）当只有一个线程去争抢锁的时候,会先使用偏向锁,就是给一个标识,说明现在这个锁被线程a占有.
- 2）后来又来了线程b,线程c,说凭什么你占有锁,需要公平的竞争,于是将标识去掉,也就是撤销偏向锁,升级为轻量级锁,三个线程通过CAS自旋进行锁的争抢(其实这个抢锁过程还是偏向于原来的持有偏向锁的线程).
- 3）现在线程a占有了锁,线程b,线程c一直在循环尝试获取锁,后来又来了十个线程,一直在自旋,那这样等着也是干耗费CPU资源,所以就将锁升级为重量级锁,向内核申请资源,直接将等待的线程进行阻塞.

#### Synchrpnized和lock的区别

（1）synchronized是关键字，lock是一个类，synchronize是在JVM层面实现的，系统会监控锁的释放与否。lock是JDK代码实现的，需要手动释放，在finally块中释放

（2） 用法不一样：synchronize可以用在代码块上，方法上。lock只能写在代码里，不能直接修改方法。synchronized在发生异常时会自动释放锁，lock需要手动释放锁

（3）synchronized是非公平锁、（每个线程获取锁的顺序不是按照线程访问锁的先后顺序获取），lock是可以是公平锁。都是可重入锁

```markdown
## 可重入锁
可重入锁和不可重入锁的最大区别在于，可重入锁允许同一个线程在获得锁之后再次获得该锁，而不可重入锁不允许。
如果一个线程已经获得锁，那么在该线程释放该锁之前，它可以再次获得该锁而不会被阻塞。
    实现原理：
    每次获得锁时，计数器加1，每次释放锁时，计数器减1。只有当计数器为0时，其他线程才有机会获得该锁。
```

#### sleep()和wait()的区别

1. wait()是Object的方法，sleep()是Thread类的方法
2. wait()会释放锁，sleep()不会释放锁
3. wait()要在同步方法或者同步代码块中执行，sleep()没有限制
4. wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒

#### yield()和join()区别

- yield()调用后线程进入就绪状态，告诉当前线程把机会交给其他高优先级的线程
- A线程中调用B线程的join() ,则B执行完前A进入阻塞状态，使并行的程序串行化执行

#### Thread、Runable的区别

Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。

#### JAVA内存模型

![java-runtime-data-areas-jdk1.7](https://gitee.com/xu_zuyun/picgo/raw/master/img/java-runtime-data-areas-jdk1.7.png)

所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的

```markdown
## 栈帧的压入
局部变量表 主要存放了编译期可知的各种数据类型、对象引用。
操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
动态链接 主要服务一个方法需要调用其他方法的场景。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接

## 栈帧的弹出
Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。
```



### 三、JAVA虚拟机（JVM）

![JVM内存模型](https://gitee.com/xu_zuyun/picgo/raw/master/img/JVM内存模型(2).png)

JDK > JRE = Java虚拟机 + Java核心类库

```
（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧
（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一
（3）程序计数器：用于记录当前线程执行到哪里，保存指令执行的地址，方便线程切回后能继续执行代码
线程共享区：
（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代
（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。
```

![图片](https://gitee.com/xu_zuyun/picgo/raw/master/img/7770edaf3e44939cb967a7120d2f21a7.png)

Java是编译与解释结合的语言，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

#### Java程序运行的具体过程

Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行.

具体过程为：**加载、链接、初始化**

```markdown
## 加载
        将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构(InstanceKlass)，然后生成一个代表这个类的java.lang.Class对象。
## 链接
        验证：确保加载的类信息符合JVM规范，没有安全方面的问题。
        准备：正式为类变量（static）分配内存并设置类变量默认值的阶段，这些内存都将在方法区中进行分配。(静态变量的定义使用final关键字，这类变量会在此阶段直接进行初始化)
        解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。

## 初始化
        执行类构造器<clinit>()方法的过程，类构造器<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块的语句合并产生的。（直接访问父类的静态变量，不会触发子类的初始化。子类的初始化cinit调用之前，会先调用父类的cinit初始化方法。）
```
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/5cbffbed7a074cef99db5bc1ecfd117f.png)

##### 类加载机制

- **全盘负责** ：就是当一个类加载器负责加载某 `个Class` 时，该 `Class` 所依赖的和引用的其他 `Class` 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
- **父类委托** ：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该 `Class` ，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- **缓存机制** ：保证所有加载过的 `Class` 都会被缓存，当程序需要使用某个 `Class` 对象时，类加载器先从缓存区中搜索该 `Class` ，只有当缓存区中不存在该 `Class对象` 时，系统才会读取该类对应的二进制数据，并将其转换成 `Class对象` ，存储到缓存区

##### 类加载器有哪些？

- 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，C++编写，（只加载包为java、javax、sun等开头的类。）无法被java程序直接引用。
- 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录（java.ext.dirs属性指定目录、jre/lib/ext、如果用户创建的jar包放在此目录下，也会自动由扩展类加载器加载）。该类加载器在此目录里面查找并加载 Java 类。
- 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。
- 用户自定义类加载器 (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器（可以直接继承URLClassLoader类，这样可以避免自己去编写findClass()方法以及获取字节码流的方式）。

##### 双亲委派模型

双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

一般情况下，由jvm指定的类加载器就是应用类加载器，jvm会自动调用其loadClass(String name)方法来开启类的加载过程。

- **‎loadClass（字符串名称，布尔解析）：‎**‎此方法用于加载 JVM 引用的类。它将类的名称作为参数。这是 loadClass（String， boolean） 的类型。‎
- **‎defineClass（）‎**‎：defineClass（） 方法是‎*‎最终‎*‎方法，不能重写。此方法用于将字节数组定义为类的实例。如果该类无效，则它抛出 ‎**‎ClassFormatError‎**‎。‎
- **‎findClass（字符串名称）：‎**‎此方法用于查找指定的类。此方法仅查找但不加载类。‎
- **‎findLoadedClass（字符串名称）：‎**‎此方法用于验证 JVM 引用的类以前是否被加载过。‎
- **‎Class.forName（字符串名称，布尔值初始化，类加载器加载器）：‎**‎此方法用于加载类以及初始化类。此方法还提供了选择任何一个 ClassLoaders 的选项。如果类装入器参数为 NULL，则使用 Bootstrap 类装入器。‎

```markdown
## 双亲委派的优点
    沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改
    避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性
作用：保证应用程序的稳定有序。
```

##### 父子类的加载顺序

- (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
- (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
- (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
- (4) 父类构造函数
- (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
- (6) 子类构造函数

#### JAVA什么情况下会内存溢出？

堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时

栈溢出：方法调用次数过多，一般是递归不当造成

#### JAVA什么情况下会内存泄漏？

1. 单例模式

   ```
       1、单例类只能有一个实例。
       2、单例类必须自己创建自己的唯一实例。
       3、单例类必须给所有其他对象提供这一实例。
   ```

2. 静态集合类

   ```
   (HashMap、Vector 等集合生命周期和应用程序一致),长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收
   ```

3. 连接（I/O）未释放

   ```
   程序中创建或者打开一个流或者是新建一个网络连接的时候，JVM 都会为这些资源类分配内存做缓存，常见的资源类有网络连接，数据库连接以及 IO 流。如果忘记关闭这些资源，会阻塞内存，从而导致 GC 无法进行清理。
   ```

4. 变量作用域过大

   ```
   一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。
   ```

5. hash值发生改变

```
在HashMap和HashSet这种集合中，常常用到equal()和hashCode()来比较对象，如果重写不合理，会认为每次创建的对象都是新的对象，从而导致内存不断的增长.
```

6. ThreadLocal使用不当

```markdown
ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。一旦线程不在存在，ThreadLocal 就应该被垃圾收集，但线程池有线程重用的功能，因此线程就不会被垃圾回收器回收，变量副本一直在内存中

## 解决方法
用完ThreadLocal一定要记得使用remove方法来进行清除。
```

#### JVM垃圾查找算法

（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题
（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收

```markdown
可以作为GC Roots的主要有四种对象：
    虚拟机栈(栈帧中的本地变量表)中引用的对象
    方法区中类静态属性引用的对象
    方法区中常量引用的对象
    本地方法栈中JNI引用的对象
```

对象的4种引用

![图片](https://gitee.com/xu_zuyun/picgo/raw/master/img/4144a6d4a0642ed469b19ed4782a75a2.png)

#### finalize()方法？

垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法：

- 第一次被标记后，对象在在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可
- 回收特殊渠道申请的内存，一般内存不需要亲自回收，但JNI(Java Native Interface)调用non-Java程序（C或C++）产生的无法被gc自动回收。

#### JVM的垃圾回收算法

（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbjM2NTg4MA==,size_16,color_FFFFFF,t_70-20240103162947320.png)

（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代

```
优点：解决碎片化问题，顺序分配内存简单高效
缺点：只适用于存活率低的场景，如果极端情况下如果对象面上的对象全部存活，就要浪费一半的存储空间。
```



![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbjM2NTg4MA==,size_16,color_FFFFFF,t_70-20240103163017798.png)

（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbjM2NTg4MA==,size_16,color_FFFFFF,t_70-20240103163205587.png)

（4）分代收集算法：一般将 java 堆分为新生代和老年代，比如在新生代中，选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，选择“标记-清除”或“标记-整理”算法进行垃圾收集。

![图片](https://gitee.com/xu_zuyun/picgo/raw/master/img/bd3ee6277775ac9f0021a50ed77787aa.png)

- 年轻代主要分为`Edan`区、Survivor区（`from/S1`区、`to/S2`区），这三者的区域大小划分比例为`8:1:1`
- 年轻代中对象被GC清理在S1与S2轮转`15`次之后会被移到老年代（这个值可以通过JVM参数：–XX:SurvivorRatio 设定，默认值为8）
- 年轻代与老年代区域大小划分比例为`1:2`（该值可以通过JVM参数：-XX:NewRatio 设定）

```markdown
当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

## 第一步：
大对象直接进入老年代
长期存活对象将进入老年代

1. Eden 区
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
2. ServivorFrom
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
3. ServivorTo
保留了一次 MinorGC 过程中的幸存者。
```

![3ff6f9cc5dc34c3ca68b3585212174e2](https://gitee.com/xu_zuyun/picgo/raw/master/img/3ff6f9cc5dc34c3ca68b3585212174e2.png)

```markdown
## 第二步：
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。
MajorGC 采用标记清除算法：
首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

## 第三步：
当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常.

永久代：主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。
```

#### 收集器种类

- Serial收集器： 新生代采用复制算法，老年代采用标记-整理算法。单线程，所以在发生GC时候需要暂停所有线程的工作。
- Parallel Scavenge收集器：新生代采用复制算法，老年代采用标记-整理算法。多线程，Parallel Scavenge收集器关注点是**吞吐量（**高效率的 利用CPU）
- ParNew收集器：（jdk8默认设置的垃圾收集器）新生代采用复制算法，老年代采用标记-整理算法。和Parallel 相似主要用于配合CMS收集器使用。
- CMS收集器：**低延迟**的**并发型**垃圾收集器。尽可能缩短垃圾收集时用户线程的停顿时间，采用“标记-清除”算法，是老年代的垃圾收集器，只能配合ParNew或Serial使用

#### 对象的内存布局

- **对象头**主要由两部分组成：

​	第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据。

- **实例数据**用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。
- **对齐填充**不是必须的，没有特别含义，仅仅起着占位符的作用。是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。

#### 对象怎么访问定位？

Java程序会通过栈上的reference数据（指向对象的引用）来操作堆上的具体对象，对象访问方式也是由虚拟机实现而定的，HotSpot虚拟机主要使用直接指针来进行对象访问，主流的访问方式主要有使用句柄和直接指针两种：

- 对象类型数据就是被虚拟机加载的类信息（对象的类型、父类、实现的接口、方法等）
- 对象实例数据就是被new出来的对象信息（对象中各个实例字段的数据）

![图片](https://gitee.com/xu_zuyun/picgo/raw/master/img/020803b8cf052a6770cb51200db753e9.png)

```
句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息

优点：
reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
```

![图片](https://gitee.com/xu_zuyun/picgo/raw/master/img/020803b8cf052a6770cb51200db753e9-20240104101533612.png)

```
指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销

优点：
速度更快，它节省了一次指针定位的时间开销
```

#### JVM配置

**![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbjM2NTg4MA==,size_16,color_FFFFFF,t_70.png)**

### 四、JAVA 网络

- **BIO**是阻塞I/O，NIO是非阻塞I/O，AIO是异步I/O。BIO每个连接对应一个线程，NIO多个连接共享少量线程，AIO允许应用程序异步地处理多个操作。
- **NIO**和AIO通常比BIO更适用于高并发的网络应用，可以更有效地管理多个连接和I/O操作。
- **AIO**是适合高吞吐量的应用程序，可以异步处理多个I/O操作，而不需要线程等待。但AIO在Java中的支持相对有限，不是所有操作系统都支持。

#### JAVA BIO

![](https://gitee.com/xu_zuyun/picgo/raw/master/img/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f34333833623962363361636534363539626631336631633861346335356365307e74706c762d6b3375316662706663702d7a6f6f6d2d696e2d63726f70.webp)

服务端会有个ServerSocket，每一个ServerSocket都有一个与之对应ClientSocket，每一个连接都需要有一个线程来维护

#### JAVA NIO

1.Java NIO 全称 Java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 NewIO)，是[同步非阻塞](https://www.zhihu.com/search?q=同步非阻塞&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2835854418})的。

Java NIO 的[非阻塞模式](https://www.zhihu.com/search?q=非阻塞模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2835854418})，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持[线程阻塞](https://www.zhihu.com/search?q=线程阻塞&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2835854418})，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。

![](https://gitee.com/xu_zuyun/picgo/raw/master/img/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f61323064353862613839366434326334616162326338373162623266346437397e74706c762d6b3375316662706663702d7a6f6f6d2d696e2d63726f70-20240110230024721.webp)

##### ByteBuffer

缓冲区(ByteBuffer)：缓冲区本质上是一个**可以读写数据的内存块**，可以理解成是一个**容器对象(含数组)**，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。ByteBuffer的指针有postion

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-e689586b7689bcdb1aeab4abd45272ef_1440w.webp)

##### Channel

NIO 的通道类似于流，主要的区别是：通道可以同时进行读写，而流只能读或者只能写。通道可以实现异步读写数据。通道可以从缓冲读数据，也可以写数据到缓冲。BIO的流是单向的，NIO的通道是双向的，可以读也可以写操作。

##### Selector

Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)。Selector 能够检测多个注册的通道上是否有事件发生(注意：多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。

这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。避免了多线程之间的上下文切换导致的开销。

#### 字节流和字符流的区别

字节流：处理字节和字节数组或二进制对象； 字符流：处理字符、字符数组或字符串。

- 1、字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的
- 2、字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容
- 3、Reader类的read()方法返回类型为int ：作为整数读取的字符（占两个字节共16位），范围在 0 到 65535 之间  (0x00-0xffff)，如果已到达流的末尾，则返回 -1 inputStream的read()虽然也返回int，但由于此类是面向字节流的，一个字节占8个位，所以返回 0 到 255 范围内的 int  字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。因此对于不能用0-255来表示的值就得用字符流来读取！比如说汉字.

#### 序列化底层原理

1. 序列化引擎会根据对象时候实现了`Serializable`接口类，如果没有则抛`NotSerializableException`异常，如果实现了则会创建`ObjectOutputStream `对象，绑定到输出流上
2. 扫描对象中`static`、 `transient`关键字的字段，不对其进行序列化，Object对象流不写入，也不读出
3. 如果对象有其他对象的引用则需要递归将引用对象也进行序列化

序列化引擎：Dubbo 框架中的 Hession、JDK 自带的 Serializable、跨语言的 Hessian、ProtoBuf、ProtoStuff

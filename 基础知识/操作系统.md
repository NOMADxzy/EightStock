## 操作系统

[参考](https://blog.csdn.net/qq_61888137/category_12436223_2.html)

### 一、概念

操作系统是管理计算机硬件与软件资源的系统软件，提供一个让用户和其他软件与硬件互动的平台。它位于用户应用程序和计算机硬件之间，充当两者之间的桥梁或中介。

包括：进程管理、内存管理、文件系统管理、设备管理、用户界面（CLI、GUI）

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/dfd6f2643180429899b267f5cb0a6286.png)

**操作系统的四个特性？**

并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时刻有多个事件，多处理器系统可以使程序并行执行）

共享：系统中的资源可以被内存中多个并发执行的进线程共同使用

虚拟：通过分时复用（如分时系统）以及空分复用（如虚拟内存）技术把一个物理实体虚拟为多个

异步：系统进程用一种走走停停的方式执行，（并不是一下子走完），进程什么时候以怎样的速度向前推进是不可预知的

**用户态和内核态**

内核态：可以执行特权指令（如内存清零指令），cpu可以访问内存的所有数据，包括外围设备。

用户态：只能执行非特权指令，只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

```
内核速度快但是资源有限，能控制的进程数不多，所以需要速度慢一些的用户态协助，但是为了避免用户态被恶意利用，所以限制了用户态程序的权限。
```

**什么时候转换用户态和内核态？**

用户->内核：

1. **系统调用**：用户进程主动发起的。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()就是执行一个创建新进程的系统调用
2. **发生异常**：会从当前运行进程切换到处理次此异常的内核相关程序中
3. **外围设备的中断：**所有程序都运行在用户态，但在从硬盘读取数据、或从键盘输入时，这些事情只有操作系统能做，程序需要向操作系统请求以程序的名义来执行这些操作。这个时候用户态程序切换到内核态。

内核->用户：

执行一条**特权指令――修改PSW**的标志位为“用户态”

**开销：**

1. **上下文切换开销**：

   - CPU 需要保存当前进程的上下文（寄存器值、程序计数器等），以便以后能够恢复。
   - 加载内核进程或线程的上下文，包括将内核栈切换到当前进程所使用的内核栈等。

2. **特权级切换**：

   - 需要通过特权指令将 CPU 切换到内核态，这通常需要额外的时间。

3. **内存访问开销**：

   - 在用户态和内核态之间切换时，可能需要更新页表或者进行地址空间相关的操作，尤其在虚拟内存系统中。

   - 切换可能导致 CPU 缓存失效，特别是对于缓存敏感的应用，刚加载到缓存中的数据可能在切换到内核态后不再有效。

#### 什么是操作系统中断

1. 当发生中断时，cpu立即进入内核态
2. 当发生中断后，当前进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理
4. 中断分为内中断和外中断。

![中断](https://gitee.com/xu_zuyun/picgo/raw/master/img/中断.webp)

##### 内部中断：

陷阱（陷入）：由陷入指令（访管指令，进行系统调用）引发，是应用程序故意引发的。
故障：由错误条件引起的,可能被`内核程序修复`。内核程序修复故障后会把 CPU使用权还给应用程序，继续执行下去。如:缺页故障。
终止：由致命错误引起,内核程序无法修复该错误，因此一及**不再将CPU使用权还给引发终止的应用程序**,而是直接终止该应用程序。如:整数除0、非法使用特权指令。

##### 外部中断：

不可屏蔽：电源异常，CPU、主板遇到故障

可屏蔽：计时器到期、I/O外围设备完成传输、网卡完成发送/接收的时刻

硬中断和软中断：一种**软中断**，例如代码调用 `INT` 指令触发，一种是**硬件中断**，就是硬件通过**中断控制器**触发的。

**中断处理流程：**

1. 当CPU检测到中断信号后，

2. 判断中断信号类型

3. 若是内中断:CPU在执行指令时会检查是否有异常发生；

4. 若是外中断:每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。

5. 然后根据中断信号的类型查询“**中断向量表**”，以此来找到相应的中断处理程序在内存中的存放位置。

   ```
   保护被中断进程的 CPU 上下文；
   转入相应的设备中断处理函数；
   进行中断处理；
   恢复被中断进程的上下文
   ```

##### 软中断 和 硬中断

硬中断（Hardware Interrupts）——键盘、鼠标、硬盘

- **触发来源**：硬中断由外部硬件设备产生，如键盘输入、鼠标移动、网络活动或其他外设事件。
- **即时性**：当硬件设备需要CPU立即处理某件事情时会发送硬中断信号给CPU，硬中断一般具有很高的优先级。
- **同步性**：硬中断不能被其他硬中断打断（可被屏蔽），但可以打断软中断和正常的进程执行。

软中断（Software Interrupts）——系统调用相关

- **触发来源**：软中断由操作系统内核生成，可以是对系统调用的响应，或者是由硬中断处理程序触发的非紧急任务。
- **即时性**：软中断相对于硬中断来说不那么紧迫。它们经常用于延迟处理硬中断中的底层工作，比如数据包的后期处理。
- **同步性**：软中断可以被其他软中断或硬中断打断。它们通常运行在较低的优先级上，并且可能会根据系统负载和调度策略被推迟处理。

### 二、进程与线程

#### **什么是进程和线程？**

##### 区别

```
进程是是计算机中的一段程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位。
线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。
```

- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
- 切换：线程上下文切换比进程上下文切换要快得多。
- 拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源（全局变量和虚拟内存）。
- 系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。
- 进程间不会相互影响，但一个线程挂掉将导致整个进程挂掉

##### 线程

1. **用户级线程（User-Level Threads, ULTs）**： 用户级线程由用户进程管理，不需要内核的直接干预。这些线程通常由一个用户级的线程库，如POSIX Pthreads或者Java线程库来管理。用户级线程的创建、同步和管理都在用户空间进行，因而它们的操作通常是快速的。然而，操作系统并不知道这些线程的存在，所以真正的调度决策仍然是基于包含这些线程的进程。
2. **内核级线程（Kernel-Level Threads, KLTs）**： 内核级线程由操作系统内核管理和调度。这意味着线程的创建、同步和销毁等操作都需要通过系统调用来完成，进而需要更多的上下文切换开销。但优势在于，内核级线程可以被操作系统看见，因此可以更好地利用多核处理器的优势，实现真正的并行执行。

**并发和并行**

并发就是在一段时间内，多个任务都会被处理；

并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成。

**多线程相较单线程的好处**

1、并发提升程序执行效率 

2、提升CPU利用率，访存、输入输出等耗时操作时可以切换线程来执行。

3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。

```markdown
## 进程必须至少拥有一个线程

每个进程`至少包含一个线程`，这个线程称为主线程。

当操作系统启动一个进程时，它会创建一个初始线程（即主线程），该线程开始运行程序的入口点（如 `main` 函数）。如果需要的话，该主线程可以创建更多的辅助线程，从而并发执行不同的任务。
```

##### 协程

—— 协程是一种用户态的轻量级线程

协程可以理解为可以暂停执行的函数。它拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，**可以不加锁的访问全局变量**（如果确保了只有一个协程能够访问此全局变量），所以上下文的切换非常快。

协程不属于操作系统的,只是用来调度协程的,但是协程的执行其实还是由线程执行的,协程可以认为是运行在线程上的代码块

优点：

- 开销小：不需要操作系统进行上下文切换，因此协程的创建和切换通常比线程更快
- 非阻塞：一个协程在等待某些资源时可以暂停执行，让出控制权给其他协程，提高整体应用的吞吐量。
- 通信机制：线程实现数据共享的方式是共享内存,而协程是通信,这就避免了线程安全的问题,避免了锁竞争.

```markdown
`协程适合做IO密集型任务`
## 为什么？
1. 资源占用少、上下文切换开销小
因为IO操作经常涉及等待（如等待网络响应或磁盘读写），而在等待期间，协程可以快速切换，让出执行权给其他协程，从而高效地利用系统资源。

2. 非阻塞式设计
协程通常与异步IO操作配合使用。当协程执行到一个会导致阻塞的IO操作时，它可以挂起自己（yield），允许其他协程继续运行。只有当IO操作完成并且数据准备好了，原来的协程才会被恢复执行。这种模式充分利用了IO密集型任务中CPU等待IO的时间，使得CPU可以去做其他工作。

3. 更好的并发控制
协程提供了更细粒度的并发控制，因为它们是由程序员在用户空间直接管理的。这意味着开发者可以根据程序的需求，精确地控制何时以及如何进行协程之间的切换，这对于IO密集型任务来说非常有用。
```

```markdown
`不适合cpu密集型任务`
## 为什么？
非抢占式调度：协程通常采用`非抢占式`的调度方式。在CPU密集型任务中，长时间的计算可能会导致协程占据CPU资源而不释放，进而影响系统的响应性。

没有利用`多核优势`：协程通常运行在单个线程中，并不能直接利用多核处理器的优势。而在CPU密集型任务中，通常希望使用多线程来利用所有可用的CPU核心。
```

##### 守护线程

​	守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种，

1. 守护线程，比如垃圾回收线程，就是最典型的守护线程。
2. 用户线程，就是应用程序里的自定义线程。

**线程的切换**

线程是被内核所调度,线程被调度切换到另一个线程上下文的时候,需要保存一个用户线程的状态到内存(切出),恢复另一个线程状态到寄存器(切入),然后更新调度器的数据结构,这几步操作涉及到用户态到内核态的切换,开销比较多.

1. 保存当前线程的上下文，包括寄存器和程序计数器。

2. 加载下一个线程的上下文。

   （进程切换则包含了以上内容加上整个虚拟地址空间的更换。）

##### 线程的调度

###### 抢占式调度

1. **定义**：在抢占式调度中，当前运行的任务可以被操作系统挂起（暂停），以便另一个更高优先级的任务可以运行。这意味着任务对处理器的控制是可以被抢占的。
2. **上下文切换**：此策略需要频繁进行上下文切换，因为任何时候一个高优先级的任务出现都可能会导致当前任务的中断。
3. **响应性**：抢占式调度通常有更好的响应性，尤其适用于共享资源和多任务处理环境，能够快速响应紧急任务。
4. **适用场景**：适用于实时操作系统（现代操作系统如Windows、Linux和UNIX等）和需要高度交互性的系统。

###### 非抢占式调度

1. **定义**：在非抢占式调度中，一旦任务开始执行，它将持续运行直到完成或者主动放弃CPU（例如，通过输入/输出操作引起的阻塞）。
2. **上下文切换**：这种方法通常涉及较少的上下文切换，因为任务不会被突然打断。
3. **响应性**：响应性可能较差，特别是当有长任务执行时，短任务可能需要等待较长时间才能得到处理。
4. **适用场景**：适用于任务执行时间可预测且任务间互不影响的场景，如某些嵌入式系统或批处理系统。

**线程是可以并行的，协程是并发的.**

```markdown
## 线程和协程有什么区别呢？
1、线程是抢占式，而协程是非抢占式的，同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 
2、线程是协程的资源。协程通过 可以关联任意线程或线程池的执行器（Interceptor）来间接使用线程的资源的。
3、线程切换的开销更大，需要内核态
4、协程是用户态实现的，操作系统无法利用多核心优势
```

##### 什么情况下用到多进程编程？

**模块化：**将复杂应用拆分成多个独立的模块，每个模块作为一个单独的进程运行，可以简化设计，便于管理和维护。

**稳定性和隔离性：**一个进程崩溃不会直接影响到其他进程

**分布式场景：**在分布式系统中，多进程可以运行在不同的机器上，并且通过网络通信共同完成任务。

#### **进程间通信方式：**

##### 4种方式

1、管道通信：管道是一种半双工的通信方式，数据只能单向流动。匿名管道只能在有血缘关系的进程间进行通信，但命名管道可以让两个毫无关系的进程进行通信。

```markdown
1⃣️如果我们想在不相关的进程间交换数据，我们可以用到FIFO文件来进行通信，这个文件也被称之为命名管道。
2⃣️命名管道其实就是一种特殊的文件类型。
3⃣️进程间通信的原理就是让两个独立的进程看到同一份文件，通过在这个文件里进行读写，就实现了两个进程间的通信了。
匿名管道是通过子进程会继承父进程的PCD的特性，实现两个进程看到同一份文件来实现的。而命名管道是直接创建了一个FIFO文件来实现，两个不相关的进程看到同一个文件的。
    FIFO是Linux基础文件类型中的一种（是一种伪文件），以伪文件形式存在于文件系统中，但FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道（可以理解为内核中的一块内存吧）。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。有名管道的名字存在于文件系统中，内容存放在内存中。
```

2、消息队列

3、共享内存。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

4、信号量。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

##### 信号量与互斥锁的不同

- 信号量（semaphore[ˈseməfɔ:(r)]）用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。
- 互斥锁（Mutual exclusion，缩写 Mutex）是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。

> mutex是semaphore的一种特殊情况（n=1时）

**死锁**

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。

```markdown
## 死锁产生的四个必要条件：

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源
- 不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺
- 循环等待：进程之间循环等待着资源

## 避免死锁的方法：
1.静态策略：预防死锁

- 使用SPOOLING技术虚拟成共享资源，但大部分情况下互斥条件不能破坏，因为加锁就是为了保证互斥
- 一次性申请所有的资源，避免线程占有资源而且在等待其他资源
- 占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源
- 按序申请资源，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源
2.动态策略：避免死锁

- 银行家算法
安全序列：所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。
只要能找出一个安全序列，系统就是安全状态。(如果系统处于安全状态，就一定不会发生死锁,如果系统进入不安全状态，就可能发生死锁)
核心思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。

可用资源（Available）：系统中当前可用的各种资源数量。
最大需求（Max）：每个进程可能需要的最大资源量。
已分配资源（Allocation）：目前每个进程已经被分配的资源量。
需求资源（Need）：为完成任务，每个进程还需要的资源量。

    检查当前的剩余可用资源是否能满足某个进程的最大需求，
    如果可以，就把该进程加入安全序列,并把该进程持有的资源全部回收。
    不断重复上述过程，看最终是否能让所有进程都加入安全序列。

操作系统策略：

1. 请求资源量检查：首先，算法会检查进程发出的资源请求量是否超过了事先声明的最大需求。如果请求量超过了该进程可能需要的最大资源量（即 Request[i] > Need[i]），则请求是非法的，因此会被拒绝。

2. 资源可用性检查：若请求没有超过最大需求，算法接着检查当前是否有足够的可用资源满足请求。如果系统不具备足够的资源（即 Request[i] > Available），那么进程就必须等待，因为资源目前不可用。

3. 假设资源已经分配：如果资源足够，银行家算法会尝试将这些资源暂时分配给请求进程，并更新相应的资源表（减少可用资源 Available，增加已分配资源 Allocation，并减少剩余需求 Need）。

4. 检查系统的安全状态：通过模拟赋予请求资源后，
- 如果存在一个安全序列，则假设的资源分配实际上会被允许，并且进程可以获得请求的资源。
- 如果无法找到安全序列，那么假设的资源分配将被撤销，进程的资源请求将被拒绝，因为它可能会引起系统进入不安全状态，增加死锁的风险。
```

#### 检测与解除死锁

**判断死锁**：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。

- 如果一个进程所请求的资源都还有剩余，可以支持该进程继续运行，则该节点称为——非阻塞节点
- 如果一个进程的某个请求资源已全部分配，则该进程无法继续运行，则该节点称为——阻塞节点

不断的尝试从非阻塞节点开始运行并释放资源，看能否去除所有的边

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/696686fce1ea4d359fbe60af104d9c24.png)

```markdown
## 解除死锁：
资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
进程终止：终止一个或多个死锁进程。这可能涉及优先级考量，如最小代价原则，选择代价最小的进程进行终止。
进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。
```

#### 进程模型

##### 1对1模型

- 每个用户线程对应一个内核线程
- 不会导致阻塞

##### 1对n模型

- 多个用户线程映射到一个内核线程，如果一个用户线程阻塞了（例如执行 I/O 操作），整个进程会阻塞，因为所有用户线程依赖于一个内核线程。
- 这种模型无法有效利用多核系统的并发能力。

##### n对n模型

- 多个用户线程映射到多个内核线程。
- 某个用户线程阻塞时，其他用户线程可以继续运行，不会影响整个进程。

#### **进程调度策略？**

- **先来先服务**：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，对`I/O`密集型进程也不利，因为这种进程每次进行`I/O`操作之后又得重新排队。

- **短作业优先**：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。

- **最短剩余时间优先**：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。

- **时间片轮转**：将所有就绪进程按 `FCFS` 的原则排成一个队列，每次调度时，把 `CPU` 时间分配给队首进程，该进程可以执行一个时间片。`当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾`，同时继续把 CPU 时间分配给队首的进程。
  时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。
  
- **优先级调度**：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以`随着时间的推移增加等待进程的优先级`。

- **多级反馈队列调度：**通过使用多个优先级队列来调度进程，不同优先级的队列有不同的调度策略。系统动态调整进程在不同队列中的位置，尤其是针对不同类型的任务（如I/O密集型和CPU密集型任务）。

  ​	•	新创建的进程通常放在较高优先级的队列中，优先被调度。

  ​	•	如果一个进程占用过多CPU时间，优先级会逐步降低，移到低优先级队列。

  ​	•	如果进程处于等待状态（如I/O操作），其优先级可能会提升，从而加快响应。

  ​	•	**调度策略**：在高优先级队列中使用较短的时间片，而在低优先级队列中使用较长的时间片。这样，短期任务（如交互式进程）能迅速获得CPU，而长期任务（如后台进程）也能得到公平的执行。

```markdown
# 非抢占方式：
一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断，或任何其它原因，去抢占该正
在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。
# 抢占方式：
允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机，重新分配给另一进程。n抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出统开销也较大。
```

#### **进程的状态**

创建、就绪、运行、终止、阻塞。

![image-20220120121814056](https://gitee.com/xu_zuyun/picgo/raw/master/img/83105e7aae933556bb11bd878912f4b6.png)

**运行态→阻塞态**：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。 **阻塞态→就绪态**：则是等待的条件已满足，只需分配到处理器后就能运行。 **运行态→就绪态**：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。 **就绪态→运行态**：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。

#### 父子进程

##### fork创建

子进程得到与父进程用户级虚拟地址空间相同但独立的一份副本（包括代码和数据段、堆、共享库以及用户栈）还有与父进程任何打开文件描述符相同的副本。这意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。**子进程只执行fork之后的代码**

它们有不同的 PID。**fork函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。创建进程过程中，可以**通过 fork 的返回值区分父进程和子进程，失败时返回-1，在父进程中返回子进程的 PID。在子进程中返回 0。

```markdown
## 特点
它将获得父进程的数据空间，堆和栈的副本，这些`都是副本`，父子进程并不共享这部分的内存。也就是说，子进程对父进程中的同名变量进行修改并不会影响其在父进程中的值。
fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但`父子进程运行顺序是不定`的，它取决于内核的调度算法
```

##### vfork创建

vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。

```markdown
## 特点
用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec或exit，vfork的好处是在子进程被创建后往往`仅仅是为了调用exec`执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，
```

##### clone创建

系统调用fork()和vfork()是无参数的，而clone()则带有参数，将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些由参数列表中的 clone_flags来决定。

```markdown
## 特点
clone()返回的是子进程的pid，clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。
```

**若父进程先结束**

- 子进程成为孤儿进程，被 init 进程收养

- 子进程变成后台进程

  ```markdown
  ## shell进程
  命令行界面（Command Line Interface, CLI）中启动一个进程时，这个新启动的进程通常会成为启动它的shell进程的子进程。Shell是运行在终端窗口中的程序，它解释你输入的命令并执行相应的程序。
  
  - 当一个终端关闭时:
  与之相关的任何后台进程（没有用nohup启动，并且没有断开与终端的关联）通常会收到SIGHUP信号并默认结束。
  如果这些后台进程持续运行，则它们的父进程会变成init或者systemd
  ```

  ```markdown
  ## 后台进程
  指在操作系统中运行，但不从用户终端直接控制的进程 —— 系统服务、调度作业、维护任务
  它们通常还具有`较低的优先级`，因此它们不会影响到前台用户的活动。
  `守护进程`也是一种特殊类型的后台进程，它在系统启动时就开始运行，直到系统关闭。
  
  - 在命令行启动一个程序，并希望该程序继续运行即使关闭了终端时，你可以将其放在后台执行
  python myscript.py &
  `myscript.py依然是bash shell的子进程`，但shell不会等待其结束，而是立即给用户提供新的命令提示。
  ```

**若子进程先结束**

-  父进程如果没有及时回收，子进程变成僵尸进程

### 三、内存管理

#### 程序执行流程

> ### 1. 程序加载
>
> 当程序启动时，操作系统会进行如下步骤：
>
> 1. **读取程序文件**：操作系统会从磁盘读取程序的可执行文件（如 ELF、PE 等格式）。
> 2. **加载程序到内存**：将程序的不同部分加载到内存中，包括代码段、数据段、堆和栈。
>
> ### 2. 代码段（Code Segment）
>
> - **定义**：代码段是程序中包含的所有可执行指令的区域，通常是只读的，防止程序在运行时修改自己的指令。
>
> - 流程
>
>   ：
>
>   1. **程序计数器**（PC/Instruction Pointer）指向代码段中的当前指令。
>   2. **指令获取**：CPU从代码段中读取指令并执行。
>   3. **顺序执行**：指令按照顺序执行，直到遇到条件跳转或函数调用等改变控制流的操作。
>
> ### 3. 数据段（Data Segment）
>
> - **定义**：数据段用于存放程序中定义的全局变量和静态变量。数据段通常分为 initialized (已初始化) 和 uninitialized (未初始化) 两部分。
>   - **已初始化数据段**：存放程序中已赋初值的全局变量和静态变量。
>   - **未初始化数据段（BSS段）**：存放未赋初值的全局变量和静态变量，不在程序文件中存值，通常在程序启动时再初始化为零。（int x）
> - **流程**：
>   1. **初始化**：操作系统在加载时将已初始化的数据复制到数据段，而未初始化的数据段会被清零。
>   2. **数据访问**：程序在运行过程中，可以通过变量名访问数据段内的变量。访问时，程序会生成相应的地址并与数据段相结合进行读取和写入。
>   3. **生命周期**：数据段的生命周期从程序加载开始到程序运行结束。
>
> ### 4. 堆和栈
>
> - **堆（Heap）**：用于动态内存分配，程序运行期间可以随意申请和释放内存。
> - **栈（Stack）**：用于存储局部变量和函数调用信息，具有先进后出（LIFO）的特性。
>
> ### 5. 总结
>
> 1. **程序加载**：程序文件被加载到内存中。
> 2. **代码执行**：CPU从代码段中提取并执行指令。
> 3. **数据处理**：数据段存放全局和静态变量。
> 4. **动态内存**：堆和栈分别用于动态和局部存储。

#### 堆和栈

- 1.栈的申请是由系统自动调度的，所以申请效率较快，堆的申请是由人为申请，效率没栈快

- 2.栈的空间由系统开辟空间较小，堆的空间较大

- 3.栈是一级缓存，调用完就立即释放，堆是二级缓存，生命周期由虚拟机的垃圾回收算法来决定

- 4.在jvm中，栈处于线程独享区，如虚拟机栈，本地方法栈，堆处于线程共享区，存储对象，数组那些，这也是产生垃圾的地方

#### 操作系统里的内存碎片

1. 内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片。通常内部碎片难以完全避免
2. 外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。  

```
段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。
```

**虚拟内存**

**原理：**

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/6c96803e1c6644f3a4d0d6accdab54f6.png)

```
局部性原理
1:时间局部性：如果执行了程序中的某条指令，那么不久后这条指令有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。
2:空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
```

**好处：**

1. **内存抽象：**虚拟地址抽象屏蔽了物理内存的具体细节。对程序员来说，不需要关心内存的物理布局或者可用大小，只需按需申请虚拟内存即可。这样简化了编程模型，因为每个程序都是从一个统一的起始地址开始运行，例如0x00000000。
2. **内存扩展**：应用程序可以使用比实际物理内存更多的内存空间，允许较大或多任务程序的运行，即便在物理内存不足的情况下。
3. **隔离与保护**：每个进程都有自己独立的虚拟内存空间，避免了进程间相互干扰，增强了系统的稳定性和安全性。允许操作系统有效地切换上下文
4. **数据共享**：不同的进程可以映射到相同的物理内存，从而方便地共享数据，而不必复制数据。
5. **内存按需分配**：操作系统只需要按实际需求把当前需要的数据页面加载到内存中，没有被使用的页面可以保留在磁盘上。这样可以更有效地使用物理内存。

#### 内存管理方式 [参考](https://www.cnblogs.com/shenckicc/p/6884921.html)

<u>分段和分页的区别：分页是把内存空间划分为**大小相等且固定的块**，作为主存的基本单位，方便管理。分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等</u>

- 分页对程序员是透明的，但是分段需要程序员显式划分每个段。
- 分页的地址空间是一维地址空间，分段是二维的。
- 页的大小不可变，段的大小可以动态改变。
- 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

**分页存储管理**：逻辑地址空间被划分为固定大小的页（page），物理内存被划分为同样大小的页帧（frame）。每个逻辑页可以映射到任意一个物理页帧。

```markdown
## 优点：
页长固定，因而便于构造页表、易于管理，没有外碎片，每个内碎片不超过页的大小
页式存储管理允许部分页面装入内存
## 缺点：
由于每一页通常较小，所以需要维护一个较大的页表来管理所有页面，
不贴合程序的逻辑结构，不方便共享
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oOz5YGa5ZCO56uv55qE5YmN56uv,size_20,color_FFFFFF,t_70,g_se,x_16-20231225110047905.png)

**分段存储管理**：段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。

```markdown
## 优点：
段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间
每个段可以有自己的保护位，用于控制对该段的访问权限，以及实现不同进程之间的段共享。
## 缺点：
主存空间分配、地址映射计算比较麻烦，容易在段间留下许多碎片，造成存储空间利用率降低。
```

```markdown
分段 和 分页 的区别：
    分页对程序员是透明的，但是分段需要程序员显式划分每个段。
    分页的地址空间是一维地址空间，分段是二维的（分页时 地址= 物理块号 + 页内偏移）。
    页的大小不可变，段的大小可以动态改变。
    分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

典型的段包括：`代码段`（用于存放执行代码）、`数据段`（用于存放全局变量和静态变量）、`堆栈段`（用于存放函数调用时的局部变量和控制信息）、`常量段`（用于存放常量数据）等
```

**段页式存储管理**：

（1）用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。

（2） 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。

```markdown
在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段表长TL。
1) 进行地址变换时，首先利用段号S，将它与段表长TL进行比较。若S<TL，表示未越界
2) 于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址
3) 利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b
4) 再利用块号b和页内地址来构成物理地址。

在段页式系统中，为了获得一条指令或数据，须三次访问内存。
第一次访问是访问内存中的段表，从中取得页表始址；
第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；
第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。

为了提高执行速度，在地址变换机构中增设一个`高速缓冲寄存器`(TLB)。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若未找到匹配表项，则仍须再三次访问内存。
```



![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/20130519103751707.jpeg)

```
优点
(1) 它提供了大量的虚拟存储空间。
(2) 能有效地利用主存，为组织多道程序运行提供了方便。
缺点：
(1) 增加了硬件成本、系统的复杂性和管理上的开消。
(2) 存在着内碎片。
(3) 还有各种表格要占用主存空间。
　段页式存储管理技术对当前的大、中型计算机系统来说，算是最通用、最灵活的一种方案。
```

#### 操作系统中的缺页中断

缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存中时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

缺页中断是由于所要访问的页面不存在于内存时，由**硬件所产生的一种特殊的中断**，因此，与一般的中断存在区别：

- 在指令执行期间产生和处理缺页中断信号
- 一条指令在执行期间，可能产生多次缺页中断

**虚拟内存的三个特性**

多次性：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存

对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入，换出。

虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量，虚拟内存和物理内存的映射。

#### 几种页面置换算法：

**最佳置换算法（理想）**：将当前页面中在未来最长时间内不会被访问的页置换出去

**先进先出**：淘汰最早调入的页面

**最近最久未使用 LRU**：每个页面有一个t来记录上次页面被访问直到现在，每次置换时置换t值最大的页面（用寄存器或栈实现）

**最少使用算法LFU**：设置寄存器记录页面被访问次数，每次置换当前访问次数最少的。

**第二次机会算法**：FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是  0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清  0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

**时钟：**第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。访问过程如下：

- 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
- 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-c58cb9ac67cf4604c47af479fe6240f6_1440w.webp)

### 四、文件管理[参考](https://blog.csdn.net/weixin_42570192/article/details/126236023)

#### 文件的信息

**文件的属性：**
文件名：由创建文件的用户决定文件名，主要为了方便用户找到文件，同一目录下不允许有重名的文件。
标识符：一个系统内的各文件的标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
类型：指明文件的类型，比如文本文档(.txt)、Word文档(.doc/.docx) 等。
位置：文件存放的路径(用户使用)、在外存中的地址(操作系统使用，对用户不可见)。
大小：指明文件的大小。
保护信息：对文件进行保护的访问控制信息。

```
无结构文件由一些二进制或字符流组成，称为流式文件，例如文本文件。
有结构文件由一组相似的记录组成，又称为记录式文件。（分为定长记录和可变长记录）
```



![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0d5ffd9e818649db9b137655d0b9b6dc.png)

（有结构）**文件的逻辑结构**

逻辑结构指的是在用户看来，文件内部的数据应该是如何组织起来的；物理结构指的是在操作系统看来，文件的数据是如何存放在外存中的。

1、顺序文件

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/004df052e6334f54981c4e48a834c619.png)

2、索引文件

索引文件包含了用来快速查找和访问文件中特定部分的索引结构。数据库索引是这种结构的一个典型应用。其本身是定长记录的顺序文件，因此可以快速的找到第 i 个记录对应的索引项。
 可以将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字二分查找，也可以用不同的数据项建立多个索引表。
缺点：由于每个记录对应一个索引表项，因此索引表可能会很大。适用于文件的每个记录占的空间远大于每个索引表项。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/6c5bba9a4f3c4d6cb77960f5fa3dac8b.png)

3、索引顺序文件

给文件建立一张索引表，不是给每个记录对应一个索引表项，而是一组记录对应一个索引表项。通过这种操作，索引表中的索引表项数量会减少很多。

![请添加图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/76308df733264b70be16912d8ce18259.png)

#### 文件目录

<u>目录本身就是一种有结构文件，它由一条条记录组成，每条记录对应一个放在该目录下的文件。</u>

##### 文件控制块

目录文件中的一条记录就是一个文件控制块(FCB，File Control Block)，FCB 中包含了文件的基本信息(包括文件名、物理地址、逻辑结构、物理结构等信息)、存取控制信息(是否可读/可写、禁止访问的用户名单等信息)以及使用信息(文件的建立时间、修改时间等信息)。其中最重要和最基本的是文件名和文件存放的物理地址。

FCB 实现了文件名和文件之间的映射，使用户可以实现按名存取（搜索、创建文件、删除文件、显示目录、修改目录）。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/718076cb10a347e89a0074ff2d3f46c2.png)

##### 单级目录结构

##### 两级目录结构

##### 多级目录结构

也称为树形目录结构，这种结构下，不同目录下的文件可以重名。系统会根据绝对路径一层一层地找到下一级目录。下图所示的就是一个多级目录结构。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e43448c384484558bc1f9c92e03f9769.png)

**无环图目录结构**，就是在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图，这样可以实现多个用户之间的文件共享。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/baac5e41ffd6418783a28bd09ebde63c.png)

#### 索引结点

除了文件名之外的文件描述信息都放到索引结点， 当找到文件名对应的目录项时，才需要将索引结点调入内存

![请添加图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0d3fae9626914419a61d279a4d35fe6c.jpeg)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/b4f4f928c6c944389969be560a51805c.png)

```
FCB 和 Inode 通常不会在同一个文件系统中共存。它们分别属于不同的文件系统架构，FCB 主要用于 FAT 等文件系统，而 Inode 则是 Unix/Linux 文件系统的核心结构。
```

#### 文件共享

硬链接：

<img wid src="https://gitee.com/xu_zuyun/picgo/raw/master/img/b4f4f928c6c944389969be560a51805c-20231227215723629.png"/>

软链接：

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e8502a5dd79e44ad82b84148dd4f04fb.png)

```markdown
1. 文件类型：软链接是一个特殊的文件，而硬链接与原始文件具有相同的文件类型。
2. 跨文件系统：软链接可以跨越文件系统，而硬链接只能在同一个文件系统中创建。
3. 链接对象：软链接可以链接到文件或目录，而硬链接只能链接到文件。
4. 存储空间：软链接的文件大小很小，只占用几个字节的存储空间，而硬链接与原始文件共享存储空间。
5. 删除原始文件：删除原始文件对软链接没有影响，但删除原始文件会导致硬链接失效。
```

#### 访问控制

在每个文件的FCB（或索引结点）中增加一个**访问控制列表**（Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。

或者用精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/29602bb984f643e7900a8a342138ced4.png)



#### 文件的分配方式

操作系统对磁盘的管理包括对非空闲磁盘块的管理(存放了文件数据)和对空闲磁盘块的管理(文件存储空间管理)。

为了方便管理，文件的逻辑地址空间也被分为了一个个的文件块。因此文件的逻辑地址也可以表示为 **(逻辑块号，块内地址)** 这样的坐标形式。

##### 1、连续分配

连续分配方式要求每个文件在磁盘上占有一组连续的块。逻辑上连续的块在物理上也要连续，同时还要保证逻辑上块与块之间的先后顺序映射到物理上之后顺序不变。
在文件目录中记录着存放的起始块号和长度，用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项，物理块号 = 起始块号 + 逻辑块号 。

```
优点：支持顺序访问和直接访问；连续分配的文件在顺序访问时速度最快。
缺点：存储空间利用率低，会产生难以利用的磁盘碎片，不方便文件的扩展（需要复制到空闲区域）
```

##### 2、链接分配

⑴隐式链接

目录中记录了文件存放的起始块号和结束块号，也可以增加一个字段表示文件的长度。除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户来说是透明的。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/29eb99d19ae54df387d6ae3574167955.png)

⑵显式链接

把用于链接文件的各物理块的指针显式地存放在一张表中，这张表就叫做文件分配表(FAT，File Allocation Table)。一个磁盘仅设置一张 FAT，开机时会将 FAT 读入内存，并会常驻内存，FAT 的各个表项在物理上连续存储，且每一个表项长度相同，所以物理块号字段可以是隐含的。
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/2f0f2be4b1324ade9311d9ab608678ea.png)

```
隐式链式分配的优点：很方便文件拓展，不会有碎片问题，外存利用率高。
隐式链式分配的缺点：只支持顺序访问，不支持随机访问，查找效率低，而且指向下一个盘块的指针也需要耗费一定的存储空间。
显式链式分配的优点：既支持顺序访问，也支持随机访问；方便文件拓展，不会有碎片问题；外存利用率高；相比于隐式链接，地址转换不需要访问磁盘，因此文件访问效率更高。
```

##### 3、索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块(建立逻辑块号与物理块号之间的映射关系)，索引表存放的磁盘称为索引块，文件存放的磁盘称为数据块。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/7403a961e34b4a9bbab4c3fc2a900059.png)

与显式链接文件分配表 FAT 是一个磁盘对应一张不同，而索引分配方式中，索引表是一个文件对应一张。

```
索引分配的优点：既支持顺序访问，也支持随机访问；文件拓展非常方便。
索引分配的缺点：索引表需要占用一定的存储空间。
```

如果文件太大，索引表项太多，可以采取**链接方案**、多层索引和混合索引这三种方式来解决，[参考](https://blog.csdn.net/weixin_42570192/article/details/126236023)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/698149e10e5f408bb1ec2cf292dcf370.png)

#### 存储空间的划分与初始化

##### 目录区与文件区

存储空间的初始化：将各个文件卷划分为目录区、文件区。

- 目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据
- 文件区用于存放文件数据。

##### 1.空闲表法（连续分配）

空闲表中记录每个连续空闲区的起始盘块号、盘块数，适用于连续分配方式

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/15d9e39e43a34f62a50e3861d302cd87.png)

```
1.如何分配磁盘块:
采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。
2.如何回收磁盘块:
当回收某个存储区时需要有四种情况：
①回收区的前后都没有相邻空闲区;
②回收区的前后都是空闲区;
③回收区前面是空闲区;
④回收区后面是空闲区。
回收时需要注意表项的合并问题。
————————————————
版权声明：本文为CSDN博主「JungleiRim」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_61888137/article/details/133977387
```

##### 2.空闲链表法

###### 空闲盘块链（**离散分配**）

- 操作系统保存着**链头、链尾指针**。
- 如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。
- 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/00035e59931d4c71a4f0e263dff69da2.png)



###### 空闲盘区链（**连续分配**、**离散分配**）

1.如何分配:
若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，
从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。
若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。

2.如何回收:
若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。
若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/b27c737afff04983be72484a74ede385.png)

##### 3.位示图法（离散分配、连续分配）

- 每个二进制位对应一个盘块。
- 在本例中，“0”代表盘块空闲，“1”代表盘块已分配。
- 位示图一般用连续的“字”来表示,例题中一个字的字长是16位，字中的每一位对应一个盘块。
- 可以用（**字号，位号**)对应一个**盘块号**。也可以描述位（**行号，列号**）

如何分配

若文件需要k个块，
 ①顺序扫描位示图，找到k个相邻或不相邻的“0”;
 ②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;
 ③将相应位设置为“1”。

如何回收:

①根据回收的盘块号计算出对应的字号、位号;
②将相应二进制位设为“0”

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0679ea6ee0384f62a876433804b6309c.png)

##### 4.成组链接法

空闲表法、空闲链表法不适用于**大型文件系统**，因为空闲表或空闲链表可能过大。
 **UNIX系统**中采用了**成组链接法**对磁盘空闲块进行管理。

1.如何分配

1.如果需求的空闲块为1，小于第一分组的块数
①检查第一个分组的块数是否足够。1<100，因此是足够的。
②分配第一个分组中的1个空闲块，并修改相应数据。

2.如果需求的空闲块为100，等于第一分组的块数
①检查第一个分组的块数是否足够。100=100，是足够的。
②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。
2.如何回收

1.假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。
2.假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。
需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/fe9e0cd0daf84e56b18952424704b527.png)

#### [一些例子](https://blog.csdn.net/qq_61888137/article/details/133999945?spm=1001.2014.3001.5502)

##### 1.创建文件(create系统调用)

1.进行Create系统调用时，

需要提供的几个主要参数:
1.所需的外存空间大小（如:一个盘块，即1KB)
2．文件存放路径（“D:/Demo”)
3.文件名（这个地方默认为“新建文本文档.txt”)
2.操作系统在处理Create系统调用时，

主要做了两件事:
1.在外存中找到文件所需的空间（结合学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)
2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。

##### 2.打开文件

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/7a320db54c7140e1bd88582f7f509bfe.png)

##### 3.文本文件和二进制文件

文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（自定义编码）。

- 文本文件基本上是定长编码的，基于字符嘛，每个字符在具体编码中是固定的，ASCII 码是 8  个比特的编码，UNICODE 一般占 16  个比特。

- 二进制文件可看成是变长编码的， BMP  文件举例，其头部是较为固定长度的文件头信息，前 2 字节用来记录文件为 BMP 格式，接下来的 8  个字节用来记录文件长度，再接下来的 4 字节用来记录 bmp 文件头的长度（不定长的，2、4、8  字节长的值都有）。

##### 4.Ascll、Unicode、utf-8

**本质上来说：**

Unicode是「字符集」    UTF-8 是「编码规则」

**字符集：** 为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）；

**编码规则：** 将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）

ASCII 定长编码 1 字节，Unicode 定长编码 2 字节，UTF-8 变长编码 1-3 字节。Unicode 和 UTF-8 均兼容 ASCII 码。unicode编码的长度固定，内存处理起来很方便。文件的存储中使用utf-8编码，可以压缩内存，节省空间。所以一般有个自动转换的机制，即从文件中读取utf-8编码到内存时，会自动转换为unicode编码，而从内存中将字符保存到文件时，则自动转换为utf-8编码

### 五、设备管理

#### IO设备

I/O设备就是可以将数据输入到[计算机](https://so.csdn.net/so/search?q=计算机&spm=1001.2101.3001.7020)，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。

```markdown
## 按使用特性分类
1.人机交互类外部设备；如：鼠标，键盘，打印机等，数据传输速度慢。
2.存储设备；用于数据存储，如：移动硬盘，光盘，数据传输速度块。
3.网络通信设备；用于网络通信，如：路由器，调制调节器。数据 传输速度介于上述二者之间。

## 按传输速率分类
1.低速设备；鼠标、键盘等——传输速率为每秒几个到几百字节。
2.中速设备；如激光打印机等—―传输速率为每秒数千至上万个字节。
3.高速设备；如磁盘等一一传输速率为每秒数千字节至千兆字节的设备。
## 按信息交换的单位分类
1.块设备；如磁盘等――数据传输的基本单位是“块’，传输速率较高，可寻址，即对它可随机地读/写任一块。
2.字符设备；鼠标、键盘等―—数据传输的基本单位是字符，传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式。

## 阻塞/非阻塞
阻塞I/O:应用程序发I/O系统调用进程需转为阻塞态等待
eg:字符设备接口―—从键盘读一个字符get
非阻塞l/O:应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待。
eg:块设备接口—―往磁盘写数据write
```

CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器，这个 I/O 桥接器，另一边接入了内存总线，使得 CPU 和内存通信。再另一边，又接入了一个 I/O 总线，用来连接 I/O 设备，比如键盘、显示器等。

![CPU 硬件总线图](https://gitee.com/xu_zuyun/picgo/raw/master/img/CPU%20%E7%A1%AC%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%9B%BE.webp)

#### IO控制器

为了屏蔽设备之间的差异，每个设备都有一个叫**设备控制器（\*Device Control\*）** 的组件，包含三个寄存器：

- *数据寄存器*，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。
- *命令寄存器*，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。
- *状态寄存器*，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。

```markdown
## 1.接收和识别CPU发来的命令
如CPU发来的read/write命令，I/O控制器中会有相应的控制寄存器来存放命令和参数。
## 2.向CPU报告设备的状态
I/O控制器中会有相应的状态寄存器,用于记录I/O设备的当前状态。
## 3.数据交换
I/O控制器中会设置相应的数据寄存器。
输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。
输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。
## 4.地址识别
类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。
I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器。
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/924d333484c94305bf82b99147c0aae1.png)

#### IO控制方式

1. 程序直接控制

   ```
   CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪)
   轮询检查控制器的状态(其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据,于是CPU会不断地轮询)
   输入设备准备好数据后将数据传给控制器，并报告自身状态
   控制器将输入的数据放到数据寄存器中,并将状态改为0（己就绪)
   CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存
   若还要继续读入数据，则CPU继续发出读指令
   ```

   优点:实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”)

   缺点:`CPU和I/O设备只能串行工作`，CPU需要一直轮询检查，`长期处于“忙等”状态`，CPU利用率低

2. 中断

   ```
   由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待l/O的进程阻塞，先切换到别的进程执行。
   当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。
   处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。
   接着，CPU恢复等待l/O的进程（或其他进程）的运行环境，然后继续执行。
   ```

   优点：`CPU和I/O设备可并行工作`，CPU利用率得到明显提升。

   缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。`而频繁的中断处理会消耗较多的CPU时间`。

3. DMA（Direct Memory Access）

   ```
   工作方式：
   
   - CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；
   - 接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；
   - 当磁盘控制器把数据传输到内存的操作完成后，`磁盘控制器`在总线上发出一个确认成功的信号到 DMA 控制器；
   - DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；
   ```

   优点：

   ①`数据的传送单位是“块”`。不再是一个字、一个字的传送;
    ②数据的流向是从设备直接放入内存，或者从内存直接到设备。
    ③仅在传送一个或多个数据块的开始和结束时，才需要CPU千预。

   缺点：

   CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。

   ![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3ef08b008e7944359c6cc67b482c31c8.png)

4. 通道

通道是一种`硬件`，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令. 与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存

```
CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。之后CPU就切换到其他进程执行了
通道执行内存中的通道程序（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息)
通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3368b5a4cf844658a4f9e2c366a3f730.png)

缺点：实现复杂，需要专门的通道硬件支持
优点：`CPU、通道、I/O设备可并行工作，资源利用率很高`。

**总结**

![](https://gitee.com/xu_zuyun/picgo/raw/master/img/3b0d6abcc4804fc6981e688d18f018b8-20231227223309417.png)

#### 设备类型

- 独占设备：一个时段只能分配给一个进程（如打印机）
- 共享设备：可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。
- 虚拟设备：采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术

```
引入脱机技术后，缓解了CPU与慢速l/O设备的速度矛盾。
即使CPU在忙碌，也可以提前将数据输入到磁带;
即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。
假脱机：SPOOLING技术，内存中虚拟缓冲区
```

**设备分配步骤**

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/8c6522ec14ce498babf1a52a0ecb4c87.png)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3a05b62ee66448ae9ac17eaaf28166b2.png)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/d2bf0fa3c98743789bbea76d54f89c51.png)

①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)
②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项。
③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

#### 事件队列

操作系统的事件队列是一种数据结构，它用于存储和管理由硬件设备、用户操作或其他系统活动生成的事件。事件可以包括键盘按键、鼠标移动、鼠标点击、触摸屏手势、系统定时器超时、网络消息到达等多种类型。

事件队列通常按照事件发生的时间顺序组织，遵循先进先出（FIFO）的原则，这意味着最早发生并加入队列的事件会首先被处理。操作系统内核或窗口系统负责管理这个队列，并将事件传递给相应的应用程序或系统服务。

事件队列的主要目的是确保对事件的响应有序进行，并允许程序异步地处理用户输入和系统通知。在图形用户界面（GUI）操作系统中，事件队列尤为重要，因为它能够确保用户界面的相应性和一致性。

当应用程序运行时，它会执行一个事件循环或消息循环，不断检查事件队列以查看是否有新事件。如果队列中有事件，应用程序会取出事件并根据其类型和内容作出反应，执行相应的处理程序。例如，一个窗口可能需要重绘自己，或者文本框可能需要更新其内容。

#### 问题

那当用户输入了键盘字符，**键盘控制器**就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送**中断请求**。

CPU 收到中断请求后，操作系统会**保存被中断进程的 CPU 上下文**，然后调用键盘的**中断处理程序**。

键盘的中断处理程序是在**键盘驱动程序**初始化时注册的，那键盘**中断处理函数**的功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符，如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的  ASCII 码，比如用户在键盘输入的是字母 A，是显示字符，于是就会把扫描码翻译成 A 字符的 ASCII 码。

得到了显示字符的 ASCII 码后，就会把 ASCII  码放到「读缓冲区队列」，接下来就是要把显示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。

显示出结果后，**恢复被中断进程的上下文**。

<hr/>

### 六、磁盘

磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据，磁盘的`盘面`被按圈划分成一个个磁道。一个磁道又等分被划分成一个个扇区，各个扇区存放的数据量相同。一个`盘片（磁道）`可能有多个`盘面`， 所有盘面中相对位置相同的磁道组成`柱面`。物理地址：（柱面，盘面，扇区）

#### 磁盘的块和内存的页

```markdown
# 存储单位
	1TB=1024GB ；1GB=1024MB ；1MB=1024KB ；1KB=1024字节

# 磁道（Track）
	磁盘旋转时，磁头在磁盘表面划出的每一个圆形轨迹。

# 扇区（sector）
	磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。（每个扇区的大小一般为512字节）
	扇区数量庞大，因此操作系统不会直接与扇区交互，而是与多个连续扇区组成的磁盘块交互。

# 磁盘块（Block）
	相邻的扇区组合在一起，形成一个磁盘块（每个磁盘块可以由 2、4、8、16、32 或 64 个扇区组成）
	磁盘块是文件系统读写数据的最小单位（操作系统规定一个磁盘块中只能放置一个文件）
	因此文件占用的空间只能是磁盘块的整数倍，这就会出现 [文件占用磁盘空间 > 文件实际大小] 的情况。

# 页（Page）
	内存的最小存储单位。页的大小通常为磁盘块大小的 2^n 倍。

# 小结
	扇区：
		硬盘读写的基本单位，磁盘中最小的物理存储单元。
	磁盘块：
		磁盘操作的基本单位，文件系统读写数据的最小单位。（多个扇区）
	页：
		内存操作的基本单位，内存存储的最小单位。（多个磁盘块）
# 固态硬盘
SSD最小读写单位是页（Page），一个页通常是1KB或2KB，也就是1024字节或2048字节，具体取决于厂商的工艺设定，最小擦除单位是块（Block），一个块通常包含64个页，擦除时以块为单位将该块中的所有页全部擦除，如果块中有数据主控会事先将数据转移到其他块中再执行擦除 
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e687bd02674c46a8bb381c47db4ae025.png)

#### 引导块

①开机时计算机先运行ROM中的“自举装入程序”，通过`执行该程序就可找到引导块`，并将完整的“自举程序”读入内存，完成初始化。

②完整的自举程序放在磁盘的启动块（即`引导块/启动分区`）上，启动块位于磁盘的固定位置。 拥有启动分区的磁盘称为启动磁盘或系统磁盘（即C:盘)

#### 磁盘调度算法

- 寻找时间（寻道时间）Ts:在读/写数据前，将磁头移动到指定磁道所花的时间。

- 延迟时间 T R T_R TR:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。

- 传输时间Tt:从磁盘读出或向磁盘写入数据所经历的时间

  ```
  总的存取时间 T a = 寻道时间 T S + 延迟时间 T R + 传输时间 T t
  延迟时间和传输时间都与磁盘转速相关，无法更改，磁盘调度算法会直接影响寻道时间。
  ```

**1.先来先服务(FCFS)**

```
优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去。
缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。
```

**2.最短寻道时间优先(SSTF)**

```
优点:性能较好，平均寻道时间短
缺点:只是选择眼前最优，但是总体未必最优，可能产生“饥饿”现象
```

**3.扫描算法(SCAN)（电梯算法）**

只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动

```
优点:不会产生饥饿现象。
缺点:
①只有到达最边上的磁道时才能改变磁头移动方向，最后一个请求磁道后面的都是无效移动。
②SCAN算法对于各个位置磁道的响应频率不平均(且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;但184号磁道很快又可以再次响应)
```

**4.LOOK调度算法**

如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向

**5.循环扫描算法(C-SCAN)**

只有磁头朝某个特定方向移动时才处理磁道访问请求，而`返回时直接快速移动至起始端而不处理任何请求`。

```
优点:比起SCAN来，对于各个位置磁道的响应频率很平均。
缺点:只有到达最边上的磁道时才能改变磁头移动方向，比起SCAN算法来，平均寻道时间更长。
```

**6.C-LOOK调度算法**

如果磁头移动的万同上已绘没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。

```
优点:比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。
```



#### 固态硬盘

基于闪存技术Flash Memory，属于电可擦除ROM，即`EEPROM`

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/59ee67e8059d483d86167c5b3af46386.png)

```
SSD读写速度快，随机访问性能高，用电路控制访问位置，机械硬盘有寻道时间和旋转延迟。
SSD安静无噪音、耐摔抗震、能耗低、造价更贵。
SSD的一个"块"被擦除次数过多(重复写同一个块)可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉。（磨损均衡技术）
```


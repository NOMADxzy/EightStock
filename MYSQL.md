## MySQL

### 一、结构

- 连接层：最上层是一些客户端链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层：第二层架构主要完成大多数的核心服务功能，如 SQL 接入，并完成缓存的查询，SQL 的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。
- 引擎层：存储引擎真正地负责了 MySQL 中数据的存储和提取，服务器通过 API 和存储引擎通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的**存储引擎**。
- 存储层：主要是将数据存储在文件系统之上，并完成与**存储引擎**的交互。

![https://img-blog.csdnimg.cn/a5caacfe5fef4255a9f74d2a57c98f63.png](https://gitee.com/xu_zuyun/picgo/raw/master/img/a5caacfe5fef4255a9f74d2a57c98f63.png)

#### 存储引擎

存储引擎就是存储数据、建立索引、更新 / 查询数据等技术的实现方式，存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。（InnoDB 引擎、MyISAM 引擎、Memory 引擎）

- 1、InnoDB支持事务，MyISAM不支持；
- 2、InnoDB支持外键，而MyISAM不支持；
- 3、InnoDB是聚集索引，而MyISAM是非聚集索引；
- 4、InnoDB支持表、行级锁，而MyISAM支持表级锁；
- 5、InnoDB表必须有唯一索引，而Myisam可以没有；

```markdown
## 那MyLSAM的的优势是？
    处理大量数据快：在大量的读操作时，访问速度相对较快。
    简单、易用：结构简单，易于操作。
    数据紧凑存储：由于其数据存储方式为压缩，可以获得更小的索引和更快的全表扫描性能。
    加锁与并发：可以对整个表加锁，而非仅针对行，可以实现并发插入。
```

#### 聚簇索引和非聚簇索引

```markdown
- 存储方式：聚簇索引将数据行直接存储在索引的叶子页中，而非聚簇索引的叶子节点仅存储指向数据行的指针。
- 数量限制：一个表中只能有一个聚簇索引（通常是主键索引），但可以有多个非聚簇索引。
- 性能差异：聚簇索引可以提供更快的数据访问速度，尤其是对于范围查询，因为数据在物理存储上是连续的；但是，更新聚簇索引键的成本高于非聚簇索引，因为它可能涉及到数据的实际移动来保持物理顺序。
- 非聚簇索引回表：使用非聚簇索引进行查询时，如果查询的列不完全包含在索引中，就需要进行“回表”操作，即通过非聚簇索引找到聚簇索引键，再通过聚簇索引键去找到对应的完整数据行。
```

##### 聚簇索引

聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。

```markdown
优点：
　　　　1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
　　　　2.聚簇索引对于主键的排序查找和范围查找速度非常快
缺点：
　　　　1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
　　　　2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
```

##### 非聚簇索引

在**聚簇索引之上创建的索引称之为辅助索引**，辅助索引访问数据**总是需要二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

![640](https://gitee.com/xu_zuyun/picgo/raw/master/img/640.png)

**在MyISAM中，主索引和二级索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。**

#### InnoDB

 InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 存储引擎。 InnoDB 对每张表在磁盘中的存储以 xxx.ibd 后缀结尾，innoDB 引擎的每张表都会对应这样一个表空间文件，用来存储该表的表结构（frm、sdi）、数据和索引。

InnoDB 的逻辑[存储结构](https://so.csdn.net/so/search?q=存储结构&spm=1001.2101.3001.7020)：表空间、段、区、页、行

![https://img-blog.csdnimg.cn/95540eb1ea7349109d388ff6fc7f7cd7.png](https://gitee.com/xu_zuyun/picgo/raw/master/img/95540eb1ea7349109d388ff6fc7f7cd7.png)

InnoDB 还会自动的给我们添加三个隐藏字段及其含义分别是：
    DB_TRX_ID
    最近修改事务 ID ，记录插入这条记录或最后一次修改该记录的事务 ID 。
    DB_ROLL_PTR
    回滚指针，指向这条记录的上一个版本，用于配合  undo log ，指向上一个版本。
    DB_ROW_ID
    隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。如果已存在主键，将不会生成该字段。

```markdown
## MySQL 为什么使用 B+ 树来作索引？ 
**B+树的磁盘读写代价更低**：B树的每个节点都存储了key和data，而B+树的data存储在叶子节点上。B+树非叶子节点仅存储key不存储data，这样一个节点就可以存储更多的key。可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。
**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
```

```markdown
## MyISAM
优势：MyISAM 在过去被广泛使用，尤其是在只读或者读多写少的场景下表现良好。它提供了全文搜索索引、压缩表和空间函数支持等特性。
缺点：MyISAM 不支持事务处理并且不支持行级锁（仅支持表级锁），这意味着在发生写操作时，整个表都会被锁定，影响并发性能。同时，MyISAM 也不支持外键约束，并且对崩溃恢复支持不佳。
## InnoDB
优势：InnoDB 是 MySQL 的默认存储引擎，它支持事务处理、行级锁定、外键约束，并且对于多线程环境下的并发性有良好的支持。InnoDB 还通过其聚簇索引结构，提供了更高效的主键查找性能。
缺点：相比 MyISAM，在某些读密集型操作中（如全表扫描）可能略微逊色，但差距已经大幅减少。而且，通过适当的配置和索引优化，InnoDB 通常可以提供接近或匹敌 MyISAM 的读性能。
```

### 二、可重复读原理

#### MVCC

MVCC，直译多版本并发控制，它的全称是Multi-Version Concurrency Control， 直白说就是在同一时刻同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制。本质上是一种乐观锁，用于实现提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别

![https://img-blog.csdnimg.cn/d992db6af2fa48588cc3ddc4e45e5c19.png](https://gitee.com/xu_zuyun/picgo/raw/master/img/d992db6af2fa48588cc3ddc4e45e5c19.png)

![https://img-blog.csdnimg.cn/828b5b7c754b4465844f7d1676e1273a.png](https://gitee.com/xu_zuyun/picgo/raw/master/img/828b5b7c754b4465844f7d1676e1273a.png)

不同事务或相同事务对同一条记录进行修改，会导致该记录的 undolog 生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

#### 读视图

 **ReadView（读视图）**是 快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。 ReadView 中包含了四个核心字段：可以通过这个列表来判断某一个版本是否对当前事务可见

![image-20231223204345236](https://gitee.com/xu_zuyun/picgo/raw/master/img/image-20231223204345236.png)

 readview 中就规定了版本链数据的访问规则： trx_id 代表当前 undolog 版本链对应事务 ID

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/33f0343fba68429580b117f54e190e6c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

1. 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。

2. 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。

3. 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：

- 如果记录的 trx_id 在 `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见
- 如果记录的 trx_id 不在 `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见

#### 实现方法

READ COMMITTED ：在事务中每一次执行快照读时生成 ReadView。

REPEATABLE READ：仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView。

#### 解决幻读

解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题。

假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。

| id   | name       | age  |
| ---- | ---------- | ---- |
| 1    | 古时的风筝 | 10   |
| 2    | 风筝2号    | 30   |

3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。

![img](https://img-blog.csdnimg.cn/img_convert/6a73e823a3de167d9c49689af5c163f4.webp?x-oss-process=image/format,png)

当事务A执行update user set name='风筝2号’ where age = 10; 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交（而大于等于30的记录则不受影响）

如果 age 不是索引列，那么数据库会为整个表加上间隙锁，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/format,png-20240123210603125.png)

### 三、日志

#### 数据存放/修改位置

数据库的数据是部分存储在内存中的

1. **性能优化**：
   - 为了提高读写效率，数据库会将频繁访问的数据页缓存在内存中的缓冲池（buffer pool）里。
   - 这样可以加快数据访问速度，因为内存的读写速度远快于磁盘。
2. **缓存策略**：
   - 大多数数据库管理系统采用某种形式的页面置换算法，如LRU（Least Recently Used），来管理内存中的数据页缓存。
   - 当需要加载新的数据页且内存已满时，最少使用的数据页可能会被替换出去，并且如果被修改过，则会先刷新回磁盘。
3. **事务处理**：
   - 在处理事务时，DBMS会在内存中操作数据，并通过日志机制（如Redo Log和Binlog）记录这些更改，以便在发生故障时能够恢复未同步到磁盘的数据。

![7db8189236cb48c1a903949d91945427](https://gitee.com/xu_zuyun/picgo/raw/master/img/7db8189236cb48c1a903949d91945427.png)

#### Buffer Pool

Mysql数据库的数据是存在磁盘中的，如果每次都从磁盘获取数据，会大大降低数据库的读写性能，所以，innodb存储引擎设计了一个缓冲池Buffer Pool。

缓冲池被划分为许多页，叫做缓存页，除了包含索引页和数据页，还包含了插入缓存页、undo页(undo log写入这里)、自适应哈希索引和锁信息。

1. 当我们需要缓存某条记录时，会将该记录所在页载入到缓冲区中。

2. 读取数据时，先去这个缓冲池看看能不能找到，找不到才去磁盘找。

3. 修改数据时，如果这个数据在缓冲池，会直接修改数据所在的页，并将其设置为脏页（也就是缓冲池和磁盘中的数据已经不一致了），为了减少磁盘I/O，不会立即将脏页写入磁盘，而是由一个后台线程选择一个合适的时机将脏页写入磁盘。

#### Write-Ahead Logging

WAL 中文称预写式日志，是一种数据安全写入机制。就是先写日志，然后在写入磁盘，这样保证数据的安全性。Mysql中的Redo Log就是采用WAL机制。

作用：

- Mysql中如果为了保证数据的持久性，在每提交一个事务就将日志刷新到磁盘上，这样效率就太低了，严重影响性能，所以就有了Write-Ahead 。
- 先在内存中提交事务，然后写日志(在InnoDB中就是Redo Log，日志是为了防止宕机导致内存数据丢失)，然后再后台任务中把内存中的数据异步刷到磁盘。

```markdown
1. 写操作：
当数据库进行修改（如插入、更新或删除数据）时，系统首先将这些变更记录到WAL中。这个过程是顺序的，通常会追加到WAL文件的末尾，这样做可以最大化磁盘I/O的效率。
只有在修改记录到WAL并确保日志数据持久化后，相应的事务才被认为是提交成功的。
这些记录在稍后的时间点（根据各种策略和触发条件）被异步刷新到实际的数据文件中。

2. 读操作：
读取数据不需要修改WAL，因此可以与WAL的写入操作并行进行。
如果读取操作遇到了还没有从WAL刷新到数据文件的最近写入操作，数据库系统可以直接从WAL中获取这些最新的数据，以便返回给用户最新的状态。这称作“预写日志”的回读操作——结合使用WAL中记录的最新状态和数据文件中的旧状态，以计算出当前的数据状态，并将其提供给读操作。

3. 并发控制：
数据库通常会采用锁机制或多版本并发控制（MVCC）等技术来处理并发读写操作，以确保数据的一致性和隔离性。

4. 崩溃恢复：
WAL还支持数据库的崩溃恢复。如果数据库意外崩溃，下次启动时，通过WAL中的日志记录可以重放未持久化的数据修改操作，从而恢复到崩溃前的状态。
```

#### Redo Log（重做日志）

InnoDB存储引擎特有的日志类型，主要用于实现事务的持久性，采用WAL机制

1. **恢复机制**：在系统发生故障时，能够使用Redo Log中的信息来恢复未写入磁盘的数据页。

2. **提高性能**：由于WAL机制的存在，InnoDB可以先将修改操作记录到Redo Log中并立即提交事务，在后续的适当时机再将这些操作同步到磁盘上的数据文件。

3. **内容：**记录某个页发生了什么修改

4. **存储机制：**

   采用的是***\*循环写\****。从头开始写，写到末尾又会重头开始写。

![334f4bc6b5744b56b1d43f25aa952d99](https://gitee.com/xu_zuyun/picgo/raw/master/img/334f4bc6b5744b56b1d43f25aa952d99.png)

write_pos沿顺时针方向一直到check_point的部分表示可以写入的空间。write_pos沿顺时针方向一直到check_point的部分表示待落盘的脏数据页记录（本质上，redo就是保存的未被刷新的脏页数据）。当write_pos追上check_point时，redo log写满，mysql会被阻塞，此时不能再进行写操作，这时会停下来将buffer pool中的脏页刷新到磁盘，接着，既然脏页中的记录已经落盘，就可以擦除redo中的一些记录，check_point也向后顺时针移动，这样，write_pos与check_point之间就有了可以写入的空间。

Redo Log通常包括两个部分：

- **重做日志缓冲区（Redo Log Buffer）**：内存中的结构，所有的修改操作首先记录在这里，然后周期性地刷新到重做日志文件中。
- **重做日志文件（Redo Log Files）**：这是Redo Log持久化存储的地方，只有事务写入这里才算提交了

#### Binlog（二进制日志）

MySQL服务器层面的日志，它记录了所有修改数据库内容的操作，

1. **复制**：在MySQL主从复制架构中，master将binlog发送给slaves，以便slaves可以执行相同的数据修改操作来保证数据一致性。
2. **数据恢复**：可以通过回放binlog来恢复数据，达到某个时间点的状态。
3. **内容：** 记录的是每一条修改数据的sql 或 每一行记录的变化过程

#### Redo Log与Binlog的区别

- **存储引擎层 vs 服务器层**：Redo Log是InnoDB特有的，而Binlog是MySQL服务层的，记录所有存储引擎的变更。

- **物理日志 vs 逻辑日志**：Redo Log是物理日志，记录物理数据页的变化；Binlog是逻辑日志，记录数据库执行的增删改操作。

- **WAL机制**：Redo Log是基于WAL机制的，先写日志，再写磁盘；Binlog不是基于WAL机制，事务提交时才写入日志。

  ***\**\*redo log\*\**\***是***\*循环写\****，日志大小固定，保存未被刷入磁盘的的***\*脏页日志\****。

  ​    ***\**\*binlog\*\**\***是***\*追加写\****，写满一个文件就创建一个新的文件继续写，保存的是***\*全量的日志\****。

- **用途**：Redo Log主要用于事务的持久性保证和崩溃恢复，而Binlog主要用于数据的复制、恢复和审计。

###### 为什么binlog没有crash-safe能力？

- 因为事务提交后，虽然更新操作都在binlog中，但是它没有一个标志判断哪些是已经刷盘，哪些还未刷盘，那么就无法达到crash-safe的能力

- 但是redo log不一样，它记录的就是未刷盘的数据，只要mysql重启后，直接将这些数据恢复至内存即可。

为什么宁可写入binlog文件 也不直接写入 数据库中？

写入redo log采用的方式是***\*追加\****操作，所以磁盘操作是***\*“顺序写”\****。相比将数据直接写入磁盘的操作，需要先找到相应的位置，再执行写操作，这样是***\*“随机写”\****，写入磁盘的开销大。

#### 两阶段提交

![1b0961e153f54bac9add9cbeacfc825c](https://gitee.com/xu_zuyun/picgo/raw/master/img/1b0961e153f54bac9add9cbeacfc825c.png)

具体就是将redo log的操作拆成了两个阶段：prepare阶段和commit阶段,中间穿插对bin log的写入。

1.   在prepare阶段：会将XA事务的id(XID)写入redo log,并将redo log的事务状态设置为prepare，然后将redo log持久化到磁盘（innodb_flush_log_at_trx_commit = 1 ）。

2. 在commit阶段：把XID写入bin log,并将binlog持久化到磁盘（sync_binlog = 1），接着调用引擎的提交事务接口将redo log事务状态设置为commit。（bin log写入成功为事务提交成功的标志）

#### UndoLog

undolog日志叫做回滚日志，它可以用于***\*回滚事务\****和实现MVCC（ 配合ReadView）。

保障事务的**原子性、一致性、隔离性**

在执行事务的过程中，将回滚所需的信息都记录在undolog中，回滚时根据undolog中的数据做相反的操作。

1. 比如插入记录时，将这条记录的主键值记录下来，回滚时就删除这个主键值的记录。

2.    删除记录时，将这条记录的内容记录下来，回滚时就插入这些内容。

3.    更新记录时，将这条记录被更新的列的旧值记录下来，回滚时就更新该列为旧值。

![f407502f11b24d5fa3a61e56adf81cd7](https://gitee.com/xu_zuyun/picgo/raw/master/img/f407502f11b24d5fa3a61e56adf81cd7.png)

#### 执行流程

1. 执行器负责具体的执行，会调用存储引擎接口，通过主键索引树获取id=1这一行记录:

2. 如果id = 1这一行所在的数据页在缓冲池中，直接返回给执行器更新；
3. 如果id = 1这一行所在的数据页不在缓冲池中，就将数据页从磁盘读入缓冲池，再返回记录给执行器；
4. 执行器得到记录后，会看一下更新后的记录与更新前的记录是否一样：
5. 如果一样则不进行后序更新流程；
6. 如果不一样，就将更新前后的记录都当做参数传给InnoDB层，让它执行真正的更新操作
7. 开启事务，InnoDB层更新记录前，先将更新前的列的旧值记录在undo log中，生成的undo log会写入缓冲池的Undo页面，同时，因为修改了Undo页面，也会记录对应的redo log
8. InnoDB层开始更新记录，会先更新缓冲池中的数据页（标记其为脏页），接着记录修改的信息到redo log中。为了减少磁盘IO，不会立即将脏页写入磁盘，而是由一个后台线程在合适的时机将脏页刷新到磁盘。（WAL技术）。Mysql的写操作不是立刻写入磁盘，而是先写到redo log,然后在合适的时机再将修改的行数据写到磁盘。
9. 至此，一条记录更新完了
10. 更新完，记录对应的bin log到bin log cache中
11. 事务提交，将binlog cache中的数据写入到操作系统内核的page cache中，由操作系统决定何时刷盘。

### 四、锁

MySQL有三种锁的级别：页级、表级、行级。

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

  "页"是数据库存储数据的基本单位，它是磁盘上连续的存储区域。不同的数据库系统可能有不同大小的页面，但通常情况下，一个数据库页的大小范围在4KB到16KB之间。

##### 死锁的解决办法?

1. 查出的线程杀死 kill
   SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
2. 设置锁的超时时间
   Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。生产环境不推荐使用过大的  innodb_lock_wait_timeout参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：
   set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。
3. 指定获取锁的顺序

##### 临时表

MySQL用于存储一些中间结果集的表，临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。*

#### 锁的类型——共享锁、排它锁（行级别）

#####  悲观锁：

- 共享锁（Shared Lock）：也称为读锁，允许多个事务同时获取共享锁，但不允许事务获取排他锁。共享锁用于保护数据的一致性读操作，不阻塞其他共享锁的获取，但会阻塞排他锁的获取。

  **For Update**：将获取排他锁

  ![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-c673a214bb7309f9ae353d6c682f2e12_1440w.jpg)

- 排他锁（Exclusive Lock）：也称为写锁，只允许一个事务获取排他锁，其他事务无法同时获取共享锁或排他锁。排他锁用于保护数据的写操作，阻塞其他锁的获取，包括共享锁和排他锁。

  **Lock in Share Mode**：获取共享锁

  ![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-1fc105cb7f7583389f1ae95f4dbcde90_1440w.jpg)

##### 乐观锁：

- 乐观锁不实际上对数据进行锁定。它基于一种假设，即数据在被修改期间不会被其他事务修改。在乐观锁中，你通常会使用版本号或时间戳等机制，以确保在提交修改之前，数据没有被其他事务修改。如果检测到冲突，事务将回滚。
- 举例：
  1. **版本号（Version Number）**:
     - 数据表中包含一个版本号字段，每次更新记录时，版本号增加。
     - 在读取记录时，将版本号一同读出，更新时检查版本号是否未改变（即没有被其他事务更新）。
     - 如果版本号不匹配，则说明数据在读取后和更新前之间被别的事务修改过，那么当前事务将回滚。
  2. **时间戳（Timestamp）**:
     - 类似于版本号机制，但是使用时间戳来标记每条记录的最后更新时间。
     - 当要更新一条记录时，检查当前记录的时间戳是否与开始更新事务时读取的时间戳相同。
     - 如果时间戳有差异，则表示记录在此期间已经被修改，当前事务应该回滚。
  3. **CAS操作（Compare and Swap/Set）**:
     - 这种方法在编程语言层面更为常见，例如Java中的`AtomicInteger`类提供了CAS操作。
     - 在进行更新操作之前，先比较内存中的值是否与预期相同，只有在相同的情况下才执行更新。
     - 在数据库中也可以实现类似的逻辑，通过比较某个字段的值是否符合预期来决定是否进行更新。

##### MVCC机制

MVCC机制就是实现非锁定读的关键技术，基于UnDO日志文件实现的，MVCC机制简单理解就是一行数据有多个版本，根据事务的隔离级别确定当前事务读取哪个版本。从而提升并发访问能力。这种能力就被称为多版本并发访问机制。如果事务隔离级别是read commited，那么读取的总是最新的已提交事务版本；如果事务隔离级别是repeatable，那么读取的是当前事务开启的时候的版本。

### 五、使用

#### 查询缓存

##### 工作流程

当启用查询缓存时，MySQL服务器会按照以下步骤处理查询：

1. 对进来的查询请求做规范化处理，去除额外的空格和注释。
2. 计算处理后的查询文本的哈希值，并在查询缓存的哈希表中搜索是否有匹配项。
3. 如果找到匹配的结果集哈希值，且具体的细节（如数据库名、表名等）也符合，就直接从缓存中返回结果集，不需要重新执行查询。
4. 如果未找到缓存的结果，则执行查询，并在返回结果之后将此新的结果集添加到查询缓存中。

##### 缓存失效

查询缓存对数据库表的变动非常敏感。如果涉及到查询结果集的任何表发生了变化（如INSERT、UPDATE、DELETE等操作），所有与该表相关的缓存结果都将被立即失效并删除，这样可以保证查询缓存中的数据始终是最新的。

##### 注意事项

- 查询缓存功能默认可能是禁用的，可以通过配置文件或运行时设置启用。
- 并非所有类型的查询都可以被缓存（例如，包含用户自定义函数、用户变量、临时表、RAND()或者当前时间函数NOW()等的查询不会被缓存）。
- SQL语句必须字节完全匹配才能命中缓存，即使逻辑上相同但格式有微小差异的查询也不会命中缓存。

#### 主从复制

MySQL 主从复制（Master-Slave Replication）是一种数据复制技术，用于在多个数据库服务器之间的数据同步。在主从复制架构中，一个服务器被设置为主服务器（Master），充当数据源，其他服务器被设置为从服务器（Slave），用来复制主服务器的数据。

目的：提高整体性能和吞吐量、高可用性、数据备份

- 主数据库接收到一个写操作（如 INSERT、UPDATE、DELETE）时，会将这个操作记录到二进制日志（Binary Log）中，将数据修改的操作按顺序记录下来。
- 从数据库 IO 线程会自动连接主服务，从二进制中读取同步数据，记录到中继日志（Relay Log）中。
- 从数据库的 SQL 线程会定期从中继日志中获取同步数据，写入到从数据库中。

![47e86f00dba444d79221a8fd42ac1cf5](https://gitee.com/xu_zuyun/picgo/raw/master/img/47e86f00dba444d79221a8fd42ac1cf5.png)

```markdown
## 主从复制模式

1. 异步复制：MySQL 主从复制中最常见和默认的模式。在异步复制模式中，主服务器将数据修改操作记录到二进制日志（Binary Log）中，并将日志传输给从服务器。从服务器接收到二进制日志后，会异步地应用这些日志进行数据复制。
优点：它的优点是及时响应给使用者，主服务器不会受到从服务器的影响而等待确认，可以提高主服务器的性能。
缺点：由于是异步复制，可能存在数据传输的延迟，且从服务器上的复制过程是不可靠的。如果主服务器故障，尚未应用到从服务器的数据可能会丢失。

2. 半同步复制：半同步复制是 MySQL 主从复制中的一种增强模式。在半同步复制模式中，主服务器将数据修改操作记录到二进制日志，并等待至少一个从服务器确认已接收到并应用了这些日志后才继续执行后续操作。
优点：可以提供更高的数据一致性和可靠性，确保至少一个从服务器与主服务器保持同步。如果主服务器故障，已经确认接收并应用到从服务器的数据不会丢失。
缺点：由于半同步复制需要等待从服务器的确认，因此相对于异步复制，会增加一定的延迟，可能会影响主服务器的性能。
```

#### 数据库优化

##### SQL优化

- 使用`JOIN`来代替子查询
- 使用`UNION`来代替手动创建临时表
- 涉及到 Group By 的地方需要额外注意，容易引起慢查询
- 尽可能的符合最左匹配原则

```mysql
## Join和子查询
假设我们要将所有没有订单记录的用户取出来:
1. 子查询
SELECT * FROM customerinfo 
WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 
2. 连接
SELECT * FROM customerinfo 
LEFT JOIN salesinfo ON customerinfo.CustomerID=salesinfo. 
CustomerID 
WHERE salesinfo.CustomerID IS NULL 
## 原因  
连接（JOIN）.. 之所以更有效率一些，是因为 MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作 
```

```markdown
## 最左匹配原则 —— 只有包含索引键左边的查询(area)才会走联合索引
比如索引 abc_index:(a,b,c) 是 a,b,c 三个字段的联合索引
可以走索引：(a)、(a,b)、(a,b,c)
只走a字段索引：(a,c)
不走索引：(c)、(b,c)
## 原因
1.Mysql创建联合索引是首先会对最左边，也就是第一个索引字段进行排序
2.在第一个排序的基础上，再对第二个索引字段进行排序，所以第一个字段是绝对有序的，而第二个字段就是无序的了
3.因此通常情况下，直接使用第二个字段进行条件判断是用不到索引的。这就是为什么mysql要强调最左匹配原则的成因。
```

```mariadb
## Group By 影响性能的原因
1. group by 导致大量的临时表：当使用group by时，MySQL会先将查询结果放入一个临时表中，然后再对临时表进行分组操作，这样会导致大量的临时表，从而降低查询效率。
2. group by 导致排序操作：当使用group by时，MySQL会先将查询结果放入一个临时表中，然后再对临时表进行排序操作，这样会导致大量的排序操作，从而降低查询效率。
3. group by 导致索引失效：当使用group by时，MySQL会先将查询结果放入一个临时表中，然后再对临时表进行索引操作，这样会导致索引失效，从而降低查询效率。
```

##### 配置参数

max_connections：如果设置过低，则可能会引起并发问题，如果设置过高，则可能会浪费系统资源。合理的值应根据服务器硬件和网络连接数量进行调整。

query_cache_size：启用查询缓存可以提高查询性能，因为经常执行的查询可以从缓存中直接获取结果。然而，对于具有大量更新、删除或插入操作的数据库，启用查询缓存可能会降低性能。

tmp_table_size 和 max_heap_table_size：这两个参数控制缓存中生成的临时表的大小。请确保它们的值足够大，以避免频繁创建和删除临时表。

##### 问题排查手段？

日志分析：常见的日志文件包括error log（记录了数据库运行时发生的错误）、slow query log（记录了执行时间超过设置阈值的查询语句）、general log（记录所有客户端连接到服务器上的操作）等。

HOW STATUS命令：使用SHOW STATUS命令可以查看当前MySQL服务器的状态信息，如连接数、线程数、查询次数、InnoDB事务等。根据这些统计信息，可以初步确认系统是否存在性能问题。

Profiling功能：开启Profiling功能后，MySQL会将每条SQL语句的执行时间、CPU消耗等信息保存下来，从而可以分析出哪些SQL语句影响了性能。

### 六、分库分表

![20211006230729516](https://gitee.com/xu_zuyun/picgo/raw/master/img/20211006230729516.png)

```
单表数据量太大，会极大影响 sql 执行的性能，一般来说，单表到几百万的时候，性能就会相对差一些了
一个库一般而言，最多支撑到并发 2000，一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大
```

#### 垂直（纵向）切分

常见有垂直分库和垂直分表两种

1. **垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。**做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与"微服务治理"的做法相似，每个微服务使用单独的一个数据库。

   ![20200107150421191](https://gitee.com/xu_zuyun/picgo/raw/master/img/20200107150421191.png)

2. 垂直分表是基于数据库中的"列"进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。常规的方案是**冷热分离**（将使用频率高字段放到一张表里，剩下使用频繁低的字段放到另一张表里）。

   ![2020010715051546](https://gitee.com/xu_zuyun/picgo/raw/master/img/2020010715051546.png)

   ```
   便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。
   ```

缺点：

- 部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度
- 分布式事务处理复杂

#### 水平（横向）切分

水平切分分为库内分表和分库分表

![20200107150731547](https://gitee.com/xu_zuyun/picgo/raw/master/img/20200107150731547.png)

```markdown
## 原理：
将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。

## 缺点：
库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决。
```

##### 分片过程

选择分片键时，需要先统计该表上的所有的 SQL，尽量选择使用频率且唯一值多的字段作为分片键，既能做到数据均匀分布，又能快速定位到数据位置，例如user_id，order_id等

- 按照时间区间或ID区间来切分

  ![20200107150850222](https://gitee.com/xu_zuyun/picgo/raw/master/img/20200107150850222.png)

- 根据数值取模

  ![20200107150945210](https://gitee.com/xu_zuyun/picgo/raw/master/img/20200107150945210.png)

- range与hash结合

  ```
  hash取模方案：没有热点问题，但扩容迁移数据痛苦
  range方案：不需要迁移数据，但有热点问题。
  ```

更多参考：https://blog.csdn.net/xushiyu1996818/article/details/103874759

### 七、问题

#####  唯一索引比普通索引快吗， 为什么？

更新时， 普通索引将记录放到 change buffer 中语句就执行完毕了。 而对唯一索引而言， 它必须要校验唯一性， 因此， 必须将数据页读入内存确定没有冲突， 然后才能继续操作。 对于写多读少的情况， 普通索引利用 change buffer 有效减少了对磁盘的访问次数， 因此普通索引性能要高于唯一索引。

##### 什么情况下会导致MySQL的索引失效

- where语句中索引列使用了负向查询：出现NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等 条件

- 以like通配符开头的模糊匹配

  ```
  like查询以%开头时，会导致索引失效。解决办法有两种：
  将%移到后面，如：
  select * from `user` where `name` like '李%';
  利用覆盖索引来命中索引。
  select name from `user` where `name` like '%李%';
  ```

  

- 条件中出现`OR`连接多个条件的时候，其中一个条件失效就会全部失效

- 涉及到对字段值进行数值转换的函数调用（`LOWER`、`UPPER`、`TRIM`等函数）

- 数据量太小了导致引擎优化器觉得全表扫描更快

- 涉及到索引字段进行类型转换

  ```
  比如下面语句中索引列user_id为varchar类型，不会命中索引：
  select * from `user` where user_id = 12;
  这是因为MySQL做了隐式类型转换，调用函数将user_id做了转换。
  select * from `user` where CAST(user_id AS signed int) = 12;
  ```

- 对索引列进行运算，一定会导致索引失效

  ```
  运算如+，-，*，/等，如下：
  select * from `user` where age - 1 = 10;
  优化的话，要把运算放在值上，或者在应用程序中直接算好，比如：
  select * from `user` where age = 10 - 1;
  ```

- 联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效

  ```markdown
  ## 当创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了(k1)、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。
  比如下面的语句就不会命中索引：
  select * from t where k2=2;
  select * from t where k3=3;
  slect * from t where k2=2 and k3=3;
  下面的语句只会命中索引(k1):
  select * from t where k1=1 and k3=3;
  ```

```markdown
## 总结：优化索引的一些建议
    禁止在更新十分频繁、区分度不高的属性上建立索引。
        更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。
        “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。
    建立组合索引，必须把区分度高的字段放在前面。
```


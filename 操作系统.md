## 操作系统

[参考](https://blog.csdn.net/qq_61888137/category_12436223_2.html)

### 一、概念

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/dfd6f2643180429899b267f5cb0a6286.png)

**操作系统的四个特性？**

并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时刻有多个事件，多处理器系统可以使程序并行执行）

共享：系统中的资源可以被内存中多个并发执行的进线程共同使用

虚拟：通过分时复用（如分时系统）以及空分复用（如虚拟内存）技术把一个物理实体虚拟为多个

异步：系统进程用一种走走停停的方式执行，（并不是一下子走完），进程什么时候以怎样的速度向前推进是不可预知的

**用户态和内核态**

内核态：可以执行特权指令（如内存清零指令），cpu可以访问内存的所有数据，包括外围设备。

用户态：只能执行非特权指令，只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

```
内核速度快但是资源有限，能控制的进程数不多，所以需要速度慢一些的用户态协助，但是为了避免用户态被恶意利用，所以限制了用户态程序的权限。
```

**什么时候转换用户态和内核态？**

用户->内核：

1. **系统调用**：用户进程主动发起的。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()就是执行一个创建新进程的系统调用
2. **发生异常**：会从当前运行进程切换到处理次此异常的内核相关程序中
3. **外围设备的中断：**所有程序都运行在用户态，但在从硬盘读取数据、或从键盘输入时，这些事情只有操作系统能做，程序需要向操作系统请求以程序的名义来执行这些操作。这个时候用户态程序切换到内核态。

内核->用户：

执行一条**特权指令――修改PSW**的标志位为“用户态”

#### 什么是操作系统中断

1. 当发生中断时，cpu立即进入内核态
2. 当发生中断后，当前进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理
4. 中断分为内中断和外中断。

![中断](https://gitee.com/xu_zuyun/picgo/raw/master/img/中断.webp)

**内部中断：**

陷阱（陷入）：由陷入指令（访管指令，进行系统调用）引发，是应用程序故意引发的。
故障：由错误条件引起的,可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行下去。如:缺页故障。
终止：由致命错误引起,内核程序无法修复该错误，因此一及不再将CPU使用权还给引发终止的应用程序,而是直接终止该应用程序。如:整数除0、非法使用特权指令。

**中断处理流程：**

1. 当CPU检测到中断信号后，
2. 判断中断信号类型
3. 若是内中断:CPU在执行指令时会检查是否有异常发生；
4. 若是外中断:每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。
5. 然后根据中断信号的类型查询“**中断向量表**”，
6. 以此来找到相应的中断处理程序在内存中的存放位置。

### 二、进程与线程

#### **什么是进程和线程？**

```
进程是是计算机中的一段程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位。
线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。
```

- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
- 切换：线程上下文切换比进程上下文切换要快得多。
- 拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
- 系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。
- 进程间不会相互影响，但一个线程挂掉将导致整个进程挂掉

**并发和并行**

并发就是在一段时间内，多个任务都会被处理；

并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成。

**多线程相较单线程的好处**

1、并发提升程序执行效率 

2、提升CPU利用率，访存、输入输出等耗时操作时可以切换线程来执行。

3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。

**协程是一种用户态的轻量级线程**

协程不是由操作系统内核管理，而是完全由用户程序所控制，这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。协程可以理解为可以暂停执行的函数。它拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

协程不属于操作系统的,只是用来调度协程的,但是协程的执行其实还是由线程执行的,协程可以认为是运行在线程上的代码块

协程适合做IO密集型任务，不适合cpu密集型任务。

```
优点：
协程是轻量级线程,全部都在用户态,因此系统消耗资源非常低,调度速度快，非常高效.
线程实现数据共享的方式是共享内存,而协程是通信,这就避免了线程安全的问题,避免了锁竞争.
缺点:
系统是察觉不到协程的存在的，所以只有一个处理器内核会被分配给该进程 ，也就不能发挥多核 CPU 的优势.
```

**线程的切换**

线程是被内核所调度,线程被调度切换到另一个线程上下文的时候,需要保存一个用户线程的状态到内存(切出),恢复另一个[线程状态](https://so.csdn.net/so/search?q=线程状态&spm=1001.2101.3001.7020)到寄存器(切入),然后更新调度器的数据结构,这几步操作涉及到用户态到内核态的切换,开销比较多.

**协程的切换**

在用户空间实现了自己的一套调度器,上下文存储,以及任务载体等等这些,相当于我直接在用户空间就能完成程序的调度与切换,完全没有内核切换的开销.

在多核处理器的环境下, 多个线程是可以并行的，协程是并发的.

#### **进程间通信方式：**

1、管道通信：管道是一种半双工的通信方式，数据只能单向流动。匿名管道只能在有血缘关系的进程间进行通信，但命名管道可以让两个毫无关系的进程进行通信。

```
1⃣️如果我们想在不相关的进程间交换数据，我们可以用到FIFO文件来进行通信，这个文件也被称之为命名管道。
2⃣️命名管道其实就是一种特殊的文件类型。
3⃣️进程间通信的原理就是让两个独立的进程看到同一份文件，通过在这个文件里进行读写，就实现了两个进程间的通信了。
匿名管道是通过子进程会继承父进程的PCD的特性，实现两个进程看到同一份文件来实现的。而命名管道是直接创建了一个FIFO文件来实现，两个不相关的进程看到同一个文件的。
```

2、消息队列

3、共享内存。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

4、信号量。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**死锁**

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。

```markdown
## 死锁产生的四个必要条件：

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源
- 不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺
- 循环等待：进程之间循环等待着资源

## 避免死锁的方法：
1.静态策略：预防死锁

- 使用SPOOLING技术虚拟成共享资源，但大部分情况下互斥条件不能破坏，因为加锁就是为了保证互斥
- 一次性申请所有的资源，避免线程占有资源而且在等待其他资源
- 占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源
- 按序申请资源，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源
2.动态策略：避免死锁

- 银行家算法
安全序列：所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。
只要能找出一个安全序列，系统就是安全状态。(如果系统处于安全状态，就一定不会发生死锁,如果系统进入不安全状态，就可能发生死锁)
核心思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。
    检查当前的剩余可用资源是否能满足某个进程的最大需求，
    如果可以，就把该进程加入安全序列,并把该进程持有的资源全部回收。
    不断重复上述过程，看最终是否能让所有进程都加入安全序列。
```

#### 检测与解除死锁

**判断死锁**：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/696686fce1ea4d359fbe60af104d9c24.png)

```markdown
## 解除死锁：
资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
撤销进程法。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。
进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。
```



#### **进程调度策略有哪几种？**

- **先来先服务**：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，对`I/O`密集型进程也不利，因为这种进程每次进行`I/O`操作之后又得重新排队。
- **短作业优先**：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。
- **最短剩余时间优先**：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。
- **时间片轮转**：将所有就绪进程按 `FCFS` 的原则排成一个队列，每次调度时，把 `CPU` 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 `CPU` 时间分配给队首的进程。
  时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。
- **优先级调度**：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

```
非抢占方式：
一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断，或任何其它原因，去抢占该正
在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。
抢占方式：
允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机，重新分配给另一进程。n抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出统开销也较大。
```

#### **进程的状态**

创建、就绪、运行、终止、阻塞。

![image-20220120121814056](https://gitee.com/xu_zuyun/picgo/raw/master/img/83105e7aae933556bb11bd878912f4b6.png)

**运行态→阻塞态**：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。 **阻塞态→就绪态**：则是等待的条件已满足，只需分配到处理器后就能运行。 **运行态→就绪态**：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。 **就绪态→运行态**：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。

#### 父子进程

子进程得到与父进程用户级虚拟地址空间相同但独立的一份副本（包括代码和数据段、堆、共享库以及用户栈）还有与父进程任何打开文件描述符相同的副本。这意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。**子进程只执行fork之后的代码**

它们有不同的 PID。**fork函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。创建进程过程中，可以**通过 fork 的返回值区分父进程和子进程，失败时返回-1，在父进程中返回子进程的 PID。在子进程中返回 0。

**若父进程先结束**

-  子进程成为孤儿进程，被 init 进程收养
-  子进程变成后台进程

**若子进程先结束**

-  父进程如果没有及时回收，子进程变成僵尸进程

### 三、内存管理

#### 堆和栈

- 1.栈的申请是由系统自动调度的，所以申请效率较快，堆的申请是由人为申请，效率没栈快

- 2.栈的空间由系统开辟空间较小，堆的空间较大

- 3.栈是一级缓存，调用完就立即释放，堆是二级缓存，生命周期由虚拟机的垃圾回收算法来决定

- 4.在jvm中，栈处于线程独享区，如虚拟机栈，本地方法栈，堆处于线程共享区，存储对象，数组那些，这也是产生垃圾的地方

#### 操作系统里的内存碎片

1. 内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片。通常内部碎片难以完全避免
2. 外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。  

```
段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。
```

**虚拟内存**

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是[虚拟内存](https://blog.csdn.net/gghhb12/article/details/120831593)。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/6c96803e1c6644f3a4d0d6accdab54f6.png)

```
局部性原理
1:时间局部性：如果执行了程序中的某条指令，那么不久后这条指令有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。
2:空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
```

#### 内存管理方式 [参考](https://www.cnblogs.com/shenckicc/p/6884921.html)

<u>分段和分页的区别：分页是把内存空间划分为**大小相等且固定的块**，作为主存的基本单位，方便管理。分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等</u>

- 分页对程序员是透明的，但是分段需要程序员显式划分每个段。
- 分页的地址空间是一维地址空间，分段是二维的。
- 页的大小不可变，段的大小可以动态改变。
- 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

**分页存储管理**：用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

```
优点：页长固定，因而便于构造页表、易于管理，没有外碎片，每个内碎片不超过页的大小
缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。。
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oOz5YGa5ZCO56uv55qE5YmN56uv,size_20,color_FFFFFF,t_70,g_se,x_16-20231225110047905.png)

**分段存储管理**：段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。

```
优点：段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间
缺点：主存空间分配、地址映射计算比较麻烦，容易在段间留下许多碎片，造成存储空间利用率降低。
```

**段页式存储管理**：

（1）用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。

（2） 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。

```
在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段表长TL。
1) 进行地址变换时，首先利用段号S，将它与段表长TL进行比较。若S<TL，表示未越界
2) 于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址
3) 利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b
4) 再利用块号b和页内地址来构成物理地址。

上图示出了段页式系统中的地址变换机构。在段页式系统中，为了获得一条指令或数据，须三次访问内存。
第一次访问是访问内存中的段表，从中取得页表始址；
第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；
第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。

为了提高执行速度，在地址变换机构中增设一个高速缓冲寄存器。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若未找到匹配表项，则仍须再三次访问内存。
```



![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/20130519103751707.jpeg)

```
优点
(1) 它提供了大量的虚拟存储空间。
(2) 能有效地利用主存，为组织多道程序运行提供了方便。
缺点：
(1) 增加了硬件成本、系统的复杂性和管理上的开消。
(2) 存在着内碎片。
(3) 还有各种表格要占用主存空间。
　段页式存储管理技术对当前的大、中型计算机系统来说，算是最通用、最灵活的一种方案。
```



**虚拟内存的三个特性**

多次性：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存

对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入，换出。

虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量，虚拟内存和物理内存的映射。

#### 几种页面置换算法：

**最佳置换算法（理想）**：将当前页面中在未来最长时间内不会被访问的页置换出去

**先进先出**：淘汰最早调入的页面

**最近最久未使用 LRU**：每个页面有一个t来记录上次页面被访问直到现在，每次置换时置换t值最大的页面（用寄存器或栈实现）

**最少使用算法LFU**：设置寄存器记录页面被访问次数，每次置换当前访问次数最少的。

**第二次机会算法**：FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是  0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清  0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

**时钟：**第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-c58cb9ac67cf4604c47af479fe6240f6_1440w.webp)

### 四、文件管理[参考](https://blog.csdn.net/weixin_42570192/article/details/126236023)

#### 文件的信息

**文件的属性：**
文件名：由创建文件的用户决定文件名，主要为了方便用户找到文件，同一目录下不允许有重名的文件。
标识符：一个系统内的各文件的标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
类型：指明文件的类型，比如文本文档(.txt)、Word文档(.doc/.docx) 等。
位置：文件存放的路径(用户使用)、在外存中的地址(操作系统使用，对用户不可见)。
大小：指明文件的大小。
保护信息：对文件进行保护的访问控制信息。

```
无结构文件由一些二进制或字符流组成，称为流式文件，例如文本文件。
有结构文件由一组相似的记录组成，又称为记录式文件。（分为定长记录和可变长记录）
```



![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0d5ffd9e818649db9b137655d0b9b6dc.png)

（有结构）**文件的逻辑结构**

逻辑结构指的是在用户看来，文件内部的数据应该是如何组织起来的；物理结构指的是在操作系统看来，文件的数据是如何存放在外存中的。

1、顺序文件

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/004df052e6334f54981c4e48a834c619.png)

2、索引文件

索引表本身是定长记录的顺序文件，因此可以快速的找到第 i 个记录对应的索引项。
 可以将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字二分查找，也可以用不同的数据项建立多个索引表。
缺点：由于每个记录对应一个索引表项，因此索引表可能会很大。适用于文件的每个记录占的空间远大于每个索引表项。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/6c5bba9a4f3c4d6cb77960f5fa3dac8b.png)

3、索引顺序文件

给文件建立一张索引表，不是给每个记录对应一个索引表项，而是一组记录对应一个索引表项。通过这种操作，索引表中的索引表项数量会减少很多。

![请添加图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/76308df733264b70be16912d8ce18259.png)

#### 文件目录

<u>目录本身就是一种有结构文件，它由一条条记录组成，每条记录对应一个放在该目录下的文件。</u>

##### 文件控制块

目录文件中的一条记录就是一个文件控制块(FCB，File Control Block)，FCB 中包含了文件的基本信息(包括文件名、物理地址、逻辑结构、物理结构等信息)、存取控制信息(是否可读/可写、禁止访问的用户名单等信息)以及使用信息(文件的建立时间、修改时间等信息)。其中最重要和最基本的是文件名和文件存放的物理地址。

FCB 实现了文件名和文件之间的映射，使用户可以实现按名存取（搜索、创建文件、删除文件、显示目录、修改目录）。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/718076cb10a347e89a0074ff2d3f46c2.png)

##### 单级目录结构

##### 两级目录结构

##### 多级目录结构

也称为树形目录结构，这种结构下，不同目录下的文件可以重名。系统会根据绝对路径一层一层地找到下一级目录。下图所示的就是一个多级目录结构。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e43448c384484558bc1f9c92e03f9769.png)

**无环图目录结构**，就是在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图，这样可以实现多个用户之间的文件共享。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/baac5e41ffd6418783a28bd09ebde63c.png)

#### 索引结点

除了文件名之外的文件描述信息都放到索引结点， 当找到文件名对应的目录项时，才需要将索引结点调入内存

![请添加图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0d3fae9626914419a61d279a4d35fe6c.jpeg)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/b4f4f928c6c944389969be560a51805c.png)

#### 文件共享

硬链接：

<img wid src="https://gitee.com/xu_zuyun/picgo/raw/master/img/b4f4f928c6c944389969be560a51805c-20231227215723629.png"/>

软链接：

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e8502a5dd79e44ad82b84148dd4f04fb.png)

```markdown
1. 文件类型：软链接是一个特殊的文件，而硬链接与原始文件具有相同的文件类型。
2. 跨文件系统：软链接可以跨越文件系统，而硬链接只能在同一个文件系统中创建。
3. 链接对象：软链接可以链接到文件或目录，而硬链接只能链接到文件。
4. 存储空间：软链接的文件大小很小，只占用几个字节的存储空间，而硬链接与原始文件共享存储空间。
5. 删除原始文件：删除原始文件对软链接没有影响，但删除原始文件会导致硬链接失效。
```

#### 访问控制

在每个文件的FCB（或索引结点）中增加一个**访问控制列表**（Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。

或者用精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/29602bb984f643e7900a8a342138ced4.png)



#### 文件的分配方式

操作系统对磁盘的管理包括对非空闲磁盘块的管理(存放了文件数据)和对空闲磁盘块的管理(文件存储空间管理)。

为了方便管理，文件的逻辑地址空间也被分为了一个个的文件块。因此文件的逻辑地址也可以表示为 **(逻辑块号，块内地址)** 这样的坐标形式。

##### 1、连续分配

连续分配方式要求每个文件在磁盘上占有一组连续的块。逻辑上连续的块在物理上也要连续，同时还要保证逻辑上块与块之间的先后顺序映射到物理上之后顺序不变。
在文件目录中记录着存放的起始块号和长度，用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项，物理块号 = 起始块号 + 逻辑块号 。

```
优点：支持顺序访问和直接访问；连续分配的文件在顺序访问时速度最快。
缺点：存储空间利用率低，会产生难以利用的磁盘碎片，不方便文件的扩展（需要复制到空闲区域）
```

##### 2、链接分配

⑴隐式链接

目录中记录了文件存放的起始块号和结束块号，也可以增加一个字段表示文件的长度。除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户来说是透明的。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/29eb99d19ae54df387d6ae3574167955.png)

⑵显式链接

把用于链接文件的各物理块的指针显式地存放在一张表中，这张表就叫做文件分配表(FAT，File Allocation Table)。一个磁盘仅设置一张 FAT，开机时会将 FAT 读入内存，并会常驻内存，FAT 的各个表项在物理上连续存储，且每一个表项长度相同，所以物理块号字段可以是隐含的。
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/2f0f2be4b1324ade9311d9ab608678ea.png)

```
隐式链式分配的优点：很方便文件拓展，不会有碎片问题，外存利用率高。
隐式链式分配的缺点：只支持顺序访问，不支持随机访问，查找效率低，而且指向下一个盘块的指针也需要耗费一定的存储空间。
显式链式分配的优点：既支持顺序访问，也支持随机访问；方便文件拓展，不会有碎片问题；外存利用率高；相比于隐式链接，地址转换不需要访问磁盘，因此文件访问效率更高。
```

##### 3、索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块(建立逻辑块号与物理块号之间的映射关系)，索引表存放的磁盘称为索引块，文件存放的磁盘称为数据块。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/7403a961e34b4a9bbab4c3fc2a900059.png)

与显式链接文件分配表 FAT 是一个磁盘对应一张不同，而索引分配方式中，索引表是一个文件对应一张。

```
索引分配的优点：既支持顺序访问，也支持随机访问；文件拓展非常方便。
索引分配的缺点：索引表需要占用一定的存储空间。
```

如果文件太大，索引表项太多，可以采取**链接方案**、多层索引和混合索引这三种方式来解决，[参考](https://blog.csdn.net/weixin_42570192/article/details/126236023)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/698149e10e5f408bb1ec2cf292dcf370.png)

#### 存储空间的划分与初始化

##### 目录区与文件区

存储空间的初始化：将各个文件卷划分为目录区、文件区。

- 目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据
- 文件区用于存放文件数据。

##### 1.空闲表法（连续分配）

空闲表中记录每个连续空闲区的起始盘块号、盘块数，适用于连续分配方式

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/15d9e39e43a34f62a50e3861d302cd87.png)

```
1.如何分配磁盘块:
采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。
2.如何回收磁盘块:
当回收某个存储区时需要有四种情况：
①回收区的前后都没有相邻空闲区;
②回收区的前后都是空闲区;
③回收区前面是空闲区;
④回收区后面是空闲区。
回收时需要注意表项的合并问题。
————————————————
版权声明：本文为CSDN博主「JungleiRim」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_61888137/article/details/133977387
```

##### 2.空闲链表法

###### 空闲盘块链（**离散分配**）

- 操作系统保存着**链头、链尾指针**。
- 如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。
- 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/00035e59931d4c71a4f0e263dff69da2.png)



###### 空闲盘区链（**连续分配**、**离散分配**）

1.如何分配:
若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，
从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。
若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。

2.如何回收:
若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。
若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/b27c737afff04983be72484a74ede385.png)

###### 3.位示图法（离散分配、连续分配）

- 每个二进制位对应一个盘块。
- 在本例中，“0”代表盘块空闲，“1”代表盘块已分配。
- 位示图一般用连续的“字”来表示,例题中一个字的字长是16位，字中的每一位对应一个盘块。
- 可以用（**字号，位号**)对应一个**盘块号**。也可以描述位（**行号，列号**）

如何分配

若文件需要k个块，
 ①顺序扫描位示图，找到k个相邻或不相邻的“0”;
 ②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;
 ③将相应位设置为“1”。

如何回收:

①根据回收的盘块号计算出对应的字号、位号;
②将相应二进制位设为“0”

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/0679ea6ee0384f62a876433804b6309c.png)

###### 4.成组链接法

空闲表法、空闲链表法不适用于**大型文件系统**，因为空闲表或空闲链表可能过大。
 **UNIX系统**中采用了**成组链接法**对磁盘空闲块进行管理。

1.如何分配

1.如果需求的空闲块为1，小于第一分组的块数
①检查第一个分组的块数是否足够。1<100，因此是足够的。
②分配第一个分组中的1个空闲块，并修改相应数据。

2.如果需求的空闲块为100，等于第一分组的块数
①检查第一个分组的块数是否足够。100=100，是足够的。
②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。
2.如何回收

1.假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。
2.假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。
需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/fe9e0cd0daf84e56b18952424704b527.png)

#### [一些例子](https://blog.csdn.net/qq_61888137/article/details/133999945?spm=1001.2014.3001.5502)

##### 1.创建文件(create系统调用)

1.进行Create系统调用时，

需要提供的几个主要参数:
1.所需的外存空间大小（如:一个盘块，即1KB)
2．文件存放路径（“D:/Demo”)
3.文件名（这个地方默认为“新建文本文档.txt”)
2.操作系统在处理Create系统调用时，

主要做了两件事:
1.在外存中找到文件所需的空间（结合学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)
2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。

##### 2.打开文件

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/7a320db54c7140e1bd88582f7f509bfe.png)

##### 3.文本文件和二进制文件

文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（自定义编码）。

- 文本文件基本上是定长编码的，基于字符嘛，每个字符在具体编码中是固定的，ASCII 码是 8  个比特的编码，UNICODE 一般占 16  个比特。

- 二进制文件可看成是变长编码的， BMP  文件举例，其头部是较为固定长度的文件头信息，前 2 字节用来记录文件为 BMP 格式，接下来的 8  个字节用来记录文件长度，再接下来的 4 字节用来记录 bmp 文件头的长度（不定长的，2、4、8  字节长的值都有）。

##### 4.Ascll、Unicode、utf-8

**本质上来说：**

Unicode是「字符集」    UTF-8 是「编码规则」

**字符集：** 为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）；

**编码规则：** 将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）

ASCII 定长编码 1 字节，Unicode 定长编码 2 字节，UTF-8 变长编码 1-3 字节。Unicode 和 UTF-8 均兼容 ASCII 码。unicode编码的长度固定，内存处理起来很方便。文件的存储中使用utf-8编码，可以压缩内存，节省空间。所以一般有个自动转换的机制，即从文件中读取utf-8编码到内存时，会自动转换为unicode编码，而从内存中将字符保存到文件时，则自动转换为utf-8编码

### 五、IO 接口等

I/O设备就是可以将数据输入到[计算机](https://so.csdn.net/so/search?q=计算机&spm=1001.2101.3001.7020)，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。

```markdown
## 按使用特性分类
1.人机交互类外部设备；如：鼠标，键盘，打印机等，数据传输速度慢。
2.存储设备；用于数据存储，如：移动硬盘，光盘，数据传输速度块。
3.网络通信设备；用于网络通信，如：路由器，调制调节器。数据 传输速度介于上述二者之间。

## 按传输速率分类
1.低速设备；鼠标、键盘等——传输速率为每秒几个到几百字节。
2.中速设备；如激光打印机等—―传输速率为每秒数千至上万个字节。
3.高速设备；如磁盘等一一传输速率为每秒数千字节至千兆字节的设备。
## 按信息交换的单位分类
1.块设备；如磁盘等――数据传输的基本单位是“块’，传输速率较高，可寻址，即对它可随机地读/写任一块。
2.字符设备；鼠标、键盘等―—数据传输的基本单位是字符，传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式。

## 阻塞/非阻塞
阻塞I/O:应用程序发I/O系统调用进程需转为阻塞态等待
eg:字符设备接口―—从键盘读一个字符get
非阻塞l/O:应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待。
eg:块设备接口—―往磁盘写数据write
```

#### IO控制器

```markdown
## 1.接收和识别CPU发来的命令
如CPU发来的read/write命令，I/O控制器中会有相应的控制寄存器来存放命令和参数。
## 2.向CPU报告设备的状态
I/O控制器中会有相应的状态寄存器,用于记录I/O设备的当前状态。
## 3.数据交换
I/O控制器中会设置相应的数据寄存器。
输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。
输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。
## 4.地址识别
类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。
I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器。
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/924d333484c94305bf82b99147c0aae1.png)

#### IO控制方式

1. 程序直接控制

   ```
   CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪)
   轮询检查控制器的状态(其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据,于是CPU会不断地轮询)
   输入设备准备好数据后将数据传给控制器，并报告自身状态
   控制器将输入的数据放到数据寄存器中,并将状态改为0（己就绪)
   CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存
   若还要继续读入数据，则CPU继续发出读指令
   ```

   优点:实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”)

   缺点:`CPU和I/O设备只能串行工作`，CPU需要一直轮询检查，`长期处于“忙等”状态`，CPU利用率低

2. 中断

   ```
   由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待l/O的进程阻塞，先切换到别的进程执行。
   当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。
   处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。
   接着，CPU恢复等待l/O的进程（或其他进程）的运行环境，然后继续执行。
   ```

   优点：`CPU和I/O设备可并行工作`，CPU利用率得到明显提升。

   缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。`而频繁的中断处理会消耗较多的CPU时间`。

3. DMA（Direct Memory Access）

   ```
   CPU指明此次要进行的操作（如:读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如:在磁盘上的地址）控制器会根据CPU提出的要求完成数据的读/写工作,整块数据的传输完成后，才向CPU发出中断信号.
   ```

   优点：

   ①`数据的传送单位是“块”`。不再是一个字、一个字的传送;
    ②数据的流向是从设备直接放入内存，或者从内存直接到设备。
    ③仅在传送一个或多个数据块的开始和结束时，才需要CPU千预。

   缺点：

   CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。

   ![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3ef08b008e7944359c6cc67b482c31c8.png)

4. 通道

通道是一种`硬件`，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令. 与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存

```
CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。之后CPU就切换到其他进程执行了
通道执行内存中的通道程序（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息)
通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3368b5a4cf844658a4f9e2c366a3f730.png)

缺点：实现复杂，需要专门的通道硬件支持
优点：`CPU、通道、I/O设备可并行工作，资源利用率很高`。

**总结**

![](https://gitee.com/xu_zuyun/picgo/raw/master/img/3b0d6abcc4804fc6981e688d18f018b8-20231227223309417.png)

#### 设备类型

- 独占设备：一个时段只能分配给一个进程（如打印机）
- 共享设备：可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。
- 虚拟设备：采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术

```
引入脱机技术后，缓解了CPU与慢速l/O设备的速度矛盾。
即使CPU在忙碌，也可以提前将数据输入到磁带;
即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。
假脱机：SPOOLING技术，内存中虚拟缓冲区
```

**设备分配步骤**

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/8c6522ec14ce498babf1a52a0ecb4c87.png)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/3a05b62ee66448ae9ac17eaaf28166b2.png)

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/d2bf0fa3c98743789bbea76d54f89c51.png)

①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)
②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项。
③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

### [软件层次](https://blog.csdn.net/qq_61888137/article/details/134064769?spm=1001.2014.3001.5502)

- 用户层软件
- 设备独立性软件
- 设备驱动程序
- 中断处理程序
- 硬件

### 六、磁盘

磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据，磁盘的`盘面`被按圈划分成一个个磁道。一个磁道又等分被划分成一个个扇区，各个扇区存放的数据量相同。一个`盘片（磁道）`可能有多个`盘面`， 所有盘面中相对位置相同的磁道组成`柱面`。物理地址：（柱面，盘面，扇区）

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e687bd02674c46a8bb381c47db4ae025.png)

#### 引导块

①开机时计算机先运行ROM中的“自举装入程序”，通过`执行该程序就可找到引导块`，并将完整的“自举程序”读入内存，完成初始化。

②完整的自举程序放在磁盘的启动块（即`引导块/启动分区`）上，启动块位于磁盘的固定位置。 拥有启动分区的磁盘称为启动磁盘或系统磁盘（即C:盘)

#### 磁盘调度算法

- 寻找时间（寻道时间）Ts:在读/写数据前，将磁头移动到指定磁道所花的时间。

- 延迟时间 T R T_R TR:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。

- 传输时间Tt:从磁盘读出或向磁盘写入数据所经历的时间

  ```
  总的存取时间 T a = 寻道时间 T S + 延迟时间 T R + 传输时间 T t
  延迟时间和传输时间都与磁盘转速相关，无法更改，磁盘调度算法会直接影响寻道时间。
  ```

**1.先来先服务(FCFS)**

```
优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去。
缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。
```

**2.最短寻找时间优先(SSTF)**

```
优点:性能较好，平均寻道时间短
缺点:只是选择眼前最优，但是总体未必最优，可能产生“饥饿”现象
```

**3.扫描算法(SCAN)（电梯算法）**

只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动

```
优点:不会产生饥饿现象。
缺点:
①只有到达最边上的磁道时才能改变磁头移动方向，最后一个请求磁道后面的都是无效移动。
②SCAN算法对于各个位置磁道的响应频率不平均(且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;但184号磁道很快又可以再次响应)
```

**4.LOOK调度算法**

如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向

**5.循环扫描算法(C-SCAN)**

只有磁头朝某个特定方向移动时才处理磁道访问请求，而`返回时直接快速移动至起始端而不处理任何请求`。

```
优点:比起SCAN来，对于各个位置磁道的响应频率很平均。
缺点:只有到达最边上的磁道时才能改变磁头移动方向，比起SCAN算法来，平均寻道时间更长。
```

**6.C-LOOK调度算法**

如果磁头移动的万同上已绘没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。

```
优点:比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。
```



#### 固态硬盘

基于闪存技术Flash Memory，属于电可擦除ROM，即`EEPROM`

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/59ee67e8059d483d86167c5b3af46386.png)

```
SSD读写速度快，随机访问性能高，用电路控制访问位置，机械硬盘有寻道时间和旋转延迟。
SSD安静无噪音、耐摔抗震、能耗低、造价更贵。
SSD的一个"块"被擦除次数过多(重复写同一个块)可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉。（磨损均衡技术）
```


## TCP知识

### 一、结构

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/66f088720961165e4bd87997ba3e3535.jpeg)

TCP协议是有连接的,可靠性传输,全双工,面向字节流的传输层协议, 使用TCP协议在客户端和发送端传输数据前,必须先建立连接,传输数据完成之后,就要断开连接

```markdown
        URG：置位了，紧急指针字段才有效
        ACK：确认报文段已收到
        PSH：催促接收方，让其上层尽快取走输入缓冲区数据（push），即便缓存区未满
        RST：复位，强制关闭一个异常连接
        SYN：请求建立一个连接
        FIN：断开一个连接
```

### 二、过程

#### 1. 握手

![https://pic1.zhimg.com/80/v2-c261e806e822ccdf18c066bb9265c280_1440w.webp](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-c261e806e822ccdf18c066bb9265c280_1440w.webp)

##### **为什么需要三次握手才能建立连接**？

原因1：主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而导致不必要的错误和资源的浪费。

```
客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
```

原因2： 两次握手只能保证单向连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据。

##### 第三次可以携带数据吗？

可以。能够发出第三次握手报文的主机，肯定接收到第二次(服务器)握手报文，因为伪造IP的主机是不会接收到第二次报文的。

##### 除了第一个握手报文SYN除外，其它所有报文必须将ACK = 1？

TCP作为一个可靠传输协议，其可靠性就是依赖于收到对方的数据，ACK对方，这样对方就可以释放缓存的数据，因为对方确信数据已经被接收到了。

        但TCP报文是在IP网络上传输，丢包是家常便饭，接收方要抓住一切的机会，把消息告诉发送方。最方便的方式就是，任何我方发送的TCP报文，都要捎带着ACK状态位。
##### 为什么是三次不是两次？

防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

##### TCP 长连接和短连接有什么区别？

 TCP 短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。

 TCP 长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。

##### TCP 通过哪些方式来保证数据的可靠性？

```
1、在数据包层面：校验和
2、在数据包传输层面：序列号、确认应答、超时重传
3、在流量控制层面：拥塞控制
```

#### 2. 挥手

1. `客户端进程发出连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，`客户端进入FIN-WAIT-1（终止等待1）状态`。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. `服务器收到连接释放报文，发出确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，`服务端就进入了CLOSE-WAIT（关闭等待）状态`。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，`客户端就进入FIN-WAIT-2（终止等待2）状态`，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
4. `服务器将最后的数据发送完毕后，就向客户端发送连接释放报文`，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，`服务器就进入了LAST-ACK（最后确认）状态`，等待客户端的确认。
5. `客户端收到服务器的连接释放报文后，必须发出确认`，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，`客户端就进入了TIME-WAIT（时间等待）状态`。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，`当客户端撤销相应的TCB后，才进入CLOSED状态`。
6. 服务器只要收到了客户端发出的确认，`立即进入CLOSED状态`。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，`服务器结束TCP连接的时间要比客户端早一些`。

![https://img-blog.csdnimg.cn/664bb95667774a4eb40712fba12aa182.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc21hbGxfZW5naW5lZXI=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc21hbGxfZW5naW5lZXI=,size_18,color_FFFFFF,t_70,g_se,x_16.png)

##### 为什么挥手需要四次？

半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力

##### 挥手报文丢失会发生什么？

**第一次挥手丢失**

如果客户端一直收不到ack应答报文的话，就会触发超时重传机制，最大重传次数由tcp_orphan_retries参数决定。当超过指定次数时，就不再发送报文，直接进入close状态

**第二次挥手丢失**

当ack报文丢失时，ack是不会重传的。服务端的ack报文丢失了，客户端就会触发超时重传，直到收到ack报文或则到达超时重传次数。

**第三次挥手丢失**

内核就会发出FIN报文，进入LAST_ACK状态，等待客户端返回ack来确认关闭连接。如果服务端没有收到ack，则会跟客户端重传FIN报文一样

**第四次挥手丢失**

如果服务端没有收到ack报文的话，服务端就会重发FIN报文，重发次数仍然由tcp_orphan_retries参数控制

##### 为什么需要TIME_WAIT状态？

`防止错误接收历史报文`：tcp序列号可能会发生绕回问题，这就意味着无法通过tcp序列号来判断是不是历史报文

`保证双方能够正常关闭`：不采用time_wait的话，如果服务端没有收到ack报文的话，就会重传FIN报文，而此时客户端已经close了，就会返回一个RST错误报文。采用time_wait的话，B收不到这个最后一个确认报文，就会超时重传连接释放报文段，然后A可以在`2MSL`时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到`CLOSED`状态。

##### 如果已经建立了连接，但是另一端突然出现故障，会发生什么？

*TCP有保活机制*：当一端时间相互直接没有发送数据时，就会触发保活机制。即每隔一段时间都发送一次探测报文给对方，如果几次都不回应的话，就会认为对方已经死亡了，那么就会断开连接。

*应用层心跳机制：*web服务一般都会提供time_keeplive参数，用来指定http长连接超时时间。

##### TCP的粘包和拆包

TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题。

**为什么会产生粘包和拆包呢?**

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

**解决方案：**

- 发送端将每个数据包封装为固定长度，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息
- 在数据尾部增加特殊字符进行分割（\r\n标记，FTP协议正是这么做的）
- 将数据分为两部分，一部分是头部，一部分是内容体，包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。

##### TCP的KeepAlive

交互双方都有可能出现掉电、死机、异常重启等各种意外，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费TCP， KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

具体流程：

1. **心跳包**： 这通常是一个轻量级的控制消息或者特定的TCP选项，用于告知对端主机当前主机仍然在连接中。
2. **心跳间隔**： 发送心跳包的时间间隔，它需要足够频繁以便能及时检测到连接问题，但又不能过于频繁以免造成不必要的网络负担。
3. **超时重试**： 如果在预定的时间内没收到心跳响应或确认，系统将尝试重新发送心跳包或采取其他恢复措施。如果连续多次尝试失败，系统可能会认定该连接已断开，并终止连接。
4. **空闲检测**： 有些系统会在连接上没有数据传输的情况下才发送心跳包，避免在正常的数据传输中增加额外的网络流量。
5. **保活定时器（Keepalive Timer）**： TCP提供了一个可选的保活定时器功能，可以在套接字级别启用。当启用后，如果连接在指定的时间内没有任何数据交换，TCP层会自动发送一个保活探测包。

##### TCP的标志位

1. **URG (Urgent Flag)**: 当URG=1时，表明紧急指针字段（Urgent Pointer）有效，需要优先处理这段数据。接收方应该立即处理紧急数据，而不是按照正常队列顺序。

   ```
   具体应用场景：
   Telnet 中断或终止远程主机上正在执行的长时间运行的命令
   FTP 取消一个长文件传输
   配合紧急指针使用：如果紧急指针的值是N，那么从当前序列号开始的前N个字节被认为是紧急数据。
   ```

2. **ACK (Acknowledgment Flag)**: ACK=1表示确认字段是有效的，即这是一个确认报文。在连接建立之后，几乎所有传送的TCP报文都会设置ACK位（除了ACK报文）。

3. **PSH (Push Flag)**: 当PSH=1时，接收方应该尽快将这个报文交给应用层，而不是缓存起来等待更多的数据到达。

   ```
   具体应用场景：
   Telnet或SSH客户端键入命令时，每次按键都应尽快被发送到远程主机并获得响应
   IRC、在线聊天室或即时消息传送服务会使用PSH标志
   ```

4. **RST (Reset Flag)**: RST=1用于重置不正常的连接，或者拒绝非法的报文或打开请求。它也可以用来清理某个端口上的旧连接，以便新的客户端能够重新使用这个端口。

   ```markdown
   具体应用场景：
   1. 如果服务器收到一个不属于任何活动连接的TCP段，可能会响应一个带有RST标志的段。告知对方该端口上没有对应的连接。
   2. 如果一个端点需要由于某种错误或者特殊情况而强行关闭连接，它可以发送一个RST段。
   3. 服务器端由于某种原因不愿意建立这个连接，它可以通过发送一个RST段来拒绝连接。
   4. 当一方决定中断长时间空闲的TCP连接时，可能会发送一个RST包来清除连接状态。——发送方：发送RST段以通知对方中断连接。接收方：收到RST段并释放所有相关资源，认为连接已终止。
   5. 在TCP三次握手的过程中，如果发起方在等待最终的ACK确认前改变主意，它可能会发送一个RST包来中止握手过程。
   ```

5. **SYN (Synchronize Flag)**: SYN=1仅在三次握手建立TCP连接时出现。它表示同步序列号，用于建立和协调初始的序列号。当想要建立新连接时，发送方会设置这个位。

6. **FIN (Finish Flag)**: FIN=1表示发送方已经没有数据要发送，并希望关闭连接。它用于在结束对话时的连接释放过程中。

#### 3.拥塞控制

##### 滑动窗口

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-704a9dee68e7f4eb215b26b8c4d7903b_1440w.webp)

流量控制：TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。

##### 拥塞控制

```markdown
## ARQ协议
自动重传请求（Automatic Repeat-reQuest，ARQ）,通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。具体可细分为 停止等待ARQ协议 和 连续ARQ协议.
## 停止等待ARQ协议
发送方在发送一个帧后停止发送，等待接收方的确认。在收到接收方发送的确认（ACK）之后，发送方才会发送下一个帧。如果确认没有在预定时间内到达，发送方会重发该帧。

## 后退 N 帧 ARQ
发送方可以发送多个帧而无需等待确认，但是它必须在窗口大小内。当发生错误时，从错误的帧开始，直到窗口末尾的所有帧都需要重传。

## 选择重传 ARQ
发送方发送多个帧，并且只有那些未被正确接收的帧会被重传。发送方和接收方都维护一个窗口。这种协议允许接收方接收并缓存非顺序到达的帧。
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/5bce2c7426a94dbebaafad208e564e33.png)

-   当 cwnd < ssthresh 时，使用慢开始算法。

-   当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

- 当有包超时，cwnd阈值减半，cwnd设置为0，重新开始慢启动

  ```
  慢开始：经过一个往返时间RTT就把发送方的拥塞窗口cwnd加倍
  拥塞避免：经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1
  ```

  快恢复：当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（这种情况下慢开始算法只是在TCP连接建立时和网络出现超时时才使用）

```
快重传:
算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。
发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段
```

### 三、优缺点

#### 优点

可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

#### 缺点

- 慢，TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，
- 效率低，占用系统资源高，而且要在每台设备上维护所有的传输连接，每个连接都会占用系统的CPU、内存等硬件资源。
- 易被攻击，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

```
在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 …………

什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP
```

## UDP知识

### 报文结构

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/fbbab71814d374019e28f20af1315717.png)

如果校验和出错，该报文就会被丢弃。

##### 端口号

- 0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的。
- 1024 - 65535: 操作系统动态分配的端口号。 客户端程序的端口号, 就是由操作系统从这个范围分配的。

##### 长度和校验和

- 长度指的是UDP报文整体长度
- 校验和：（可选）数据分割成16位（2字节）的块。计算所有16位的块的二进制求和，如果有溢出，则将溢出的高位再加到低位上（这称为回卷或端回绕加法），最后再取反。

##### 缓冲区

- UDP没有真正意义上的发送缓冲区. 调用sendto会直接交给内核（应用层发一个，传输层送走一个）, 由内核将数据传给网络层协议进行后续的传输动作;

- UDP具有接收缓冲区，如果缓冲区满了, 再到达的UDP数据就会被丢弃;

```markdown
无连接: 知道对端的IP和端口号就直接进行传输, 不需要建立连接;

不可靠: 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方导致丢包, UDP协议也不会给应用层返回任何错误信息;

面向数据报: 不能够灵活的控制读写数据的次数和数量，sendto几次就recvfrom几次。应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并; 用UDP传输100个字节的数据: 如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节; 而不能循环调用10次recvfrom, 每次接收10个字节

UDP成功读取都将读取到一个报文，我们不用考虑报头的问题，只需要做好有效载荷的序列化与反序列化问题即可。
```


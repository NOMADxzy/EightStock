## 数据库

#### SQL执行流程

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16.png)

1、在打开客户端后，最初需要和sql服务器建立连接，账号认证和校验权限。

2、认证后，客户端发生查询sql脚本给服务器

3、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。

4、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。

5、MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。

6、将结果返回给客户端。

#### 语句执行顺序：

select from 表 <on 条件 join 右表> where <条件> group by <字段> having <条件> DISTINCT <字段> order by <条件> limit <数量>



### 一、数据库三范式(不可再分、部分依赖、传递依赖)

[nf](https://blog.csdn.net/A_art_xiang/article/details/113880638)

#### 第一范式

1NF 原子性：列或者字段不能再分，要求属性具有原子性，不可再分解；

![1nf](https://img-blog.csdnimg.cn/20210220121125532.png)

#### 第二范式

2NF唯一性： 要求非主键字段的值必须完全依赖主键（不能部分依赖），表中，学分是依赖课程的，成绩是部分依赖联合主键（学生，课程）的。

![2nf](https://img-blog.csdnimg.cn/20210220122011873.png)

#### 第三范式

3NF 直接性：数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系。

![3nf](https://img-blog.csdnimg.cn/20210220122950155.png)

### 二、数据库事务

#### 1.事务特性

原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态

隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

#### 2.隔离级别

(1) 读未提交（read Uncommited）:

在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用，      安全性太差；
(2) 读已提交（read commited）:

这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；这个隔离级别满足了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题；
由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题（下面详细介绍这种问题，结合问题来理解隔离级别的含义）；
(3 ) 可重复读（Repeatable read）：

这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
(4) 可串行化（serializable）：

事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；

### 三、索引

#### 实现原理

索引的原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

- \1. 把创建了索引的列的内容进行排序
- \2. 对排序结果生成倒排表
- \3. 在倒排表内容上拼上数据地址链
- \4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

#### 索引优点

索引存储在内存中，为服务器存储引擎为了快速找到记录的一种数据结构。索引的主要作用是加快数据查找速度，提高数据库的性能。

    优点：
    
    创建唯一性索引，保证数据库表中每一行数据的唯一性
    大大加快数据的检索速度，这也是创建索引的最主要的原因
    加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
    在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    
    索引的分类（必会）
    
    普通索引：最基本的索引，它没有任何限制。
    唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
    主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用     primary key 来约束。
    联合索引（又叫复合索引）：多个字段上建立的索引，能够加速复合查询条件的检索。
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVsb2lzZV95YW5neXVjaGFuZw==,size_13,color_FFFFFF,t_70,g_se,x_16.png)

#### 设计原则

- \1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列，对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
- \2. 基数较小的表，索引效果较差，没有必要在此列建立索引
- \3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间， 如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
- \4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进 行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
- \5. 定义有外键的数据列一定要建立索引（**限制并发性、影响性能**）。
- \6. 更新频繁字段不适合创建索引
- \8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- \9. 对于定义为text、image和bit的数据类型的列不要建立索引。

#### Mysql中的实现

Mysql的存储引擎(InnoDB,MyISAM)层中实现的：

B+Tree 索引: 最常见的索引类型, 大部分索引都支持B+树索引.

Hash 索引: 只有Memory引擎支持, 使用场景简单.

R-Tree索引(空间索引): 空间索引是MyISAM引擎的一个特殊索引类型, 主要地理空间数据, 使用也很少.

S-Full-text(全文索引): 全文索引也是MyISAM的一个特殊索引类型, 主要用于全文索引, InnoDB从Mysql5.6版本开始支持全文索引.

### 四、数据库锁

#### 行锁和表锁

1.主要是针对锁粒度划分的，一般分为：行锁、表锁、库锁

行锁：访问数据库的时候，锁定整个行数据，防止并发错误。

表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

页级锁：是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。

**行锁 和 表锁 的区别：**

 表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

 行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

#### 悲观锁和乐观锁

（1）悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

（2）乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

### 五、数据库设计

A：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。

B：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间, 前提是这个列经常被用到, 这也就是反第三范式。

C：分割表。

数据表拆分：主要就是垂直拆分和水平拆分。

水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。

垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。

D: 字段设计

    表的字段尽可能用NOT NULL
    字段长度固定的表查询会更快
    把数据库的大表按时间或一些标志分成小表
### 六、数据库扩展

#### 垂直扩展

- 也称为纵向扩展，是通过向现有机器添加更多的性能（CPU、RAM、DISK等）来进行扩展。
- 单点故障的风险增加。
- 垂直扩展的总体成本较高。强大的服务器更加昂贵。

#### 水平扩展

也称为分片，是添加更多服务器的做法，将大型数据库分割成更小、更易管理的部分，称为分片。每个分片共享相同的模式，尽管每个分片上的实际数据是唯一的。

![image-20230517210216761](https://gitee.com/xu_zuyun/picgo/raw/master/img/60df5ceccfc849e7a5a3c23f5b909e30.png)

- **重新分片问题：**在选择分片键时，最重要的一个标准是选择一个能够均匀分布数据的键。某些分片可能由于不均匀的数据分布而更快地耗尽分片。当分片耗尽时，需要更新分片函数并移动数据。
- **热点键问题**：也称为明星问题。对特定分片的过度访问可能导致服务器超载。
- **连接和去规范化**：一旦数据库被分片到多个服务器上，执行跨数据库分片的连接操作就变得困难。一个常见的解决方法是对数据库进行去规范化，以便可以在单个表中执行查询。

### - 问题

##### 1、count(*)、count(1)、count(列)的区别？

- `COUNT(1)`: 此查询返回的是结果集中的行数，不关心具体的列内容，因此使用常数1。
   在很多数据库系统中，这种方式被优化为与 `SELECT COUNT(*)` 相同的性能水平，因为数据库引擎通常忽略括号内的内容。
- `COUNT(*)`：统计整个表的行数，不考虑是否有NULL值。
   通常优于 `COUNT(id)`，因为它不需要关心具体的列，且现代数据库引擎会对其进行特殊优化。
- `COUNT(列)` ：统计指定列非空值的数量。需要考虑是否有NULL值
   此种方式取决于列是否有索引。如果 列有索引，数据库引擎可能会利用索引进行快速计数。如果没有索引，或者有大量NULL值，性能可能较差，因为需要扫描整个表。

### 参考

[](https://blog.csdn.net/bangyanya/article/details/127221534)
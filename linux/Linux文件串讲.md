### 十六、linux是如何根据文件名打开文件的

inode负责文件的元数据和数据存储，文件存储块负责实际数据的存储，而目录文件维护文件名和inode之间的联系。

> 1. **用户空间到内核空间：**首先，当用户程序请求打开一个文件时（例如使用`open`系统调用），程序将文件路径名传递给操作系统。这是从用户空间向内核空间进行系统调用的过程。
>
> 2. **解析路径名：**操作系统需要解析提供的路径名。如果路径是绝对路径，解析从根目录开始；如果是相对路径，则从当前工作目录开始。路径名可能包含多个组件，由斜杠(`/`)分隔。
>
> 3. **查找目录项：**文件系统会逐级查找路径中的每个目录项。每个目录项都有一个关联的inode和文件名。从当前目录（或根目录）的inode开始，文件系统读取目录内容，寻找与第一个路径组件匹配的目录项。
>
> 4. **获取iNode号：**一旦找到了匹配的目录项，就会获得与之关联的inode号。如果路径中还有更多的组件，文件系统会使用这个inode号获取下一级目录的信息，并重复步骤3和4，直到找到最终文件名对应的inode号。
>
> 5. **获取iNode结构：**文件系统使用inode号来索引inode表，读取该文件的inode结构。inode结构包含了文件的元数据，如文件大小、权限、所有者以及指向文件实际数据块的指针。
>
> 6. **权限检查：**在打开文件之前，系统会检查当前进程是否有足够的权限（基于inode中的权限信息）来执行请求的操作（读、写或执行）。
>
> 7. **创建文件描述符：**权限检查通过后，内核会为该文件创建一个文件描述符（file descriptor）。文件描述符是一个非负整数，它在内核中唯一标识已打开的文件，并可被进程用来读写文件。
>
> 8. **读取内容**: 程序通过指定文件句柄/描述符并使用相应的系统调用（如UNIX中的`read`或Windows中的`ReadFile`）来请求读取文件内容。程序需要提供缓冲区（内存地址）供操作系统填充数据。
>
> 9. **磁盘操作**: 文件系统管理硬盘上的文件存储。当收到读取请求时，它会确定文件数据在硬盘上的位置，并发起磁盘I/O操作，将数据从硬盘复制到操作系统内核空间的缓冲区中。
>
>    ```
>    这样的设计允许操作系统有效地管理文件系统、内存和其他资源，同时提供权限控制和安全保护，确保只有有权访问的程序才能读取特定文件的内容。
>    ```
>
> 10. **数据传输**: 从内核缓冲区，数据被复制到程序提供的用户空间缓冲区中。对于大文件，这个过程可能会分多次进行，每次读取一部分数据。
>
> 11. **操作结束**: 一旦读取操作完成（或者在读取过程中遇到文件尾EOF），程序可以开始处理数据。如果读取期间发生错误，比如硬件故障或者文件损坏，系统调用通常会返回一个错误码。
>
> 12. **关闭文件**: 完成文件操作后，程序需要使用系统调用（如UNIX中的`close`或Windows中的`CloseHandle`）来关闭文件句柄/描述符。这个步骤会告知操作系统文件不再被使用，释放相关资源。
>
> ```markdown
> 当我们尝试打开/usr/local/a.txt这个文件时，操作系统会经历以下步骤：
> 
> 1. 路径解析：
> 操作系统首先解析文件的路径。根据路径/usr/local/a.txt，它会从根目录开始查找。
> 首先，它会读取根目录/的内容，查找usr这个目录条目对应的inode号码。
> 一旦找到usr目录的inode，系统就会加载这个inode，并访问存储在usr目录下的`文件条目和子目录`的列表。
> 接着在usr目录下查找名为local的目录，并重复上述过程，即加载其inode，查找local目录下的内容。
> 最后在local目录的内容中找到名为a.txt的`文件条目`，并获取其对应的`inode号码`。
> 
> 2. inode加载：
> 系统根据得到的inode号码，从磁盘上的`inode表`中加载a.txt文件的`inode结构`。
> inode结构包含了文件的各种属性信息，如文件类型、权限、所有者、组、文件大小、时间戳（创建、修改、访问时间）以及指向文件实际数据的指针。
> 
> 3. 权限检查：
> 不通过将返回一个错误，通常是“Permission denied”。
> 
> 4. 文件打开：
> 一旦确认用户有相应的权限，系统会在内核中为该文件创建一个文件描述符（`整数`）。
> 
> 有了文件描述符之后，就可以通过Linux提供的系统调用（如read(), write()等）来操作文件内容了。
> 文件的实际数据可能存储在硬盘的不同位置，inode中的`指针`会指向这些数据所在的数据块。
> 系统会根据需要从磁盘读取数据到内存中，或者将内存中的数据写入到磁盘。
> 
> 5. 关闭文件：
> 完成对文件的操作后，程序会调用close()系统调用来关闭文件描述符。
> 关闭文件描述符后，相关资源会被释放，该文件描述符也可以被其他文件使用。
> ```
>
> #### Linux文件目录
>
> - 绝对路径是从根目录（/）开始的完整路径，它可以唯一地标识一个文件或目录
>
> - 相对路径是相对于当前工作目录的路径
>
>   ```
>   cd: 改变当前工作目录
>   pwd: 显示当前工作目录的路径
>   ls: 列出指定目录下的文件和子目录 其实就是输出了目录文件的内容
>   chdir: 改变当前工作目录
>   getcwd: 获取当前工作目录的路径
>   access: 判断文件是否存在或是否有指定的权限
>   ```
>
> #### Linux系统目录文件是什么？
>
> 在Linux中，目录是一种特殊类型的文件。它的主要作用是存储其他文件和子目录的索引。一个目录文件包含了一系列的条目，每个条目都连接着一个文件名到相应文件（或子目录）的inode号码。
>
> - **文件名**：在该目录下的文件或子目录的名称。
> - **inode号码**：与每个文件名对应的inode的唯一标识符。这个inode号码指向文件系统中的inode表里的一个特定的inode
>
> 假设有一个目录 /home/user/docs/，里面有三个文件 file1.txt、file2.txt 和 file3.txt。这些文件在磁盘上分别有以下 inode 号码：
>
> ​	•	file1.txt 的 inode 号：12345
>
> ​	•	file2.txt 的 inode 号：12346
>
> ​	•	file3.txt 的 inode 号：12347
>
> 目录文件 /home/user/docs/ 的内容可以用以下表格形式来表示：
>
> | 文件名    | iNode号码 |
> | --------- | --------- |
> | .         | 11111     |
> | ..        | 11110     |
> | file1.txt | 12345     |
> | file2.txt | 12346     |
> | file3.txt | 12347     |
>
> #### Linux系统文件种类有哪些？
>
> 在Linux操作系统中，几乎所有的外接设备都是以文件的形式表示和访问的。这一设计理念体现在Linux的常说原则“一切皆文件”（Everything is a file）上。无论是硬盘、USB驱动器、打印机还是其他外围设备，它们在Linux中通常都有对应的文件表示。这些设备文件通常位于`/dev`目录下
>
> DT_REG：普通文件
> DT_DIR：目录文件
> DT_FIFO：命名管道
> DT_SOCK：套接字文件
> DT_CHR：字符设备文件
> DT_BLK：块设备文件
> DT_LNK：符号链接文件（软链接）
>
> ##### 套接字文件：
>
> 本地套接字通常位于`/tmp`目录、`/var/run`目录，如：
>
> - /var/run/mysqld/mysqld.sock：MySQL
> - /proc/net/tcp：所有的TCP套接字文件
>
> ##### 字符设备文件：
>
> **特点：**
>
> - 数据按字符（字节）流处理。
> - 支持串行访问。
> - 通常用于像键盘、鼠标、串口和打印机这样的设备。
>
> **示例：**
>
> - `/dev/tty` - 表示当前终端的控制终端。
> - `/dev/null` - 一个特殊的字符设备，任何写入它的数据都会被丢弃，读取它总是返回文件结束。
> - `/dev/random` 和 `/dev/urandom` - 随机数生成器设备，提供随机数据。
> - `/dev/ttyUSB0` - 第一个 USB 串行端口设备文件。
>
> ##### 块设备文件：
>
> ##### 特点：
>
> - 数据按块（通常是512字节或更大）处理。
> - 支持随机访问。
>
> ##### 示例：
>
> - `/dev/sda` - 第一个SCSI或SATA硬盘。
> - `/dev/sdb`, `/dev/sdc` 等 - 其他SCSI或SATA硬盘。
>
> ```bash
> ls -l命令查看/dev目录下的内容来区分字符设备和块设备
> brw-rw---- 1 root disk 8, 0 Mar 10 08:53 /dev/sda
> crw-rw-rw- 1 root tty 5, 0 Mar 10 09:08 /dev/tty
> ```
>
> #### Linux文件按块存储
>
> 在Linux文件系统中，一个数据块通常只用于存储单个文件的数据。每个数据块被分配给文件时，它将专门用于该文件的内容，并且不会与其他文件共享。
>
> 块的大小有1 KB、2 KB、4 KB或更大，当一个文件小于一个块的大小时，产生的未使用空间称为内部碎片。
>
> #### Linux系统 Inode表是什么？
>
> inode表是一个数据结构，它位于Unix和类Unix文件系统中，用来存储文件的元数据信息（除了文件名和目录信息之外的所有信息）。每个文件或目录在文件系统中都有一个唯一的inode，并且有一个对应的条目在inode表中。
>
> 每个inode条目通常包含以下信息：
>
> - **文件的类型**：比如普通文件、目录、符号链接、字符设备、块设备等。
>
> - **权限位**：指明哪些用户对该文件有读、写、执行权限。
>
> - **所有者**：文件的所有者的用户ID（UID）。
>
> - **所属组**：文件的所属组的组ID（GID）。
>
> - **文件大小**：文件的字节大小。
>
> - **时间戳**：文件的最后访问时间、最后修改时间、inode状态的最后改变时间等。
>
> - **链接计数**：指向该文件的硬链接数量。
>
> - **数据块指针**：指向文件实际内容的数据块的指针。这可能包括直接指针、间接指针、双重间接指针和三重间接指针。
>
>   ```markdown
>   `直接指针`: 这些指针直接指向包含文件数据的硬盘块。在inode中，通常有多个直接指针，每个指向一个不同的数据块。小文件的数据可能完全由直接指针引用。
>   
>   `间接指针`: 一旦直接指针不足以引用文件数据时，就会使用间接指针。一个间接指针指向一个硬盘块，而这个硬盘块完整地被用作存储其他指针的数组，这些新指针各自指向实际包含文件数据的硬盘块。
>   
>   `双重间接指针`: 当一个间接指针还不够时，双重间接指针会被利用
>   
>   `三重间接指针`: 在极少数情况下，如果文件非常大，即使双重间接指针也不够用时，就会使用到三重间接指针
>   
>   实际数据：
>   所以Linux文件系统是通过这种`索引分配`方法来管理文件的数据块
>   有些文件系统（FAT32，EXFAT）是通过`链接分配`来管理的
>   `顺序分配`比较少用，因为容易产生碎片
>   ```
>
> 当文件系统被格式化时，inode表会被创建并预分配一定数量的inode，这些inode会占据连续的空间。每个inode都有一个数字标识符（称为inode号），文件系统通过这个inode号来引用特定的文件元数据。
>
> 文件名与inode之间的映射存储在目录项中。目录本身也是一种特殊的文件，它的内容包含了文件名和相应的inode号码。这样设计可以允许多个文件名（硬链接）指向`同一个inode`，因此同一个文件可以出现在多个位置，但是其元数据实际上只存储一份。
>
> ![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/e928cf1806224bb7a1e360d7fa4504ee-20240326102301475.png)
>
> #### Inode相关命令
>
> ```bash
> 在 /home/user 目录下查找 inode 号为 123 的文件：
> find /home/user -inum 123
> 
> 查看 filename的 inode 号
> ls -i filename
> ```
>
> #### 硬链接和软链接
>
> 硬链接：
>
> 1. **定义**：硬链接是指向文件inode的直接指针。创建硬链接时，实际上是在不同的位置创建了相同的文件名，这些文件名指向同一个inode号。
> 2. 硬链接像是给文件创建了一个额外的“别名”，与原始文件完全等同。
>
> 软链接：
>
> 1. **定义**：软链接（符号链接）是一个特殊类型的文件，它包含了另一个文件的路径名信息。软链接文件自己有独立的inode和数据块，数据块中存储的是其所指向的目标文件的路径名。
> 2. **属性独立**：软链接与它所指向的文件有着不同的权限、所有者和大小信息。软链接的大小通常是它所包含的路径字符串的字符数。
> 3. **限制**：软链接可以跨文件系统创建，因为它们通过路径名而非inode号来引用文件。软链接可以指向目录，也可以指向不存在的文件或目录。
> 4. **删除行为**：删除软链接不会影响目标文件。如果删除了目标文件，软链接将成为一个悬空链接，也就是说它不再指向一个有效的文件，尝试访问该软链接将产生错误。
>
> #### Linux文件权限
>
> 每个文件和目录都有三组权限：
>
> 1. **所有者（Owner）权限**：文件的创建者通常是其所有者，并且可以设置文件的权限。
> 2. **组（Group）权限**：文件属于一个用户组，该组内的所有用户共享相同的权限。
> 3. **其他用户（Others）权限**：系统上的其他用户的权限。
>
> 每组权限三种类型：
>
> - **读（Read, r）**：允许读取文件内容或列出目录中的内容。
> - **写（Write, w）**：允许修改文件内容或向目录中添加/删除文件。
> - **执行（Execute, x）**：允许执行文件，或允许进入目录并访问其包含的文件和子目录。
> - 所以 验证权限时 需要递归向上级目录验证权限
>
> 示例：
>
> ```bash
> -rwxr-xr-- 1 user group 1024 Mar 10 08:53 example.txt
> 第一个字符表示文件类型（例如-代表普通文件，d代表目录，l代表符号链接等）。
> 
> chmod u=rwx,g=rx,o=r example.txt  # 使用字母设置权限
> chmod 754 example.txt             # 使用数字设置权限
> ```
>
> #### 视频为什么支持随机播放？
>
> 现代视频文件通常使用容器格式存储多个数据流（视频、音频以及可能的字幕流），将它们分割成较小的部分，称为**帧**（视频）或**样本**（音频）。每一帧或样本都关联着特定的时间码，这允许播放器快速定位到视频中的特定位置。
>
> 1. **关键帧**: 关键帧（或I帧）是可以独立解码的帧，不需要依赖其他帧。播放器可以直接跳转到任何关键帧并开始播放，使得时间定位变得快速而精确。
> 2. **索引**: 许多视频容器格式都包含用于快速访问文件其他部分的索引信息。比如，元数据中会包括哪些帧是关键帧，它们的具体位置以及对应的时间码。
>
> 当用户请求跳转到视频的某个时间点时，播放器会查找**最接近的关键帧**，并从那里开始解码和播放。
>
> #### 文件的逻辑组织方式？
>
> - 无结构文件：二进制流
>
> - 有结构文件：由很多条记录组成
>
>   - **顺序文件**：其中的数据按照顺序排列，例如文本文件。读取这样的文件时，通常是从头到尾依次读取。
>
>     如：txt文件、日志等
>
>   - **索引文件**：将记录的某一部分抽取出来建立索引机制来存储和检索数据。在这种组织方式下，文件的访问不依赖于数据在存储介质上的物理顺序，而是通过一个索引来进行直接访问。
>
>     如：数据库、pdf、视频等
>
> - 直接（随机访问）文件
>
>   - 允许用户直接访问文件中的任意位置，而不需要从头开始顺序读取
>
>     如：.xlsx
>
> 所以`目录是索引文件`，文件名 -> inode号
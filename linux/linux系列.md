## linux系列

- 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。
- 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。 

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/66bdf61474a03d7eae453641bb802df7.png)

- Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。
- 内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统

```markdown
## 一．Linux内核
内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。
## 二．Linux shell
shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。
## 三．Linux文件系统
文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、EXT3、EXT3、FAT、FAT32、VFAT和ISO9660。
## 四．Linux应用程序
标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、XWindow、办公套件、Internet工具和数据库等。
```

### 一、linux内核

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/aeb3e998da33476090b47c0a843de966.png)

#### 1、进程调度

    进程调度控制系统中的多个进程对CPU的访问，使得多个进程能在CPU中“微观串行，宏观并行”地执行。
    进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。

##### Linux进程的状态

- R运行状态（running）: 并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。
- S睡眠状态（sleeping): 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep））。

- 磁盘休眠状态（Disk sleep）：有时候也叫不可中断睡眠状（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。

- T停止状态（stopped）： 可以通过发送 SIGSTOP 信号给进程来停（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。

- X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态

- Z僵死状态（Zombies） :进程已经退出了但是资源还没有完全被释放的一种状态。

#### 2、内存管理

    内存管理的主要作用是控制多个进程安全地共享主内存区域。
    Linux内存管理对于每个进程完成从虚拟内存到物理内存的转换。
#### 3、虚拟文件系统

```
Linux虚拟文件系统隐藏了各种硬件的具体细节，为所有设备提供了统一的接口,独立于各个具体的文件系统，是对各种文件系统的一个抽象。
它为上层的应用程序提供了统一的vfs_read（）、vfs_write（）等接口，并调用具体底层文件系统或者设备驱动中实现的file_operations结构体的成员函数。
```

#### 4、网络接口

```markdown
网络接口提供了对各种网络标准的存取和各种网络硬件的支持。
如下图所示，在Linux中网络接口可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序。

## 套接字
套接字（socket）是一种通信机制，提供了一组函数和接口，使不同计算机之间的进程可以通过网络进行通信。套接字实际上是一个抽象的概念，它代表了网络通信中的一个端点，3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。
`流套接字`提供了一种可靠的、面向连接的服务，比如TCP协议就是基于流套接字实现的。`数据报套接字`则提供了一种不可靠的、无连接的服务，比如UDP协议就是基于数据报套接字实现的。
        套接字的创建和使用与管道是有区别的，因为套接字明确地将客户和服务器区分开来。套接字机制可以实现将多个客户连接到一个服务器。
```

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/2df0396f175f488cabda666f632dfb8f.png)

##### 服务器：

1. 创建套接字，即实例化。server = socket.socket()
2. 绑定地址，且地址是一个元组，里面包括ip和端口，为自己创建了一个地址，用于客户端的连接。server.bind(('127.0.0.5',8520))
3. 开始监听，此时的套接字server才被真正叫做监听套接字，自此之前，客户端是无法连接过来的。代码中的5表示最大能同时连接到客户端的数量。server.listen(5)
4. 收到连接请求就建立与客户端连接，返回结果由两个变量接收，第一个变量是对等连接套接字，第二个是客户端的地址（ip和端口）a,b = server.accept()，这里要特别注意是会有阻塞现象，阻塞在下面介绍。
5. 利用对等连接套接字开启接收信息状态。若接到空值，表示客户端已主动断开连接。这里也会产生一次阻塞，客户端是无法发送空值的。代码的1024表示可以接收的最大字节数。a.recv(1024)
6. 信息传递讲究一收一发，一发一收。若收到信息，应给客户端一个回复。这里要注意的是信息的传递是以字节的形式。a.send(date)
7. 若收到空值，最后一步是断开连接。a.close()

##### 客户端

1. 创建套接字，即实例化生成客户端套接字。client = socket.socket()
2. 向服务端发送连接请求，连接成功后，原本的客户端套接字实际上就变成了对等连接套接字。代码中的ip和端口是服务端的ip和端口。client.connect(('127.0.0.5',8520))
3. 向服务端发送信息。client.send(mess)
4. 向服务端接收信息，这里会发生一次阻塞。client.recv(1024)
5. 主动断开与服务端的连接，这时客户端会自动向服务端发送一个空值。client.close()

```
全连接队列：又称 Accept 队列（底层结构：双向链表，先进先出），包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。如果 accept 阻塞不被调用，那么很快全连接就可以被占满，此时再来客户端连接将超时，server 会舍弃 client 发送过来的 SYN，客户端一直重试，最终超时断开。(同时，客户端可以发数据，全连接队列里的socket不会ack，会因为重传导致网络抖动)

半连接队列：又称 SNY 队列（底层结构：Hash表，易于查找），服务端收到客户端的 SYN 包，回复 SYN+ACK 但是还没有收到客户端 ACK 情况下，会将连接信息放入半连接队列。
```

#### 5、进程间通信

    1、进程间通信支持进程之间的通信，Linux支持进程间的多种通信机制，包含信号量、共享内存、消息队列、管道、UNIX域套接字等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。
    2、在实际的Linux应用中，人们更多地趋向于使用UNIX域套接字，而不是System V IPC中的消息队列等机制。Android内核则新增了Binder进程间通信方式。
### 二、Linux系统

#### 系统调用与普通函数调用的区别

```markdown
系统调用（fprint等等）：
    1.使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备
    2.依赖于内核，不保证移植性
    3.在用户空间和内核上下文环境间切换，开销较大
普通函数调用（c标准库prinf）：
    1.使用CALL和RET指令，调用时没有堆栈切换
    2.平台移植性好
    3.属于过程调用，调用开销较小
## RET和IRET
- RET指令应安排在子程序的出口，即子程序的最后一条指令处，它的功能是从堆栈顶部弹出由CALL指令压入的断点地址值IP或CS、IP，迫使CPU返回到调用程序的断点去继续执行。
- IRET指令总是安排在中断服务程序的出口处，由它控制从堆栈中弹出程序断点送回CS和IP中，弹出标志寄存器内容送回F中，迫使CPU返回到断点继续执行后续程序。
```
#### linux的启动

（一个嵌入式Linux系统从软件角度看可以分为四个部分：引导加载程序（Bootloader），Linux内核，文件系统，应用程序。）启动顺序：bootloader->linux kernel->rootfile（app）

- Bootloader全名为启动引导程序，是第一段代码，它主要用来初始化处理器及外设，

- 用Linux内核，Linux内核在完成系统的初始化之后需要挂载某个文件系统作为根文件系统（RootFilesystem）

- 加载必要的内核模块，启动应用程序。

#### C程序运行的完整过程

```markdown
预处理（Pre-Processing）：gcc -E hello.c -o hello.i
    主要工作是删除程序中所有的注释、处理以# 开头的命令，如：头文件的展开、宏定义的替换。

编译（Compiling）：gcc -S hello.i -o hello.s
    gcc在编译阶段会对预处理后的代码进行各种检查(词法分析、语法分析、语义分析),来判断我们代码是否符合规范，如果通过就会生成汇编代码(以.s结尾的文件)
    注意：gcc -S 不是只能编译经过预处理后的.i文件，它的涵义是控制GCC 编译器仅对指定文件处理至编译阶段。
    如果需要编译的文件是 .c 或者 .cpp 源文件，则 GCC 编译器会对其进行预处理和编译(两步)。

汇编（Assembling）：gcc -c hello.s -o hello.o
    把 .s 文件翻译成二进制.o文件(目标文件)
    注意：gcc -c 不是只能编处理.s文件，它的涵义是控制GCC 编译器仅对指定文件处理至汇编阶段

链接（Linking）：gcc hello.o -o hello
    汇编阶段将代码编译成了二进制文件，还需要和系统其他组件（比如标准库、动态链接库等）结合起来才能正常运行，比如调用print函数打印，在预处理阶段也只是将“stdio.h”头文件中的申明引入进来，没有函数的实现，链接之前的操作都是对一个文件进行处理，而链接可以看作是对多个文件进行“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。
    其链接过程又涉及到动态库、静态库的链接，动态链接设置PATH，LIBPATH等环境变量来指定外部库文件
```
**动态链接和静态链接**：静态链接和动态链接的主要区别在于程序运行时是否依赖于外部库文件，静态链接将外部库文件嵌入到可执行文件中，使得程序运行时不依赖于外部库文件；而动态链接将外部库文件放在一个单独的目录下，使得程序在运行时需要依赖于外部库文件。

静态链接可以减少程序的依赖性和安全性问题，缺点是程序体积较大；动态链接的优点是程序体积较小，便于升级和维护；缺点是程序运行时需要依赖于外部库文件，可能会导致安全性问题和兼容性问题。

#### 大端序和小端序：

- 大端存储：高字节存储在低地址中，即高位先存;
- 小端存储：低字节存储在高地址中，即低位先存。

> **“高大低小”。“高”是指高字节，“大”是指大端序，“低”是指低字节，“小”是指小端序，“高大低小”也即先存高字节为大端序，先存低字节为小端序。**

1. IP协议中定义网络序固定采用大端模式，所以在大端设备中主机序和网络序是相同不需要转换
2. 当涉及一个Byte的变量存储时是不区分大小端序的

```markdown
## 小端序优点：
    内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（int64 -> int32）。
    CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，运算方式更高效。
    末位在所表示的数据的内存的第一个字节中，便于快速判断数据的奇偶性。
## 大端序优点：
    符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小。
```

#### 程序运行内存分配

堆向上涨，栈往下涨，这样设计可以使得堆和栈能够充分利用空闲的地址空间。（如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，无法确定）

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/89c48b6ccf8a49808f34986f8014770c.png)

**堆和栈**

```markdown
空间管理方式不同：
    1.栈上的空间由系统分配并管理、不需要我们关心申请与释放
    2.堆上的空间是我们自己申请并负责释放、如果忘记释放会造成内存泄漏、多次释放也会导致越界访问、非法操作、甚至导致程序崩溃问题等，这是需要我们程序员自己注意的地方

内存分配方向不同
    1.栈上的空间是从高地址向低地址分配
    2.堆上的空间是从低地址向高地址分配

分配效率不同
    1.栈是由系统分配管理，更加贴合系统底层、效率更高
    2.堆的申请和释放是由库函数支持，由我们自己手动调用库函数进行申请内存和释放内存，且容易产生内存碎片的问题，效率低于栈

存放内容不同
    1.栈主要存放局部变量、函数返回值、函数参数、函数地址等、程序运行过程中的函数调用就是栈来完成的、函数调用逐个入栈、调用完成之后逐个弹出
    2.堆主要为我们动态申请空间服务，为我们开辟空间
```

**全局区/静态存储区**：这里主要存放 全局变量和 静态变量、生命周期覆盖整个程序、直到程序结束，生命周期结束

**常量区**：

```cpp
string str1 = "helloworld";
int n = 6;
```

**代码区：**存放代码、不允许被修改， 代码区中的东西是随整个程序一起的，启动时 生、结束时 亡
 还有的平台const类型的常量，还有字符串常量会存放在这里。

#### 内存泄漏、内存溢出、内存越界

**内存泄漏**：是指堆内存的泄漏。堆内存是指程序从堆中分配的，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用。
**内存溢出：**你要求分配的内存超出了系统能力，系统不能满足需求，于是产生溢出，篡改了别的变量（strcpy函数）
**内存越界：**向系统申请了一块内存，而在使用内存时，超出了申请的范围（常见的有使用特定大小数组时发生内存越界）

```
内存溢出通常与总体的内存使用量有关，而内存越界是关于非法访问内存地址的问题。内存溢出是资源管理问题，而内存越界则与程序安全密切相关。
```

#### 硬链接和软链接

硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode，软链接则是创建指向目录/文件的符号链接，使用更广泛

- 硬链接不可以跨分区，软件链可以跨分区。
- 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。
- 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。

#### CPU 负载和 CPU 利用率

- CPU负载（Load Average）：他代表的是**当前系统正在运行的和处于等待运行的进程数之和**。

- CPU 利用率：和负载不同，CPU利用率指的是当前**正在运行**的进程实时占用CPU的百分比，它是对一段时间内CPU使用状况的统计。

CPU 负载很高，利用率却很低，说明处于等待状态的任务很多，负载越高，代表可能很多僵死的进程。通常这种情况是IO密集型的任务，大量请求在请求相同的IO，导致任务队列堆积。

CPU 负载很低，利用率却很高，这表示 CPU 的任务并不多，但是任务执行的时间很长，通常是计算密集型任务，生成了大量耗时短的计算任务。

#### IO多路复用：Select、poll和epoll

介绍：IO多路复用是一种同步的I/0模型，允许单个线程或进程同时监测和处理多个I/0事件。
这种技术通过减少系统开销，无需创建和维护大量进程或线程，从而提高了系统的并发处理能力。当有I/0事件就绪时，这些方法能够通知应用程序进行相应的读写操作，如果没有I0事件就绪，线程或进程会阻塞，直到有事件发生。

```
select 最早被引入，因此它几乎在所有的平台上都得到支持,使用固定大小的位图来跟踪每个文件描述符的状态,每次调用时将整个数组复制到内核空间，再进行遍历比对，所以复制开销、性能都会收很大影响

poll只是使用链表保存文件描述符，因此没有了监视文件数量的限制，其他缺点依然存在

epoll 是 Linux 特有的，不像 select 和 poll 那样广泛支持。epoll 使用内核中的事件表，应用程序只需向这个事件表注册一次感兴趣的事件，之后只有状态发生变化的文件描述符会触发通知，这极大地减少了不必要的数据复制和遍历开销。
```

select和poll的机制

服务器进程每次都把n个连接告诉操作系统（从用户态复制句柄数据结构到内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据拷贝到用户空间，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此select/poll一般只能处理几千的并发连接

| .            | select                                                       | poll                                                         | epoll                                                        |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 底层数据结构 | 数组（1024）                                                 | 链表                                                         | 红黑树 + 双链表                                              |
| 数据拷贝     | 每次调用都需要将fd数据从用户空间拷贝至内核空间               | 每次调用都需要将fd数据从用户空间拷贝至内核空间               | 使用内存映射(mmap),不需要从用户空间频繁拷贝fd数据至内和空间，降低拷贝的资源消耗 |
| 事件集合     | 通过3个参数分别传入感兴趣的可读、可写、异常等事件。内核通过对这些参数的在线修改来反馈其中的就绪事件，这使得用户每次调用select都要重置这3个参数 | 统一处理所有事件类型，因此只需要一个事件集参数。用户通过polfd.events传入感兴趣的事件，内核通过修改plfd.revents参数反馈其中就绪的事件 | 内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll _wait时， 无需反复传入用户感兴趣的事件。epoll _wait系统调用的参数events仅用来反馈就绪的事件 |

select和poll的缺点

1. 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024），但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差
2. 内核和用户空间之间的内存拷贝问题，因为我们每次调用select和poll时。都会填写相应的位数组和其他的参数，select和poll需要复制大量的句柄数据结构到内核空间进行监听，监听完成后需要把发生事件句柄再拷贝到用户空间，会产生巨大的开销
3. select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件。poll和select一样，都是轮询
4. select和poll的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select和poll调用还是会将这些文件描述符通知进程。**同一个事件，数据没有读完，会多次触发，效率低**

epoll3个部分：

- 调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）

- 调用epoll_ctl向epoll对象中添加这100万个连接的套接字，以红黑树的形式组织，增删查是 O ( l o g 2 n ) O(log_2n) O(log2n)

- 调用epoll_wait收集发生的事件的fd资源，发生事件的fd会从红黑树上拷贝到双向链表，用于返回给用户。用户拿到的就只有发生事件的文件描述符了

  ![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/d814c2bec9af4c26b232c7093b1f5a13.png)

#### 磁盘快照

- 全量快照：镜像分离 (Split Mirror)
  1. **建立镜像**：首先，存储系统创建一个数据卷的精确副本，这个副本可以是同一个阵列内的另一组盘上的数据，或者是远程站点的存储设备上的数据。这个过程涉及将所有数据从原始卷复制到镜像卷。
  2. **正常操作**：在镜像建立之后，所有的写入操作都同时应用于原始卷和镜像卷，保持它们之间的数据一致性。
  3. **分离镜像**：当需要创建快照时，将镜像卷与原始卷分离。分离后，镜像卷就变成了一个时间点的数据快照，而原始卷则继续正常工作并处理新的写入请求。
  4. **增量更新**：在分离出的镜像卷上可以执行备份操作或其他维护任务，而不影响原始卷的性能。之后，还可以重新同步镜像卷和原始卷，只同步它们之间差异的部分，然后再次分离以创建下一个增量快照。

- 增量快照

- - 写时拷贝 (Copy-On-Write)

    **更新源数据卷中的原始数据时, 将原始数据 Copy 到快照卷中**. 当我们需要恢复快照时, 只需要按照快照指针表逐一进行寻址就能够完成了. 而且 COW 在使用上非常的灵活, 可以随时为任意源数据卷建立快照。

    ![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-d0a90c5c91823fbdf8f77c4f3c7a47c4_1440w.webp)

    ```
    优点：COW 在进行快照操作之前, 不会占用任何的存储资源, 也不会影响系统性能. 
    
    缺点：每次写入都需要先将源数据卷中的原始数据拷贝到快照卷中才能开始写入源数据卷, 会降低源数据卷的写性能.
    ```

  - 写时重定向 (Redirect-On-Write)

    写操作 并不会像 COW 似得直接修改源数据卷原始数据, 而是再开辟一个新的空间用于存放用于更新原始数据的新的数据，将写操作重定向到该位置

    而读操作是否需要读重定向, 则根据读取数据的位置是否有过自上次快照以来的写重定向, 必须对有过写重定向的位置进行读重定向, 反之就不需要了.

    所以由此至终, 快照卷的数据指针表和其对应的数据是没有被改变过的. 恢复快照的时候, 只需要按照快照卷数据指针表来进行寻址就可以完成恢复了.

    ![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-2e22d722c7c25f4f1307bff4bed44578_1440w.webp)

    ```
    优点：不会降低源数据卷的写性能.
    
    缺点：没有一个完整的快照卷
    ROW 的快照卷数据指针表保存的是源数据卷的原始副本, 而源数据卷数据指针表保存的则是更新后的副本, 这导致在删除快照卷之前需要将快照卷数据指针表指向的数据同步至源数据卷中. 而且当创建了多个快照后, 会产生一个快照链, 使原始数据的访问、快照卷和源数据卷数据的追踪以及快照的删除将变得异常复杂.
    ```

    

### 三、Linux使用

#### Linux目录

| 目录               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| /home              | 家目录，新增用户时，放在此目录下                             |
| /root              | 系统管理员root的家目录                                       |
| /bin    /usr/bin /sbin | 普通可执行二进制文件的目录                                                                                                                        超级用户的可执行文件目录 |
| /etc               | 系统配置文件的存放目录                                       |
| /media             | 光盘挂载点                                                   |
| /tmp               | 一般用户或正在执行的程序临时存放文件的目录                   |
| /var               | 存放不断扩充的东西，经常被修改的目录存放在此，包括日志文件   |
| /proc              | 位于内存中的伪文件系统，存放一些【运行时】的信息，如 CPU 信息、负载信息、系统内存信息、磁盘 IO 信息 |
| /dev              | device 系统硬件设备目录（linux系统所有的硬件都通过文件表示） |

| /usr  | 用于存放系统应用程序                                         |
| ----- | ------------------------------------------------------------ |
| /opt  | 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里 |
| /boot | 存放用于系统引导时使用的各种文件                             |
| /lib  | 存放着和系统运行相关的库文件                                 |

#### Linux命令

```markdown
## 查看端口号占用
netstat -anp | grep 端口
    -a，显示所有
    -n，不用别名显示，只用数字显示
    -p，显示进程号和进程名

## 查看进程对应的端口号
先查看进程pid： ps -ef | grep 进程名 （process status -full全称 -e(a)所有）
通过pid查看占用端口 netstat -anp | grep 进程pid

## 修改权限
chmod [选项] 文件名
-r -w -x -777(读：4，写：2，执行：1)
    第1位为文件类型（-表示普通文件）
    第2-4位为用户权限（rw-：4+2=6）
    第5-7位为用户所属组权限（r--：4）
    第8-10位为其他用户权限（r-x：4+1=5）
## 列出进程
ps [选项]
-a列出终端上的所有进程
-e 显示所有进程。
-f 全格式
r 只显示正在运行的进程

## 删除进程
kill [选项]/[信号] 进程号
    -1 重新加载 
    -9 杀死进程
    -15 正常停止一个进程
## 查看测试项目的日志
tail [选项] 文件名
    -f 实时读取
    -1000 查看最近1000行

## 查看信息
    top：显示系统整体资源使用情况
    vmstat：监控内存和CPU
    iostat：监控IO使用
    netstat：监控网络使用
## 查找
    find语法：find dirName -option fileName
    当前目录及其子目录下查找.java结尾的文件：find . -name "*.java"
    在/user目录下查找：find /user -name ".java"

## 防火墙操作
    暂时关闭防火墙：systemctl stop firewalld
    永久关闭防火墙：systemctl disable firewalld
    开启防火墙：systemctl start firewalld

    开放指定端口：firewall-cmd --zone=public --add-port=8080/tcp --permanent
    关闭指定端口：firewall-cmd --zone=public --remove-port=8080/tcp --permanent

    操作立即生效：systemctl status firewalld

## 修改权限
修改 /test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限：
    chmod u=rwx,g=rw,o=r aaa.txt 
    或者 chmod 764 aaa.txt

## 用户管理
    useradd 选项 用户名        #添加用户账号
    userdel 选项 用户名        #删除用户帐号
    passwd 用户名             #更改或创建用户的密码

## 用户组管理
    groupadd 选项 用户组    #增加一个新的用户组
    groupdel 用户组        #要删除一个已有的用户组
    groupmod 选项 用户组    #修改用户组的属性

## 文件
1. linux命令 怎么搜索系统中的大文件
find / -type f -size +100M
/ 表示从根目录开始搜索。
-type f 表示只搜索文件。
-size +100M 表示搜索大小超过100兆字节的文件。

2. linux命令 怎么查看log文件定位问题
`查看`
cat /path/to/logfile.log  查看整个日志文件
tail -f /path/to/logfile.log 查看最新的日志条目

more /path/to/logfile.log 分页查看
less /path/to/logfile.log 分页查看
`less与more相比，不会在启动时就加载全部、可以向前翻页、支持跳转特定行`

head -n 100 /path/to/logfile.log # 查看前100行
tail -n 100 /path/to/logfile.log # 查看后100行

`搜索`
grep 'error' /path/to/logfile.log 搜索特定内容
tail -f /path/to/logfile.log | grep 'error'
grep 'Mar 10 08:15' /path/to/logfile.log 通过时间戳搜索


3. linux命令 查看文件前100行，找出以text结尾的
head -n 100 filename | grep 'text$' `$` 是正则表达式中表示行结束的特殊字符
```

```markdown
## linux统计一个文件中的某个单词数量
grep -o -w 'the' example.txt | wc -l
grep 是用于查找文件里符合条件的字符串的工具。
-o 选项告诉 grep 只输出匹配模式的部分，而不是整行内容。
-w 选项确保只匹配整个单词，而不是部分单词。例如，没有这个选项，单词 "there" 中的 "the" 也会被计算在内。
'the' 是你想要搜索的单词。
example.txt 是文件名。
| 是管道符号，它将前一个命令的输出作为后一个命令的输入。
wc 是一个文本处理工具，用来计算字数、行数等。
-l 选项告诉 wc 计算行数。

## 要将文本文件中所有的 "alibaba" 替换成 "aliyun"，
sed 's/alibaba/aliyun/g' file.txt > output.txt
s 是 substitute 的缩写，表示替换操作。
alibaba 是要被替换的旧字符串。
aliyun 是新字符串，它将替换旧字符串。
g 代表 global，意味着替换会发生在全部匹配的地方，而不只是每一行的第一个匹配。

sed -i 's/alibaba/aliyun/g' file.txt // 直接替换原文件
```

shell脚本：

1. **解析**：Shell 首先解析你输入的命令。这个过程包括分离命令、参数、重定向符号等，并检查是否有任何语法错误。
2. **命令搜索**：Shell 会在系统的 PATH 变量指定的目录中搜索匹配的程序来执行命令。PATH 是一个环境变量，包含了一系列的目录，这些目录是操作系统查找可执行文件的地方。
3. **创建进程**：如果找到了对应的程序，Shell 会为该程序创建一个新的进程。在 Unix-like 系统中，通常通过 `fork()` 系统调用来创建一个新的进程。
4. **执行命令**：创建进程后，Shell 通过 `exec()` 系统调用用所请求的程序替换新创建的进程的映像。也就是说，原来的 Shell 进程“变身”为要执行的命令。
5. **命令执行结束**：命令执行完成后，它会向 Shell 返回一个退出状态。Shell 可以根据这个退出状态来决定下一步的操作。
6. **返回控制权**：控制权返回给 Shell，等待用户的下一个命令。

```markdown
shell 脚本中特殊的参数变量：

$0 - 脚本名或者函数名
$1 - 第一个参数
$2 - 第二个参数
$N - 第 N 个参数（N 是一个大于 0 的整数）
其他与参数相关的特殊变量包括：

$# - 参数总数
$@ 或 $* - 所有的参数列表

当字符串中包含空格、制表符或者其他特殊字符时，需要使用引号
# 使用双引号
string="This is a string with spaces"
# 使用单引号也可以
string='This is a string with spaces'

```


## Http知识

### 一、HTTP协议

#### 协议字段

HTTP，HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。
1、HTTP协议特点

①基于TCP协议：面向连接，安全。
②基于请求-响应模型：一次请求对应一次响应。
③HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。

    缺点：多次请求间不能共享数据。Java中使用会话技术（Cookie、Session）来解决这个问题。

2、HTTP请求数据格式

请求数据分为3部分：
①请求行：请求数据的第一行。其中GET表示请求方式，/ 表示请求资源路径，HTTP/1.1表示协议版本。
②请求头：第二行开始，格式为key: value形式。
③请求体：POST请求的最后一部分，存放请求参数。（GET没有请求体）
                                                  ![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/152ca0028c2c42cd9b8b972606ca137d.png)

 3、HTTP响应数据格式

①响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述。
 ②响应头：第二行开始，格式为key: value形式。
 ③响应体：最后一部分。存放响应数据。

> | 状态码分类 | 说明                                                         |
> | ---------- | ------------------------------------------------------------ |
> | 1xx        | 响应中时状态码，表示目前是中间状态，还需后续的操作，如果它已经完成则忽路 |
> | 2xx        | 成功--表示请求已经被成功接收，处理已完成                     |
> | 3xx        | 重定向--重定向到其它地方:它让客户再发起一个请求以完成整个处理。 |
> | 4xx        | 客户端错误——如:客户端的请求一个不存在的密源，客户末被授权，禁止访问等 |
> | 5xx        | 服务端错误——如：网关错误                                     |

- 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。

- 202(已经接受请求，但处理尚未完成)，将来会通过不同的方式通知客户端：

  1. **轮询**：客户端定期发送请求来检查操作的状态。
  2. **Webhooks**：服务器在操作完成后，向客户端提供的URL发送通知。
  3. **WebSocket**：通过持久化的WebSocket连接实时发送结果给客户端。

- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分。

- 301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求。

- 302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求。

  ```
  HTTP 响应头有一个Location字段，当状态码是301或者302时，客户端会自动读取 Location中的新地址，自动重定向发送请求。
  ```

- 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

- 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

- 403 (禁止) 服务器拒绝请求。

- 404 (未找到) 服务器找不到请求的网页。

- 500 (服务器内部错误) 服务器遇到错误，无法完成请求。

- 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。

- 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

4、GET请求和POST请求区别

数据类型、位置、大小、方向，缓存、幂等性等方面

Post和Get的区别：
① post传递数据，不需要在url中显式出来， 参数在请求体中 ，而get方法需要在url中显式。
② post传输的 数据量大，可以达到2M ，而get传参受url长度限制， 最多传递1024字节 。
③   GET请求可以被缓存，因为GET请求是**幂等**的，即多次相同的GET请求对服务器的状态没有影响，可以使用缓存来提高性能。而POST请求不能被缓存，因为POST请求可能对服务器的状态产生影响，每次请求都需要重新向服务器获取最新的数据。
④ 某些情况（数据量很大）post在真正接受数据之前会 先将请求头发送给服务器进行确认，然后才真正发送数据 。
⑤ get不能传递中文，会乱码 ，而post不会出现乱码问题。

#### http长连接

HTTP1.0需要使用Connection: Keep-Alive保持连接，在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 "Connection: close" 才关闭。

> HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。

> HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，**Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的**，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。

> 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1.  判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length  ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked  块，表明本次传输数据结束。

```markdown
## HTTP长连接在什么时候会超时？

HTTP一般会有httpd守护进程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。
TCP 的keep-alive包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了tcp_keepalive_time，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了tcp_keepalive_probes，就会丢弃该连接。

## HTTP的Keep Alive 和 tcp的 Keep Alive区别
层次：HTTP Keep-Alive工作在应用层（HTTP协议），而TCP Keep-Alive工作在传输层。
目的：HTTP Keep-Alive的目的是减少建立和关闭连接的频率，提高效率。TCP Keep-Alive的目的是检测和清除无效的连接。
实现：HTTP Keep-Alive是通过HTTP头部字段控制的，而TCP Keep-Alive是通过底层TCP/IP协议栈的定时器实现的。
可选性：HTTP Keep-Alive在HTTP/1.1中默认开启，而TCP Keep-Alive通常是默认关闭的，需要系统配置来启用。
```

#### HTTP各个版本的区别？

##### HTTP1.1相比HTTP1.0的进步：

1. ###### 持久连接（Persistent Connections）

- **HTTP/1.0** 默认非持久，每个 HTTP 请求/响应对后，建立的 TCP 连接会被关闭，下一个请求将重新建立新的连接。
- **HTTP/1.1** 引入了持久连接（也称为 Keep-Alive），默认情况下，在一个连接上可以发送、接收多个请求/响应，从而减少了由于频繁建立和关闭连接所产生的延迟和开销。

2. ###### 流水线处理（Pipelining）

- **HTTP/1.0** 不支持流水线处理；客户端必须等待服务器响应当前请求之后才能发送下一个请求。
- **HTTP/1.1** 支持请求的流水线处理，即客户端可以在等待前一个请求的响应时发送后续的请求。这有助于进一步减少延迟。

3. ###### 分块传输编码（Chunked Transfer Encoding）

- **HTTP/1.0** 中，数据必须在发送之前完全准备好，因为需要在 HTTP 头部中发送 `Content-Length` 头来定义响应体的长度。

- **HTTP/1.1** 引入了分块传输编码，允许数据以一系列分块的形式发送。这样，服务器可以开始传输动态生成的内容而无需事先知道总大小。

  ```
  每个数据块都以其大小开始（以十六进制表示），紧跟着是数据本身，然后是一个CRLF（回车换行）。当所有数据都被发送后，服务器发送一个长度为零的块，表示消息结束。
  ```

##### HTTP2.0相比HTTP1.1支持的特性：

- **新的二进制格式**：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。

- **多路复用**：在一个连接里，允许同时发送多个请求或响应，**并且这些请求或响应能够并行的传输而不被阻塞**，避免 HTTP1.1 出现的”队头堵塞”问题。

  ```markdown
  实现原理
  ## 1. 二进制帧：
  在 HTTP/1.x 中，我们以文本格式传输数据，例如标头以纯文本形式表示，而且每个请求或响应都必须被整体发送。
  HTTP/2 引入了二进制协议，所有通信都是通过更小、更易于管理的消息单元——称为帧——进行的。这些帧可以交错发送，然后在另一端重新组装。
  ## 2. 流：
  每个请求或响应都被分解成多个帧，并在一个虚拟通道上发送，这个虚拟通道称为流。
  每个流都有一个唯一的标识符和优先级信息，这使得多个请求/响应能够同时在同一TCP连接上并行传输。
  ```

  与quic多路复用的区别？

  ```
  HTTP/2将通信分解为小的消息单元，称为帧。请求和响应都被分割成多个帧，在同一个TCP连接上交错发送。果一个TCP数据包丢失，整个TCP流需要等待该数据包的重传才能继续处理其他数据。
  QUIC某个流中的一个数据包丢失，这不会影响到同一连接上的其他流。
  ```

  到底解没解决队头阻塞？

  ```markdown
  ## 解了，没完全解
  `应用层面的阻塞：`一个HTTP请求可能阻塞后续的请求，即使后续的请求已经准备好发送，通过将请求和响应分割成独立的帧，这些帧可以交错发送并接收，从而在很大程度上解决了队头阻塞问题。
  
  `TCP层面的阻塞：`尽管HTTP/2试图在应用层克服队头阻塞，但它仍然无法完全消除TCP传输层可能出现的队头阻塞。例如，在丢包的情况下，TCP需要按照原始的顺序确认包，这可能导致HTTP/2流等待重传的数据包。
  ```

- **头部压缩**，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，**使用特定算法压缩头帧**，有效减少头信息大小。并且HTTP2.0**在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。**比如请求a发送了所有的头信息字段，请求b则**只需要发送差异数据**，这样可以减少冗余数据，降低开销。

#### 缓存

##### 请求头部字段：

- `If-Modified-Since`: 客户端在请求中包含这个字段，值为上次获取资源时的 `Last-Modified` 值。如果服务器上的资源自那时未被修改，则服务器返回一个 304 Not Modified 状态而不发送完整的响应体。
- `If-None-Match`: 类似于 `If-Modified-Since`，但使用的是资源的 ETag (实体标签) 而不是时间戳。客户端发送它所拥有的最后一个 ETag 的值，如果该值与服务器上资源的当前 ETag 匹配，意味着内容没有变化，服务器将返回一个 304 Not Modified 状态。

##### 响应头部字段：

- `Last-Modified`: 服务器以此头部字段告诉客户端资源最后一次被修改的时间。它通常用于 `If-Modified-Since` 请求头的基础比较。

- `ETag`: 服务器生成的资源的唯一标识符，通常是一个散列或某种形式的版本号。它用于更准确地确定资源是否已经更改，通常用于 `If-None-Match` 请求头的基础比较。

- Expires，HTTP/1.0 特性，它提供了一个日期/时间，告诉浏览器该资源的过期时间。

  ```http
  Expires: Wed, 21 Oct 2020 07:28:00 GMT
  ```

- `Cache-Control`: HTTP/1.1 特性,通过多个指令控制资源的缓存行为

  - `max-age=<seconds>` 指令表示自资源下载后多少秒内资源是新鲜的，这段时间内无需重新请求。
  - public ：可以被任何缓存区缓存，包括客户端、代理服务器等
  - private :指定响应只能被单个用户缓存，不能被共享缓存处理。这通常用于包含个人信息的页面，告诉代理服务器不要缓存这些响应。只有初始请求的客户端才能缓存内容。
  - no-cache : 并不是说不能缓存内容，而是告诉缓存必须向原始服务器验证缓存的响应是否仍然有效（新鲜），然后才能使用这个缓存的响应。
  - no-store : 完全禁止缓存。这意味着每次请求都必须向服务器重新获取资源，并且在本地不应存储任何副本。

##### 缓存验证结果头部字段：

- `304 Not Modified`: 这并非一个 HTTP 头部字段，而是一个状态代码。当使用 `If-Modified-Since` 或 `If-None-Match` 头部字段，并且服务器确定资源未被修改时，就会返回这个状态码。这样，客户端可以安全地使用本地缓存的版本，而无需重新下载资源。

#### 跨站攻击

CSRF（Cross-site request forgery，跨站请求伪造）伪造请求，冒充用户在站内的正常操作，比如爬虫。

##### 防范的方法

- 关键操作只接受POST请求
- 验证码
- 检测 Referer
- Token
  - Token 要足够随机——只有这样才算不可预测
  - Token 是一次性的，即每次请求成功后要更新Token——这样可以增加攻击难度，增加预测难度
  - Token 要注意保密性——敏感操作使用 post，防止 Token 出现在 URL 中

#### 断点续传

要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。

HTTP1.1协议中定义了断点续传相关的HTTP头 `Range` 和 `Content-Range` 字段，一个最简单的断点续传实现大概如下：

1. 客户端下载一个1024K的文件，已经下载了其中512K
2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：`Range:bytes=512000-`，这个头通知服务端从文件的512K位置开始传输文件。
3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：`Content-Range:bytes 512000-/1024000`，并且此时服务端返回的HTTP状态码应该是`206`，而不是200。

- 但是在实际场景中，我们需要有一个标识文件唯一性的方法。在RFC2616中也有相应的定义，比如 **实现Last-Modified来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动**。同时RFC2616中还定义有一个ETag的头，可以使用ETag头来放置文件的唯一标识，比如文件的MD5值。

#### Request ID

在分布式系统中统一request id，记录请求如何进入系统、经过哪些服务、每个服务处理耗时等

**日志追踪与关联：**Request  ID可以作为一条线索，将同一个请求生命周期内产生的所有相关日志条目关联起来，即使一个请求跨越了多个服务或微服务，可以迅速定位和收集到与该请求相关的所有日志，便于故障排查和性能分析。

**跨系统协调**：当请求在不同系统间传递时，携带Request ID可以在各系统间保持请求的上下文一致性，有助于在分布式事务或跨系统调用链路中进行协调和监控。

### 二、HTTP 请求跨域问题

#### 跨域的原理

**跨域**，同源策略限制了通过脚本访问不同源的文档、Cookie、LocalStorage 等资源。当一个网页尝试在脚本中请求另一个不同域的资源时，浏览器会阻止这个请求，以保护用户的隐私和防范潜在的安全威胁。它是由浏览器的`同源策略`造成的。

注意⚠️，浏览器在跨域的情况下，请求都会发送出去，响应是否被前端 JavaScript 代码接收和处理，取决于服务器的响应头部（Access-Control-Allow-Origin），跨域机制主要是阻止数据的跨域获取，不是阻止请求的发送。

 **同源策略**,用于限制一个Origin的文档或者它加载的脚本如何能与另一个源的资源进行交互，只要`协议、域名、端口`有任何一个不同，都被当作是不同的域。
 **跨域原理**，即是通过各种方式，`避开浏览器的安全限制`。

#### 为什么需要跨域

假设 Alice 访问了一个银行网站 `https://www.alice-bank.com` 并登录了她的账户。这时，她的浏览器上会存储用于身份认证的 cookies。如果没有同源策略，Alice 在不小心访问了一个恶意网站 `https://www.hacker-site.com` 时，该恶意网站可以轻易地使用 JavaScript 发出对 `https://www.alice-bank.com` 的请求，并尝试获取她的敏感信息。

```javascript
// 从恶意网站发起对 Alice 银行的请求
fetch('https://www.alice-bank.com/account-details', {
  method: 'GET',
  credentials: 'include' // 尝试携带 cookie
})
.then(response => response.json())
.then(data => {
  // 恶意网站尝试获取响应数据, 浏览器会遵循同源策略, 阻止这一行为
  console.log(data);
  // 如果成功，接下来可能将这些信息发送到黑客的服务器
});
```

#### 不受影响的资源

<img>，<script>，<video>，<iframe>,`<link>`

#### 解决方案

**CORS** (Cross-origin resource sharing)跨域资源共享 设置 CORS 是最直接的方法。该方法无需前端操作，只需后端在返回响应时设置响应头即可，指定允许访问的域名"http://web.domain.com"，或者使用通配符 `*` ，表示所有网站都可以访问资源。（适用于那些提供公共 API 或资源且不涉及敏感数据的情况）

**Nginx反向代理** 目前常用方式,通过服务器设置代理，由于同源策略仅存在于浏览器之间，服务器之间的交互不需要遵循同源策略。

所以我们这里可以使用 Nginx 作为 Web 服务器，监听并接收来自外部（其他服务器）请求，将接收到的请求使用和本机相同的域名转发到后端，然后再将响应转发给前端。

**使用Websocket**：HTML5 定义了 Websocket 协议，该协议主要用于服务器和浏览器之间的持久化连接，并且没有同源策略的限制。该方法需要后端提供 Websocket 接口，前端进行接收。

### 三、Session和Cookie

#### 1.Cookie

cookie是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081)计算机暂时或永久保存的信息（一般是浏览器），按其存储位置可分为：内存式Cookie（不持久）和硬盘式Cookie（持久）。

Cookie定义了一些HTTP请求头和HTTP响应头，通过这些HTTP头信息使服务器可以与客户进行状态交互。

客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等较验。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70.png)

##### Cookie的有效期：

- 如果maxAge属性为正数：则表示该Cookie会在maxAge秒之后自动失效。浏览器会将maxAge为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie仍然有效。
- 如果maxAge为负数：则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中。
- 如果maxAge为0：则表示删除该Cookie。

##### 修改和删除Cookie：

- Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。

- 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。

##### 设置域名：

Cookie是不可跨域名的。www.helloweenvsfei.com和images.helloweenvsfei.com也不能交互使用Cookie，想所有helloweenvsfei.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数，例如：

##### 设置Cookie的路径：

domain属性决定运行访问Cookie的域名，而path属性决定允许访问Cookie的路径（ContextPath）。

```
Cookie cookie = new Cookie("time","20080808"); // 新建Cookie
cookie.setDomain(".helloweenvsfei.com");       // 设置域名
cookie.setPath("/");                           // 设置路径
cookie.setMaxAge(Integer.MAX_VALUE);           // 设置有效期
response.addCookie(cookie);                    // 输出到客户端

response.addCookie(cookie);  
```

#### 2.Session

Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20240104114517622.png)

Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session，因此，Session里的信息应该尽量精简。

Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。

Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。

##### Session的销毁方式

- 默认情况下，无操作，30分钟自动销毁。
- 调用Session对象的invalidate()方法。

##### 服务器重启后，Session中的数据是否还在?

 **钝化：** 在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。
 **活化：** 再次启动服务器后，从文件中加载数据到Session中。

#### 3.区别

- 存储位置：Cookie是将数据存储在客户端，Session 将数据存储在服务端。
  安全性：Cookie 不安全，Session安全。
  数据大小：Cookie最大3KB，Session无大小限制。
  存储时间：Cookie可以长期存储，Session 默认30分钟。
  服务器性能：Cookie不占服务器资源，Session占用服务器资源。

  可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。

#### 4.Cookie、sessionStorage、localStorage

**相同点**：

- 存储在客户端，sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问，sessionStorage不能跨页面共享，但只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。
- localstorage持久化存储，跨站不能访问。
- 两者存储方式为String类型、存储数据大小一般都是：5MB

```javascript
var storage=window.localStorage;
var storage=window.sessionStorage;

setItem (key, value) // 保存数据，以键值对的方式储存信息。
getItem (key) // 获取数据，将键值传入，即可获取到对应的value值；
removeItem (key) // 删除单个数据，根据键值移除对应的信息。
clear () // 删除所有的数据；
key (index) // 获取某个索引的key

//cookie
response.setHeader(Set-Cookie,usernamejohn ); //添加
var username = document.cookie.replace(/(?:?:^.*,s*)usernames*=s*(^;*).*$)^.*$/,'$1' ) //获取
response.setHeader(Set-Cookie, "username=, expires=Thu, 01 Jan 1970 00:00:00 UTC") //删除
```

**不同点**：

- cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
- cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
- cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地
- localStorage在浏览器的隐私模式下面是不可读取的

```markdown
## 应用场景：
localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；
有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；
```



### 四、Https协议

#### http 和 https 的区别及优缺点？

- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议`安全`，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
- http 协议的`默认端口`为 80，https 的默认端口为 443。
- http 的连接很简单，是无状态的。https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https `缓存`不如 http 高效，会增加数据开销。
- Https 协议需要 ca 证书，费用较高，功能越强大的`证书费`用越高。

### https 协议的工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：

-    1）客户端向服务端发起建立HTTPS请求。

```markdown
      a.  客户端生成随机数R1 发送给服务端
      b.  告诉服务端自己支持哪些加密算法和哈希算法
```

-    2）服务器向客户端发送数字证书。

```markdown
      a.  服务端生成随机数R2
      b.  从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）和哈希算法用机构的证书公钥解密得到证书的内容和证书签名
      c.  服务端生成把证书、随机数R2、会话密钥生成算法，一同发给客户端
```



-    3）客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。

```markdown
  		 a.  首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥、会话密钥生成算法、随机数R2。
       b.  用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。
       c.  浏览器生成一个随机数 R3，根据会话密钥算法使用R1、R2、R3生成会话密钥。

       d.  用服务端证书的公钥加密随机数R3并发送给服务端。
```

-    4）服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。

```markdown
      a.  服务器用私钥解密客户端发过来的随机数R3
      b.  根据会话密钥算法使用R1、R2、R3生成会话密钥
```

-    5）客户端与服务端开始进行加密会话。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/1062096-20210911221113316-1433252826.png)

#### 证书原理

- 服务器得去公证人这里先登记，把自己的公钥、名字等等信息报上去，公证人拿到这些信息后，计算一个Hash值，然后再用公证人的**私钥**把Hash值进行加密，加密后的结果就是**数字签名**。
- 公证人把登记的信息和这个数字签名合在一起，封装了一个新的文件发给服务器，登记就完成了，而这个新的文件就是**数字证书**。然后发给服务器，通信的时候须要将他们的证书发给浏览器验证。
- 浏览器拿到证书后，把证书里面的信息也计算一遍Hash，再用**提前记录好的公证人的公钥**把证书里的数字签名进行解密，得到公证人计算的Hash，两个一对比，就知道这证书是不是公证人签发的，以及有没有被篡改过了！



### 五、浏览器

#### 从输入URL到页面加载的全过程

- 首先在浏览器中输入URL
- 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。
  - 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
  - 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
  - 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
  - ISP缓存：若上述均失败，继续向ISP搜索。
- DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议。`。
- 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
- 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器
- 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
- 关闭TCP连接：通过四次挥手释放TCP连接
- 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
  - 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
  - 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
  - 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
  - 布局（Layout）：计算出每个节点在屏幕中的位置
  - 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

#### W3C标准

W3C是World Wide Web Consortium的缩写，它是一个国际组织，由网页开发者、浏览器厂商、软件开发者、研究机构和其他利益相关者组成。W3C的主要任务是制定和维护网页技术的标准，以确保网页的互操作性、可访问性、可用性和质量。

- 提高网页的兼容性，使其能够在不同的浏览器、设备和平台上正常显示和运行。
- 提高网页的可访问性，使其能够为不同的用户群体和需求提供合适的内容和交互方式。
- 提高网页的性能，使其能够更快地加载和响应用户操作。
- 提高网页的可维护性，使其能够更容易地修改和更新。

#### 请求转发

请求转发（forward）：一种在 服务器内部的资源跳转方式。
实现方式req.getRequestDispatcher("资源B路径").forward(req,resp)；
请求转发资源间共享数据：使用Request对象 void setAttribute(String name,Object o)：存储数据到request域中。

##### 特点

① 浏览器地址栏路径不发生变化。
② 只能转发到当前服务器的内部资源。
③ 一次请求，可以在转发的资源间使用request共享数据。

##### 与重定向的区别

1. 请求转发只发出一次请求；**重定向**时浏览器发出了两次请求。
2. 请求转发浏览器上的地址不会改变；（302跳转）重定向浏览器上的地址会改变。
3. 请求转发的效率更高，重定向的效率低。
4. 请求转发可以使用request对象再多个页面间传递参数；重对象不可以。
5. 请求转发可能造成表单的重复提交；重定向不会，在表单处理时经常使用重定向解决表单重复提交问题。
6. 请求转发只能在服务器内部转发；重定向可以跳转到其他服务器进行转发。

#### 常用鉴权方式

##### HTTP Basic Authentication (HTTP基本认证)

##### session-cookie

```
1，服务器在接受客户端首次访问时在服务器端创建session，然后保存session(我们可以将session保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。
2.签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）
3.浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的请求头中会带上该域名下的cookie信息，
4.服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。
```

##### Token 验证(包括JWT,SSO)

最简单的token组成(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串.

- 2, 服务端收到请求，去验证用户名与密码
- 3, 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
- 4, 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
- 5, 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token

```markdown
## 优点
Token 可以避免 CSRF 攻击(也是因为不需要cookie了)
Token 可以是无状态的，可以在多个服务间共享(服务器也只是做了token的解密和用户数据的查询， 它不需要在服务端去保留用户的认证信息或者会话信息)
Token 支持手机端访问(Cookie不支持手机端访问)
## 缺点：
性能问题: 相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证.其实Token相比于session-cookie来说就是一个"时间换空间"的方案.
```

token与session的区别：

使用Token,服务端不需要保存状态，服务端是根据session_id，来查询在服务器端保持的session，这里面才保存着用户的登陆状态。但是token本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个token是否合法就行。

**Token不需要借助cookie的.** 我们知道http代理客户端不只有浏览器，还有原生APP等等，这个时候cookie是不起作用的，使用token时，客户端在收到响应的时候，可以把他存在本地的cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个token就行了。

时效性。session-cookie的sessionid实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而token是可以在一段时间内动态改变的。

可扩展性。token验证本身是比较灵活的，一是token的解决方案有许多，常用的是JWT,二来我们可以基于token验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。

##### OAuth(开放授权)

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/585623664ea44313a9ceb138425285be~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

- 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
- sso认证中心发现用户未登录，将用户引导至登录页面
- 用户输入用户名密码提交登录申请
- sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
- sso认证中心带着令牌跳转会最初的请求地址（系统1）
- 系统1拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统1
- 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
- 用户访问系统2的受保护资源
- 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
- sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
- 系统2拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统2
- 系统2使用该令牌创建与用户的局部会话，返回受保护资源

注销：

- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话销毁，局部会话必须销毁

- 用户向系统1发起注销请求
- 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求
- sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址
- sso认证中心向所有注册系统发起注销请求
- 各注册系统接收sso认证中心的注销请求，销毁局部会话
- sso认证中心引导用户至登录页面

##### OAuth 2.0

它允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有QQ,微信,微博等。

#### 浏览器缓存

##### 强制缓存

- **工作原理**：当一个用户访问一个页面时，强制缓存会检查请求的资源是否存在于浏览器缓存中，并且是否还有效（未过期）。如果是，浏览器将直接使用缓存中的副本，而不会发送任何请求到服务器。
- **控制方式**：通过HTTP头部`Cache-Control`的`max-age`指令或`Expires`头来设置资源的有效期限。
- **效果**：如果资源在缓存中且有效，加载速度非常快，因为没有网络延迟。
- **适用场景**：适合那些不经常变动或可以通过版本控制来管理更新的资源。

```markdown
不经常变化的资源：

- 静态文件：如 HTML、CSS 和 JavaScript 文件，在网站更新前通常不会变化。
- 图片和视频：媒体资源如图标、背景图片、图表等，这些内容很少更改。
```

##### 协商缓存

- **工作原理**：当资源已经存在于浏览器缓存中但是强制缓存规则表明它可能已过期时，浏览器会向服务器发送一个带有校验标记（如 `ETag` 或 `Last-Modified` 头部）的请求，询问资源是否已经被修改。
- **控制方式**：服务器通过`ETag`或`Last-Modified`响应头提供资源的最后修改时间或者唯一标识符。浏览器在后续请求中通过`If-None-Match`或`If-Modified-Since`头部发送这些值来进行校验。
- **效果**：如果服务器响应状态码为`304 Not Modified`，表示资源未更改，浏览器将使用缓存副本；如果资源有变动，服务器则会发送状态码`200 OK`和新的资源内容。
- **适用场景**：适合那些可能会变动但不频繁更新的资源，以及对实时性要求不高的内容。
## 数据库

#### SQL执行流程

**词法解析：**在词法解析阶段，解析器会将输入的SQL字符串（一串字符）分解成一系列有意义的单元，称为“词法单元”，每个词法单元都有一个特定的类别，如`SELECT`是一个关键字，`users`是一个标识符，`>`是一个运算符，`30`是一个常量。

**语法解析：**使用一组预定义的规则（通常以文法的形式存在）来检查词法单元的序列是否能构成合法的SQL语句结构。

**语义解析：**预处理器主要负责将解析阶段生成的语法树转换为更易于数据库优化器处理的形式，并进行初步的查询验证工作：

1. **验证（Validation）** 预处理器将检查SQL语句中引用的所有对象（如表格、列、视图等）是否存在，并验证用户是否有权限访问这些对象。这个步骤确保了查询的合法性。
2. **优化准备（Optimization Preparation）** 这个阶段涉及重写查询以提高效率，例如消除冗余的子查询、展开视图等。虽然**实际的查询优化通常发生在后续的查询优化阶段**，但预处理器设置了基础，使优化器能够高效地进行工作。
3. **解析树转换（Parse Tree Transformation）** 解析树可能会被转换成一个更加抽象的内部表示，称为查询树（query tree）或查询图（query graph）。这个结构更侧重于查询的逻辑含义而不是其原始语法形式。
4. **上下文相关检查（Contextual Checks）** 检查语句在当前的数据库环境上下文中是否有意义，例如，聚合函数是否处在正确的位置，或者GROUP BY和ORDER BY子句中的列是否存在。

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16.png)

1、在打开客户端后，最初需要和sql服务器建立连接，账号认证和校验权限。

2、认证后，客户端发生查询sql脚本给服务器

3、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。

4、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。

5、MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。

6、将结果返回给客户端。

#### 语句执行顺序：

```sql
SELECT DISTINCT player_id, player_name, count(*) as num #顺序5
FROM player JOIN team ON player.team_id = team.team_id #顺序1
WHERE height > 1.80 #顺序2
GROUP BY player.team_id #顺序3
HAVING num > 2 #顺序4
ORDER BY num DESC #顺序6
LIMIT 2 #顺序7
```

### 一、数据库基础

#### 三个范式[nf](https://blog.csdn.net/A_art_xiang/article/details/113880638)

##### 第一范式

原子性：列或者字段不能再分，要求属性具有原子性，不可再分解；

![1nf](https://img-blog.csdnimg.cn/20210220121125532.png)

##### 第二范式

2NF唯一性： 要求非主键字段的值必须完全依赖主键（不能部分依赖），表中，学分是依赖课程的，成绩是部分依赖联合主键（学生，课程）的。

![2nf](https://img-blog.csdnimg.cn/20210220122011873.png)

##### 第三范式

3NF 直接性：数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系。

![3nf](https://img-blog.csdnimg.cn/20210220122950155.png)

#### 主键、候选键、外键

主键的特性：

- 1.唯一性，不可重复

- 2.强制性，不可以为空

- 3.永久性，不可以改变

- 4.最小集合，不可以参杂多余的属性

  数据库自动为主键创建索引，从而加快查找和排序操作

候选键的特性：

候选键是一个或多个列的组合，可以唯一标识表中的每一行。如果一个或多个列满足唯一性和完整性，那么这些列就可以被视为候选键，表中可以有多个候选键，候选键可以为NULL。每个主键都可以是候选键，但反过来则不可能。

外键的特性：

外键是指一个表中的一个或多个字段，它们的值必须在另一个表中的某个字段中存在。这个被参照的表中的字段通常是主键（Primary Key），这样就可以通过外键将两个表关联起来。

外键的作用是保证数据的完整性和一致性，从而避免数据重复和冗余，也可以限制数据的删除和修改。

#### 完整性约束

数据库完整性约束是保证数据库中数据一致性和完整性的重要概念。它主要包括**实体完整性、参照完整性和用户定义的完整性**。实体完整性约束指表中必须有主键，且主键的值不能为空或重复；参照完整性约束指外键的值必须在被参照的表中找到或者为空；用户定义的完整性约束指对数据类型、格式、取值范围等进行约束。

### 二、数据库事务

在InnDB存储引擎中，事务的原子性、一致性、持久性都是通过redo和undo日志文件实现。 redo：重做日志。它记录了事务的执行过程，可以支持任何场景下的”重做“。 exp：当事务提交之后，通过异步刷新磁盘的方式持久化到磁盘中，如果事务提交之后，服务宕机了，可以通过redo日志进行恢复。

#### 1.事务特性

原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态

隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

#### 2.隔离级别

- (1) 读未提交（read Uncommited）:在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用。
- (2) 读已提交（read commited）:这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；会避免脏读问题；由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读的问题（可以在读时加锁解决）
- (3 ) 可重复读（Repeatable read）：这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。不可重复读是我们在一次事务中读到的数据数值不一致，而幻读则是读到了上一次查询根本不存在的行。
- (4) 串行化（serializable）：事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；

MySQL InnoDB中设置隔离级别方法：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL<隔离级别>;
其中，`<隔离级别〉`可以是 read uncommitted、readcommitted、repeatable read 或 serializable.
```

### 三、索引

#### 实现原理

索引的原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

- \1. 把创建了索引的列的内容进行排序
- \2. 对排序结果生成倒排表
- \3. 在倒排表内容上拼上数据地址链
- \4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

当你在某个字段上建立索引时，底层会创建B+树来存储该字段的值及其对应的行指针，索引数据被存储在数据库文件系统中的单独文件里，索引中的每个条目都包括一个指向实际数据行的指针（在InnoDB中称为主键ID）。如果索引是主键索引，那么它直接包含数据；如果是二级索引，那么它包含主键字段的值。

- **查询优化**：一旦索引被创建，MySQL的查询优化器会在解析查询时考虑使用索引来加速查找和排序操作。

#### 索引优点

索引存储在内存中，为服务器存储引擎为了快速找到记录的一种数据结构。索引的主要作用是加快数据查找速度，提高数据库的性能。

```markdown
## 优点：
创建唯一性索引，保证数据库表中每一行数据的唯一性
大大加快数据的检索速度，这也是创建索引的最主要的原因
加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

## 索引的分类（必会）
普通索引：最基本的索引，它没有任何限制。
唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用     primary key 来约束。
联合索引（又叫复合索引）：多个字段上建立的索引，能够加速复合查询条件的检索。
```
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVsb2lzZV95YW5neXVjaGFuZw==,size_13,color_FFFFFF,t_70,g_se,x_16.png)

#### 设计原则

- \1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列，对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
- \2. 基数较小的表，索引效果较差，没有必要在此列建立索引
- \3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间， 如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
- \4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进 行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
- \5. 定义有外键的数据列一定要建立索引（**限制并发性、影响性能**）。
- \6. 更新频繁字段不适合创建索引
- \8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- \9. 对于定义为text、image和bit的数据类型的列不要建立索引。

#### 优化设计

##### 索引下推

在读取完整的行数据之前，存储引擎可以先使用索引列的值来评估这些条件。如果条件不满足，那么该行就会被跳过，而不需要再去读取这一行的全部数据。这样可以减少 I/O 操作和提高查询效率。

```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,
    department VARCHAR(100),
    salary INT
);

CREATE INDEX idx_department_salary ON employees(department, salary);
SET SESSION optimizer_switch = 'index_condition_pushdown=on';  启用

SELECT * FROM employees WHERE department = 'Sales' AND salary > 50000;
```

使用索引 `idx_department_salary`，在没有索引下推的情况下，数据库将读取所有部门为 'Sales' 的行，然后检查这些行的 `salary` 字段是否满足大于 50000 的条件。

启用索引下推后，`优化器`会在索引层面首先判断 `salary` 是否大于 50000，如果不满足，直接跳过，而不会去读取整行的数据。这使得查询操作更加高效，特别是当满足条件的记录只占少数时。

```sql
在 EXPLAIN 输出结果中，如果看到 Extra 列包含了 Using index condition，则表示对该查询使用了索引下推。
```

##### 覆盖索引

覆盖索引是指一个索引包含了查询所需要的所有数据。换句话说，如果一个查询能够仅通过访问索引就可以得到所需的数据，而不必读取表中的数据行，那么这个索引就是覆盖索引。

1. **减少I/O操作**：由于索引通常比整张表小很多，因此查询可以更快地在索引中进行，而不需要进行额外的磁盘I/O来读取实际的数据行。
2. **提高查询性能**：当索引能够覆盖查询时，MySQL可以避免读取数据行，这样可以显著提高查询速度，尤其是对于大型数据表。
3. **缓存更高效**：索引条目通常比数据行更小，更多的索引值能够被缓存在内存中，这意味着更少的缓存页和更高的缓存命中率。

```sql
在 EXPLAIN 输出结果中，如果看到 Extra 列包含了 Using index condition，则表示对该查询使用了索引下推。
```

#### Mysql中的实现

Mysql的存储引擎(InnoDB,MyISAM)层中实现的：

B+Tree 索引: 最常见的索引类型, 大部分索引都支持B+树索引.

Hash 索引: 只有Memory引擎支持, 使用场景简单.

R-Tree索引(空间索引): 空间索引是MyISAM引擎的一个特殊索引类型, 主要地理空间数据, 使用也很少.

S-Full-text(全文索引): 全文索引也是MyISAM的一个特殊索引类型, 主要用于全文索引, InnoDB从Mysql5.6版本开始支持全文索引.

```sql
ALTER TABLE students
ADD INDEX idx_score (score);

ALTER TABLE students
ADD INDEX idx_name_score (name, score);

DROP INDEX index_name
ON table_name;

SELECT *
FROM user
WHERE username = 'Alice';
// 如果 user 表中有名为 idx_username 的索引，那么 MySQL 就会使用该索引来加速查询操作。
```

### 四、数据库锁

#### 行锁和表锁

1.主要是针对锁粒度划分的，一般分为：行锁、表锁、库锁

行锁：访问数据库的时候，锁定整个行数据，防止并发错误。

表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

页级锁：是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。

**行锁 和 表锁 的区别：**

 表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

 行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

#### 悲观锁和乐观锁

（1）悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

（2）乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

### 五、数据库设计

#### 关系型与非关系型数据库

1、数据存储方式不同

- 关系型数据天然就是表格式的，因此存储在数据表的行和列中，结构化存储。
- 非关系型数据通常存储在数据集中，就像文档、键值对、列存储、图结构。

 2、扩展方式不同

- 在基于web的结构中，关系型数据库是最难以横向拓展的，通常要优化机器性能。
- 非关系型数据存储天然就是分布式，NoSQL数据库是横向扩展的，给资源池添加更多普通的数据库服务器分担负载。

3、对事务性的支持不同

- 如果数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库是最佳选择。
- NoSQL数据库是最终一致性，一般不保证ACID的数据存储系统，具有极高的并发读写性能，价值是在操作的扩展性和大数据量处理方面。

```markdown
## 非关系型优点：
成本低：nosql数据库部署简单，基本都是开源软件
查询速度快：
存储数据的格式多：nosql的存储格式是key，value形式，文档形式，图片形式等，所以可以存储基础类型以及对象或者是集合的等多种形式，而关系型数据库只支持基础类型
高扩展性：
速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘
## 关系型优点：
丰富的完整性(实体完整性，参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率
```

#### 关系型数据库优化

A：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。

B：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间, 前提是这个列经常被用到, 这也就是反第三范式。

C：分割表。

数据表拆分：主要就是垂直拆分和水平拆分。

水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。

垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。

D: 字段设计

    表的字段尽可能用NOT NULL
    字段长度固定的表查询会更快
    把数据库的大表按时间或一些标志分成小表
### 六、数据库扩展

#### 垂直扩展

- 也称为纵向扩展，是通过向现有机器添加更多的性能（CPU、RAM、DISK等）来进行扩展。
- 单点故障的风险增加。
- 垂直扩展的总体成本较高。强大的服务器更加昂贵。

#### 水平扩展

也称为分片，是添加更多服务器的做法，将大型数据库分割成更小、更易管理的部分，称为分片。每个分片共享相同的模式，尽管每个分片上的实际数据是唯一的。

![image-20230517210216761](https://gitee.com/xu_zuyun/picgo/raw/master/img/60df5ceccfc849e7a5a3c23f5b909e30.png)

- **重新分片问题：**在选择分片键时，最重要的一个标准是选择一个能够均匀分布数据的键。某些分片可能由于不均匀的数据分布而更快地耗尽分片。当分片耗尽时，需要更新分片函数并移动数据。
- **热点键问题**：也称为明星问题。对特定分片的过度访问可能导致服务器超载。
- **连接和去规范化**：一旦数据库被分片到多个服务器上，执行跨数据库分片的连接操作就变得困难。一个常见的解决方法是对数据库进行去规范化，以便可以在单个表中执行查询。

### - 问题

##### 1、count(*)、count(1)、count(列)的区别？

- `COUNT(1)`: 此查询返回的是结果集中的行数，不关心具体的列内容，因此使用常数1。
   在很多数据库系统中，这种方式被优化为与 `SELECT COUNT(*)` 相同的性能水平，因为数据库引擎通常忽略括号内的内容。
- `COUNT(*)`：统计整个表的行数，不考虑是否有NULL值。
   通常优于 `COUNT(id)`，因为它不需要关心具体的列，且现代数据库引擎会对其进行特殊优化。
- `COUNT(列)` ：统计指定列非空值的数量。需要考虑是否有NULL值
   此种方式取决于列是否有索引。如果 列有索引，数据库引擎可能会利用索引进行快速计数。如果没有索引，或者有大量NULL值，性能可能较差，因为需要扫描整个表。

##### 2、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几?

　　一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是8；但是如果重启（文中提到的）MySQL的话，这条记录的ID是6。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是8。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

##### 3、char和varchar的区别？

- 最大长度： Char 类型是固定长度的，其最大长度通常为255个字符或10个字节（取决于操作系统）。 Varchar 类型则是可变长度的，其最大长度可以达到65535个字节。

- 存储效率： Char 类型的存储效率较高

- 空间使用： Char 会浪费一些空间

- Char 通常用于存储固定长度的数据，如身份证号码、电话号码等。 Varchar 更适合存储可变长度的数据，如用户名、地址等。

  ```
  空间填充：char如果存储的字符串长度小于定义的长度，MySQL 会使用空格来填充其余的位置，以保证数据长度始终是固定的。varchar需要额外的空间来存储字符串的实际长度(额外的1字节或两个字节)，这可能会导致轻微的性能开销。
  检索速度：由于长度固定，CHAR 类型的字段在某些情况下可以更快地被检索，因为存储系统知道每个记录的确切位置。
  ```

  ```markdown
  ## 注意：
  字符集影响：字符集也可能影响存储大小。比如，在 UTF-8 编码下，一个字符可能需要最多 3 或 4 个字节来存储。
  ```

##### 4、为什么最好用NOT NULL

1. **数据完整性**：强制字段必须有值可以确保数据库中的记录都是完整的，这对于分析和决策非常重要。它避免了数据出现不一致或含糊不清的情况。
2. **简化查询**：如果字段可以为 `NULL`，那么在编写查询（特别是复杂的查询）时就需要考虑 `NULL` 值的处理，这可能会使查询逻辑变得更加复杂。
3. **优化性能**：知道一个字段永远不会为 `NULL` 可以帮助数据库优化器选择更高效的执行计划。某些数据库系统在处理非空字段时会更加高效，因为它们可以省去检查 `NULL` 的步骤。
4. **索引效率**：有时候，标记为 `NOT NULL` 的字段可以更有效地被索引。例如，在某些数据库系统中，对于包含 `NULL` 值的字段，索引可能会不包括那些 `NULL` 记录，这可能导致性能问题。

##### 5、为什么数据库要用一个字节去存bool类型？

1. **内存对齐**：现代计算机硬件和操作系统通常在处理按字节对齐的数据时性能更好。一个字节是最小的可寻址单位，使用它可以避免对单个或几个位进行特殊处理，从而提高数据访问的效率。
2. **性能考虑**：在CPU和内存交互时，传输一个完整的字节比传输单个位要快得多。通常，CPU会以字节甚至更大单位（如32位或64位字）的形式读写内存。当处理布尔值时，使用一个完整字节有助于避免潜在的性能损失。

### 七、数据库优化

**连接优化：**本质上MySQL还是提供的TCP长链接的方式进行网络通信，因此根据业务规模设置合理的连接池和连接参数很有必要，我们要尽可能的避免大事务、长时连接、死锁等情况，目的就是为了避免连接池耗尽和连接阻塞问题。

**索引：**索引对于InnoDB存储引擎的性能而言非常重要，我们在实际的工作中，要充分评估业务场景；能走聚集索引就走聚集索引，不能走聚集索引就走非聚集索引。

**分库分表：**在InnoDB存储引擎中，其特有的B+Tree索引数据结构，最本质的目的之一就是为了尽可能保持树的高度（h），因为h越高，代表着IO次数越多，对于关系型数据库而言，最关注的性能指标便是IO次数了。因此一旦突破最佳性能下的h，性能会急剧的下降。

**读写分离：**当并发高的时候，一台数据库服务器既读又写，压力山大。此时我们可以采用读写分离的技术方案。在读写分离的模式下，主库负责写，从库负责读。各司其职，压力down down down，性能up up up.（主从之间的数据同步是另一个话题，计划单独记录一篇）。

### 参考

[](https://blog.csdn.net/bangyanya/article/details/127221534)
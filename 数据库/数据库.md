## 数据库

#### SQL执行流程

**词法解析：**在词法解析阶段，解析器会将输入的SQL字符串（一串字符）分解成一系列有意义的单元，称为“词法单元”，每个词法单元都有一个特定的类别，如`SELECT`是一个关键字，`users`是一个标识符，`>`是一个运算符，`30`是一个常量。

**语法解析：**使用一组预定义的规则（通常以文法的形式存在）来检查词法单元的序列是否能构成合法的SQL语句结构。

**语义解析：**预处理器主要负责将解析阶段生成的语法树转换为更易于数据库优化器处理的形式，并进行初步的查询验证工作：

1. **验证（Validation）** 预处理器将检查SQL语句中引用的所有对象（如表格、列、视图等）是否存在，并验证用户是否有权限访问这些对象。这个步骤确保了查询的合法性。
2. **优化准备（Optimization Preparation）** 这个阶段涉及重写查询以提高效率，例如消除冗余的子查询、展开视图等。虽然**实际的查询优化通常发生在后续的查询优化阶段**，但预处理器设置了基础，使优化器能够高效地进行工作。
3. **解析树转换（Parse Tree Transformation）** 解析树可能会被转换成一个更加抽象的内部表示，称为查询树（query tree）或查询图（query graph）。这个结构更侧重于查询的逻辑含义而不是其原始语法形式。
4. **上下文相关检查（Contextual Checks）** 检查语句在当前的数据库环境上下文中是否有意义，例如，聚合函数是否处在正确的位置，或者GROUP BY和ORDER BY子句中的列是否存在。

**查询优化器：**优化器主要负责将 SQL 查询语句的执行方案确定下来，参考：`数据的大小、可用内存资源、磁盘 I/O 成本、索引情况` 来确定执行具体方案，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

```markdown
## 怎么决定选择哪个索引？
	•	选择性计算：选择性 = 索引字段的唯一值数目 / 表中的总行数
	•	唯一性索引（如主键索引）选择性为 1，是最优的索引。
	•	对于低选择性的索引（例如包含大量重复值的字段，如性别、状态等），查询优化器可能会认为其效果不佳，而不选用该索引。
```

语句 -> 单元 -> 语法树 -> (验证、准备、解析树) -> 优化 

**执行器：**

- 主键索引查询
- 全表扫描
- 索引下推

![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16.png)

1、在打开客户端后，最初需要和sql服务器建立连接，账号认证和校验权限。

2、认证后，客户端发生查询sql脚本给服务器

3、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。

4、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。

5、MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。

6、将结果返回给客户端。

#### 语句执行顺序：

```sql
SELECT DISTINCT player_id, player_name, count(*) as num #顺序5
FROM player JOIN team ON player.team_id = team.team_id #顺序1
WHERE height > 1.80 #顺序2
GROUP BY player.team_id #顺序3
HAVING num > 2 #顺序4
ORDER BY num DESC #顺序6
LIMIT 2 #顺序7
```

### 一、数据库基础

#### 三个范式[nf](https://blog.csdn.net/A_art_xiang/article/details/113880638)

##### 第一范式

原子性：列或者字段不能再分，要求属性具有原子性，不可再分解；

![1nf](https://img-blog.csdnimg.cn/20210220121125532.png)

##### 第二范式

2NF唯一性： 要求非主键字段的值必须完全依赖主键（不能部分依赖），表中，学分是依赖课程的，成绩是部分依赖联合主键（学生，课程）的。

![2nf](https://img-blog.csdnimg.cn/20210220122011873.png)

##### 第三范式

3NF 直接性：数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系。

![3nf](https://img-blog.csdnimg.cn/20210220122950155.png)

#### 主键、候选键、外键

主键的特性：

- 1.唯一性，不可重复

- 2.强制性，不可以为空

- 3.永久性，不可以改变

- 4.最小集合，不可以参杂多余的属性（从中去掉任何一个子属性后，就不再具备唯一性）

  数据库自动为主键创建索引，从而加快查找和排序操作

候选键的特性（唯一、强制、最小集合）：

候选键是一个或多个列的组合，可以唯一标识表中的每一行。如果一个或多个列满足唯一性和完整性，那么这些列就可以被视为候选键，表中可以有多个候选键，候选键可以为NULL。每个主键都可以是候选键，但反过来则不可能。

```
在所有候选键中，通常会选择其中一个作为主键（Primary Key），用于在数据库中建立唯一的标识和索引。选择主键时，通常会考虑其稳定性和使用频率。
```

外键的特性：

- 外键是指一个表中的一个或多个字段，它们的值必须在另一个表中的某个字段中存在。在被参照表中必须唯一（通常是主键）。

- 外键的作用是保证数据的完整性和一致性，限制数据的删除和修改。

  **为什么必须唯一**：每个外键值都应该精确地引用参照表中的一个特定行。如果参照列不是唯一的，那么外键就无法清楚地指出它所关联的具体是哪一行。

#### 完整性约束

数据库完整性约束是保证数据库中数据一致性和完整性的重要概念。它主要包括**实体完整性、域完整性、参照完整性和用户定义的完整性**。实体完整性约束指表中必须有主键，且主键的值不能为空或重复；域完整性指每个字段（即列）的值都符合特定的数据类型、格式和约束条件；参照完整性约束指外键的值必须在被参照的表中找到或者为空；用户定义的完整性约束指对数据类型、格式、取值范围等进行约束。

- 每一行都有一个唯一的标识——主键
- 列的数据类型和格式必须满足特定的条件
- 外键的值必须是另一表的主键的有效值，或者是NULL

#### 视图

视图本质上是一个虚拟表，它是基于查询语句的结果集。当基础表中的数据发生改变（插入、删除或更新）时，视图也会反映这些变化，因为每次查询视图时，它都会重新执行关联的查询语句，从而获取最新的数据。**视图不会独立存储数据**，它依赖于基础表的数据。

### 二、数据库事务

在InnDB存储引擎中，事务的原子性、一致性、持久性都是通过redo和undo日志文件实现。 redo：重做日志。它记录了事务的执行过程，可以支持任何场景下的”重做“。 exp：当事务提交之后，通过异步刷新磁盘的方式持久化到磁盘中，如果事务提交之后，服务宕机了，可以通过redo日志进行恢复。

**事务是数据库的最小工作单元，是单个逻辑工作单元**

```
现代数据库中，即使是单个 SELECT 操作也会被封装在一个事务中执行。虽然 SELECT 操作本身是只读的，不会改变数据库的状态，但它通常会在事务的上下文中执行，以确保数据的一致性和隔离性。
```

#### 1.事务特性

原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态

隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

#### 2.隔离级别

- (1) 读未提交（read Uncommited）:在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用。
- (2) 读已提交（read commited）:这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；会避免脏读问题；由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读的问题（可以在读时加锁解决）
- (3 ) 可重复读（Repeatable read）：这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。不可重复读是我们在一次事务中读到的数据数值不一致，而幻读则是读到了上一次查询根本不存在的行。
- (4) 串行化（serializable）：事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；

MySQL InnoDB中设置隔离级别方法：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL<隔离级别>;
其中，`<隔离级别〉`可以是 read uncommitted、readcommitted、repeatable read 或 serializable.
```

#### 3.示例

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/1235188eba154b7b869b15f7e860fee7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

`FOR UPDATE`只能在支持行级锁的数据库引擎中使用，并且只能在事务块内部使用

事务 A 在③处执行了select * from bank_balance where balance > 0 for update这条锁定读语句后，就会把整个表所有记录锁上(因为balance字段无索引)

### 三、索引

#### 实现原理

索引的原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

- \1. 把创建了索引的列的内容进行排序
- \2. 对排序结果生成倒排表
- \3. 在倒排表内容上拼上数据地址链
- \4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

当你在某个字段上建立索引时，底层会创建B+树来存储该字段的值及其对应的行指针，索引数据被存储在数据库文件系统中的单独文件里，索引中的每个条目都包括一个指向实际数据行的指针（在InnoDB中称为主键ID）。如果索引是主键索引，那么它直接包含数据；如果是二级索引，那么它包含主键字段的值。

- **查询优化**：一旦索引被创建，MySQL的查询优化器会在解析查询时考虑使用索引来加速查找和排序操作。

#### 索引优点

索引存储在内存中，为服务器存储引擎为了快速找到记录的一种数据结构。索引的主要作用是加快数据查找速度，提高数据库的性能。

```markdown
## 优点：
创建唯一性索引，保证数据库表中每一行数据的唯一性
大大加快数据的检索速度，这也是创建索引的最主要的原因
加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

## 索引的分类（必会）
普通索引：最基本的索引，它没有任何限制。
唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用     primary key 来约束。
联合索引（又叫复合索引）：多个字段上建立的索引，能够加速复合查询条件的检索。

## 主键索引和唯一索引的区别
唯一标识：主键是一张表中记录的唯一标识，每个表只能有一个主键，而一个表可以有多个唯一索引。

非空约束：主键字段不允许NULL值，这是由数据库系统强制的，以确保每行数据都能被唯一地识别。相比之下，唯一索引的列可以包含NULL值（具体取决于数据库系统，某些数据库系统允许唯一索引列有多个NULL值）。

聚集索引：在许多数据库系统中，主键索引默认是聚集索引。这意味着表中的数据物理上按照主键索引的顺序存储。这可以加快基于主键的查询速度。相比之下，唯一索引通常是非聚集索引，并不影响数据的物理存储方式。
```
![在这里插入图片描述](https://gitee.com/xu_zuyun/picgo/raw/master/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVsb2lzZV95YW5neXVjaGFuZw==,size_13,color_FFFFFF,t_70,g_se,x_16.png)

#### 设计原则

- **适合索引**的列是出现在where子句中的列，或者连接子句中指定的列，对于那些查询中很少涉及的列，
- 更新频繁字段、重复值比较多、基数较小的表的列**不适合建立索引**。
-  使用**短索引**，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间， 如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
- **不要过度索引**。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进 行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
- 定义有外键`的数据列一定要建立索引（**JOIN、校验、级联**）。
- 尽量的**扩展索引**，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

#### 优化设计

##### 外键索引

子表参照原表：

1. **提高查询性能**：当对外键列进行查询操作时，如连接（JOIN）两个表，如果外键列上有索引，数据库可以快速匹配相关的行，这样可以显著提高查询效率。(子表索引)——查
2. **加速外键约束检查**：在插入或修改含有外键的表时，数据库系统需要检查外键值是否存在于原表中。如果参照表中的对应列已经被索引，这个检查过程会更快。（原表索引）——增
3. **维护数据完整性的性能**：当更新或删除原表中的数据时，需要检查是否有依赖于这些行的外键约束。如果有索引，数据库可以快速找到所有受影响的行，并执行相应的级联更新或删除操作。（子表索引）——删、改
4. **防止锁升级**：如果没有在外键列上建立索引，执行上述三种情况会导致全表扫描，进而引起锁升级（例如，从行级别锁变为表级别锁），这会降低并发性能。

##### 索引下推

```sql
CREATE INDEX idx_ab ON table (A, B);
SELECT * FROM table WHERE A=1 AND B=2 AND C=3;
```

### 不使用索引下推（没有ICP）：

1. **索引查找**：数据库首先使用复合索引 `idx_ab` 来快速找到所有 `A=1 AND B=2` 的行。
2. **回表操作**：然后，数据库会访问实际的数据行，检索完整的记录。
3. **逐行过滤**：对于每一条检索出来的记录，数据库接着检查 `C` 字段是否等于 `3`。

在此情况下，即使 `A=1 AND B=2` 有很多匹配的索引项，数据库也需要为每个匹配项执行回表操作，并读取完整的数据行来验证 `C=3` 是否成立。这可能涉及大量不必要的I/O操作。

### 使用索引下推（启用ICP）：

1. **索引查找并过滤**：数据库使用复合索引 `idx_ab` 并开始遍历。由于启用了索引下推，当找到索引中 `A=1 AND B=2` 的记录时，数据库现在可以在同一步骤中进一步检查 `C` 字段的条件（如果存储引擎支持这种操作）。这意味着只有当索引记录同时满足 `A=1`, `B=2`, **以及该记录所指向的行的 `C` 字段值为 `3`** 时，才会标记为匹配。
2. **减少回表次数**：只有那些符合全部条件的记录才会进行回表操作以获取全部数据。

```sql
在 EXPLAIN 输出结果中，如果看到 Extra 列包含了 Using index condition，则表示对该查询使用了索引下推。

主要在查询优化器阶段进行：当查询包含过滤条件时，优化器可以重新排列查询以利用索引的能力，从而在扫描索引时就进行条件判断，从而避免不必要的数据访问。
```

##### 覆盖索引

```sql
CREATE INDEX idx_username_email ON users (username, email);
SELECT username, email FROM users WHERE username = 'johndoe';
```

覆盖索引是指一个索引包含了查询所需要的所有数据。换句话说，如果一个查询能够仅通过访问索引就可以得到所需的数据，而不必读取表中的数据行，那么这个索引就是覆盖索引。

1. **减少I/O操作**：由于索引通常比整张表小很多，因此查询可以更快地在索引中进行，而不需要进行额外的磁盘I/O来读取实际的数据行。
2. **提高查询性能**：当索引能够覆盖查询时，MySQL可以避免读取数据行，这样可以显著提高查询速度，尤其是对于大型数据表。
3. **缓存更高效**：索引条目通常比数据行更小，更多的索引值能够被缓存在内存中，这意味着更少的缓存页和更高的缓存命中率。
4. **减少锁竞争**：某些数据库管理系统在访问索引时使用的锁粒度可能比访问表时更细，这可能会减少锁等待时间和锁竞争。

```markdown
如果 WHERE 子句中的某些列没有被索引覆盖，那么数据库就不能仅通过索引来完成查询。在这种情况下：

索引非覆盖扫描：数据库仍然会首先使用索引来查找满足某些条件的行。但是，由于不是所有的查询条件都能通过索引解决，数据库还需要`访问实际的数据行来进一步过滤结果`或者检索额外的数据。
可能的表扫描：如果索引不能有效地缩小结果集，数据库`可能会退回到进行全表扫描`来确定满足 WHERE 子句的行。
```

```sql
在 EXPLAIN 输出结果中，如果看到 Extra 列包含了 Using index condition，则表示对该查询使用了索引下推。
```

#### Mysql中的实现

1. B+Tree 索引: 最常见的索引类型, 大部分索引都支持B+树索引.

2. Hash 索引: 只有Memory引擎支持, 使用场景简单.

3. R-Tree索引(空间索引): 空间索引是MyISAM引擎的一个特殊索引类型, 主要地理空间数据, 使用也很少.

4. S-Full-text(全文索引): 全文索引也是MyISAM的一个特殊索引类型, 主要用于全文索引, InnoDB从Mysql5.6版本开始支持全文索引.


```markdown
B+Tree 索引是通过`二分查找`的方式进行查询
而全文索引、哈希索引或位图索引等`都有自己的特定查找算法和流程`
```


```sql
ALTER TABLE students
ADD INDEX idx_score (score);

ALTER TABLE students
ADD INDEX idx_name_score (name, score);

DROP INDEX index_name
ON table_name;

SELECT *
FROM user
WHERE username = 'Alice';
// 如果 user 表中有名为 idx_username 的索引，那么 MySQL 就会使用该索引来加速查询操作。
```

##### 联合索引的叶子节点存储了哪些值？

1. **索引键值**：这是构成索引的那些列的实际数据。在联合索引中，叶子节点会包含所有索引列的值，它们根据索引定义时指定的顺序进行排序。

2. **行指针**：每个索引键值会有一个对应的行指针，指向具有该索引键值的表中的行。这个指针可以是行的物理地址（如行ID或数据文件中的位置），也可以是主键的值，具体取决于索引是聚集索引还是非聚集索引。

   ```
   - 对于**聚集索引**（通常只有一个，就是表的主索引），因为索引结构的叶子节点直接包含了整行数据，所以这里说的“指针”就是数据本身。
   - 对于**非聚集索引**（次级索引），叶子节点则包含一个指向聚集索引键的指针或者直接指向数据行的指针，这样才能找到完整的行数据。
   ```

3. **其他元信息**：某些数据库系统可能还会在索引的叶子节点中存储一些额外的元信息，比如事务版本号、锁信息等，这用于支持并发控制、恢复和维护操作。

B+树 相比 跳表的优势：

> ### 1. 磁盘I/O优化
>
> B+树是为磁盘存储而设计的数据结构，其节点大小通常与磁盘块对齐（例如，4KB）。这意味着每个磁盘I/O操作可以加载一个完整的B+树节点。这样的设计减少了磁盘I/O次数并提高了访问速度。
>
> ### 2. 高扇出率
>
> B+树通过增加索引节点的分支数（扇出率）来减少树的深度。在实际应用中，一个B+树节点可能包含数百个指针，这使得B+树通常很“浅”——即便是大型数据库也只需要几次磁盘读取就能找到所需记录。
>
> ### 3. 范围查询优势
>
> B+树通过其叶子节点的有序链表特性，非常适合执行范围查询。在进行范围搜索时，你可以从范围的一个端点开始，然后顺序遍历叶子节点直到另一个端点。相比之下，跳表执行范围查询时效率较低，因为它`必须在每个级别处理跳过的节点`。
>
> ### 4. 缓存局部性原理
>
> B+树具有良好的缓存局部性，因为节点通常在物理存储上是连续存放的，且查询路径上的节点可被系统缓存以供后续快速访问。跳表由于其结构特性，可能不如B+树在利用缓存方面有效。

跳表 相比 B+树的优势：

> ### 1. 简单的实现
>
> 跳表的算法和数据结构要比B+树简单得多。对于跳表，基本的插入、删除和查找操作比B+树更容易实现，不需要复杂的树平衡操作。这使得跳表在某些情况下更易于编码和维护。
>
> ### 2. 动态性
>
> 跳表是一个完全动态的数据结构，可以在运行时无缝地进行增长和收缩，而不需要批量的重组整个数据结构。相比之下，B+树在节点分裂或合并时可能需要更多的数据移动和I/O操作。
>
> ### 3. 适应内存数据库
>
> 跳表特别适合内存数据库和缓存系统，因为它们主要依赖随机内存访问，而且没有磁盘I/O的限制。内存中的随机访问成本远低于磁盘访问，因此跳表的随机层级结构在这种情况下并不会成为性能瓶颈。

### 四、数据库锁

#### 行锁和表锁

1.主要是针对锁粒度划分的，一般分为：行锁、表锁、库锁

行锁：访问数据库的时候，锁定整个行数据，防止并发错误。

表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

页级锁：是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。

**行锁 和 表锁 的区别：**

 表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

 行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

#### 悲观锁和乐观锁

（1）悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

（2）乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

#### 死锁

**概念：**发生在两个或多个事务在执行过程中，因为争夺同一资源而相互等待，导致所有相关事务都无法继续执行的情况。

**预防：**

- 使用合适的锁粒度（如行锁代替表锁）可以减少死锁可能性，因为细粒度的锁意味着更少的数据被锁定。
- 分解大型事务为多个更小的事务，每个事务完成一个逻辑单元工作，并及时释放不需要的锁。
- 保证所有事务以相同的顺序请求资源锁可以预防循环等待条件，从而避免死锁发生。

**解除：**

- 为数据库操作设置超时时间可以避免无限期等待资源，超时后事务会被终止。
- 当检测到死锁时，数据库系统通常会选择并中止一个或多个事务以解开死锁，允许其他事务继续执行。
- 在只读取数据且脏读不会引起问题的情况下，可以使用较低的事务隔离级别。但请注意这样做有可能读取到未提交的数据。

#### 锁升级

Mysql默认使用**行级锁**，锁**升级** 是数据库管理系统为了减轻锁定颗粒度管理的开销而采用的一种技术。当小范围的锁（如行锁）变得太多时，DBMS可能会将这些小范围的锁提升为大范围的锁（如页锁或表锁）。尽管锁升级能减轻系统的锁管理负担，但它也增加了事务之间发生死锁的风险，并可能显著降低并发性能。

### 五、数据库设计

#### 关系型与非关系型数据库

1、数据存储方式不同

- 关系型数据天然就是表格式的，因此存储在数据表的行和列中，结构化存储。
- 非关系型数据通常存储在数据集中，就像文档、键值对、列存储、图结构。

 2、扩展方式不同

- 在基于web的结构中，关系型数据库是最难以横向拓展的，通常要优化机器性能。
- 非关系型数据存储天然就是分布式，NoSQL数据库是横向扩展的，给资源池添加更多普通的数据库服务器分担负载。

3、对事务性的支持不同

- 如果数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库是最佳选择。
- NoSQL数据库是最终一致性，一般不保证ACID的数据存储系统，具有极高的并发读写性能，价值是在操作的扩展性和大数据量处理方面。

```markdown
## 非关系型优点：
成本低：nosql数据库部署简单，基本都是开源软件
查询速度快：
存储数据的格式多：nosql的存储格式是key，value形式，文档形式，图片形式等，所以可以存储基础类型以及对象或者是集合的等多种形式，而关系型数据库只支持基础类型
高扩展性：
速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘
## 关系型优点：
丰富的完整性(实体完整性，参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率
```

#### 关系型数据库优化

A：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。

B：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间, 前提是这个列经常被用到, 这也就是反第三范式。

C：分割表。

数据表拆分：主要就是垂直拆分和水平拆分。

水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。

垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。

D: 字段设计

    表的字段尽可能用NOT NULL
    字段长度固定的表查询会更快
    把数据库的大表按时间或一些标志分成小表
### 六、数据库扩展

#### 垂直扩展

- 也称为纵向扩展，是通过向现有机器添加更多的性能（CPU、RAM、DISK等）来进行扩展。
- 单点故障的风险增加。
- 垂直扩展的总体成本较高。强大的服务器更加昂贵。

#### 水平扩展

也称为分片，是添加更多服务器的做法，将大型数据库分割成更小、更易管理的部分，称为分片。每个分片共享相同的模式，尽管每个分片上的实际数据是唯一的。

![image-20230517210216761](https://gitee.com/xu_zuyun/picgo/raw/master/img/60df5ceccfc849e7a5a3c23f5b909e30.png)

- **重新分片问题：**在选择分片键时，最重要的一个标准是选择一个能够均匀分布数据的键。某些分片可能由于不均匀的数据分布而更快地耗尽分片。当分片耗尽时，需要更新分片函数并移动数据。
- **热点键问题**：也称为明星问题。对特定分片的过度访问可能导致服务器超载。
- **连接和去规范化**：一旦数据库被分片到多个服务器上，执行跨数据库分片的连接操作就变得困难。一个常见的解决方法是对数据库进行去规范化，以便可以在单个表中执行查询。

### - 问题

##### 1、count(*)、count(1)、count(列)的区别？

- `COUNT(1)`和COUNT(*): 结果集中的行数，不关心具体的列内容，`COUNT(*)`会统计表中所有列，而`COUNT(1)`只统计一个固定值
- `COUNT(列)` ：统计指定列非空值的数量。需要考虑是否有NULL值
   此种方式取决于列是否有索引。如果 列有索引，数据库引擎可能会利用索引进行快速计数。如果没有索引，或者有大量NULL值，性能可能较差，因为需要扫描整个表。

```
有主键或联合主键的情况下，count(*)略比count(1)快一些。 
没有主键的情况下count(1)比count(*)快一些。 

优先考虑count(*)，因为mysql数据库本身对于count(*)做了特别的优化处理
```

##### 2、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几?

　　一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是8；但是如果重启（文中提到的）MySQL的话，这条记录的ID是6。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是8。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

##### 3、char和varchar的区别？

- 最大长度： Char 类型是固定长度的，其最大长度通常为255个字符或10个字节（取决于操作系统）。 varchar 类型则是可变长度的，其最大长度可以达到65535个字节。

- 存储效率： Char 类型的存储效率较高，在检索时可以快速定位数据

- 空间使用： Char 会浪费一些空间

- Char 通常用于存储固定长度的数据，如身份证号码、电话号码等。 varchar 更适合存储可变长度的数据，如用户名、地址等。

  ```
  空间填充：char如果存储的字符串长度小于定义的长度，MySQL 会使用空格来填充其余的位置，以保证数据长度始终是固定的。varchar需要额外的空间来存储字符串的实际长度(额外的1字节或两个字节)，这可能会导致轻微的性能开销。
  检索速度：由于长度固定，CHAR 类型的字段在某些情况下可以更快地被检索，因为存储系统知道每个记录的确切位置。
  ```

  ```markdown
  ## 注意：
  字符集影响：字符集也可能影响存储大小。比如，在 UTF-8 编码下，一个字符可能需要最多 3 或 4 个字节来存储。
  
  varchar具体是一个字节还是两个字节，取决于你为 VARCHAR 字段定义的最大长度（255以内是一个字节）（⚠️有些系统可能总是使用两个字节）
  ```

```
Msql4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）。
Mysql5.0版本以上，varchar(20)，指的是20字符
```



##### 4、为什么最好用NOT NULL

1. **数据完整性**：强制字段必须有值可以确保数据库中的记录都是完整的，这对于分析和决策非常重要。它避免了数据出现不一致或含糊不清的情况。
2. **简化查询**：如果字段可以为 `NULL`，那么在编写查询（特别是复杂的查询）时就需要考虑 `NULL` 值的处理，这可能会使查询逻辑变得更加复杂。
3. **优化性能**：知道一个字段永远不会为 `NULL` 可以帮助数据库优化器选择更高效的执行计划。某些数据库系统在处理非空字段时会更加高效，因为它们可以省去检查 `NULL` 的步骤。
4. **索引效率**：有时候，标记为 `NOT NULL` 的字段可以更有效地被索引。例如，在某些数据库系统中，对于包含 `NULL` 值的字段，索引可能会不包括那些 `NULL` 记录，这可能导致性能问题。

##### 5、为什么数据库要用一个字节去存bool类型？

1. **内存对齐**：现代计算机硬件和操作系统通常在处理按字节对齐的数据时性能更好。一个字节是最小的可寻址单位，使用它可以避免对单个或几个位进行特殊处理，从而提高数据访问的效率。
2. **性能考虑**：在CPU和内存交互时，传输一个完整的字节比传输单个位要快得多。通常，CPU会以字节甚至更大单位（如32位或64位字）的形式读写内存。当处理布尔值时，使用一个完整字节有助于避免潜在的性能损失。

##### 6、为什么推荐使用自增主键？

- **简单高效：**自增主键由数据库自动管理，开发者无需担心如何生成唯一的键值。
- **插入速度**：自增主键通常是连续的，这意味着新记录可以迅速插入表的末尾，而不需要进行额外的查找操作来确定插入位置。
- **索引效率**：基于自增主键的索引一般比随机或非顺序的键更高效。因为它们是顺序的，所以索引结构（如 B-Tree）上的分裂和重新平衡操作更少，从而提升性能。
- **范围插入：**自增主键可以支持很长一段时间内的数据增长，即使是在非常大量的数据插入情况下也不会出现问题。

7、数据库是怎么保证原子性的？

> ### 1. **事务管理**
>
> - 数据库系统将一组操作封装成一个事务。事务是一个不可分割的操作单元，要么全部执行成功，要么全部不执行。
>
> ### 2. **日志机制**
>
> - 数据库通常使用日志（如事务日志）来记录事务的所有操作。在事务开始之前，操作会记录到日志中，这样在宕机或错误时，可以通过重做或撤销来保证原子性。
>
> ### 3. **锁机制**
>
> - 在执行事务时，数据库可能会使用锁来防止其他事务对正在处理的数据进行并发操作，从而保证事务的完整性和一致性。
>
> ### 6. **2PC（两阶段提交协议）**
>
> - 在分布式数据库中，2PC协议用于确保跨多个节点的事务原子性。它分为准备阶段和提交阶段，确保所有参与者同意后才会提交操作。

### 七、数据库优化

**连接优化：**本质上MySQL还是提供的TCP长链接的方式进行网络通信，因此根据业务规模设置合理的连接池和连接参数很有必要，我们要尽可能的避免大事务、长时连接、死锁等情况，目的就是为了避免连接池耗尽和连接阻塞问题。

**索引：**索引对于InnoDB存储引擎的性能而言非常重要，我们在实际的工作中，要充分评估业务场景；能走聚集索引就走聚集索引，不能走聚集索引就走非聚集索引。

**分库分表：**在InnoDB存储引擎中，其特有的B+Tree索引数据结构，最本质的目的之一就是为了尽可能保持树的高度（h），因为h越高，代表着IO次数越多，对于关系型数据库而言，最关注的性能指标便是IO次数了。因此一旦突破最佳性能下的h，性能会急剧的下降。

**读写分离：**当并发高的时候，一台数据库服务器既读又写，压力山大。此时我们可以采用读写分离的技术方案。在读写分离的模式下，主库负责写，从库负责读。各司其职，压力down down down，性能up up up.（主从之间的数据同步是另一个话题，计划单独记录一篇）。

### 参考

[](https://blog.csdn.net/bangyanya/article/details/127221534)
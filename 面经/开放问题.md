### 一、创建一块新的内存一定比指针重新指向慢吗，为什么？

```markdown
一般情况下，创建新的内存确实比指针重新指向要慢，原因如下：
## 内存分配开销：
创建新的内存通常意味着操作系统需要在堆上为你的数据分配空间。这个过程可能包括查找足够大小的连续内存区域、更新内存管理的数据结构等
## 指针赋值效率：
指针重新指向通常只是改变了指针变量所保存的内存地址，是 CPU 缓存友好的操作，因为它简单且通常可以在 CPU 寄存器中快速完成，内存分配可能会触发更多的内存访问，这些访问不一定能够高效地利用缓存。
## 系统调用：
内存分配可能会涉及到操作系统层面的系统调用（如当内存不足时请求更多内存），这会增加延迟，指针操作通常完全在用户空间完成
```

例外情况P：如果指针重新指向后引用的数据位于缓慢的存储介质上（如硬盘，或者跨网络的存储），那么随后的数据访问可能会变得非常慢。同样，如果内存已经预分配好了，那么“创建新内存”可能实际上只是在这块预分配的内存上进行简单的标记，这种情况下创建新内存的开销也会很小。

```markdown
## 分配内存的详细过程
内存池管理：内存管理器通常会实现一个内存池或空闲链表，将大块的内存分割成小块，根据应用的需求分配合适的块大小。（首次适配、最佳适配、最差适配、循环首次适配）

操作系统使用 页表（Page Table） 来维护虚拟地址到物理地址的映射(TLB加速)。每当分配新的内存，操作系统会将新的虚拟地址区域映射到实际的物理内存。

如果物理内存不足，操作系统可能会将某些不常用的内存页写入 交换区（Swap），腾出物理内存.

操作系统捕捉到缺页中断后，会为这个虚拟地址分配一个新的物理页，并更新页表。此时，虚拟内存空间中的某段地址会与物理内存关联。
```

```
	1.	应用程序 调用动态内存分配函数（如 malloc()）。
	2.	操作系统 通过虚拟内存管理系统，将虚拟地址映射到物理内存。
	3.	硬件（MMU） 负责处理虚拟地址到物理地址的转换，支持内存分页和高速缓存访问。
```

### 二、mysql中有一个表有（A，B，C，D）字段，select A,B from 表 where C=? and D=?,如何让这段SQL执行速度达到最快？

1. **创建合适的索引**：

   - MySQL 可以大幅提速查询，尤其是如果数据量很大时。对于该查询，你可以创建一个组合索引（C,D），这样 MySQL 查询优化器可以利用该索引快速定位到满足条件 `C=? AND D=?` 的数据行。

   ```sql
   CREATE INDEX idx_c_d ON 表名 (C, D);
   ```

   - 索引列的顺序很重要，理论上应该按照过滤能力更强的列放在前面。

2. **分析查询计划**：

   - 使用 `EXPLAIN` 命令来分析 SQL 执行计划，确保查询正在使用正确的索引进行操作。

   ```sql
   EXPLAIN SELECT A, B FROM 表名 WHERE C=? AND D=?;
   ```

3. **调整列类型和大小**：

   - 确保字段 C 和 D 是最佳的数据类型，并且没有过多的空间浪费。对于字符串类型，避免使用太长的 VARCHAR，这会增加索引的大小，从而增加 I/O 操作和内存使用。

### 三、一个分支上面提交了1，2，3，如何得到1，3而跳过2？

使用`git rebase`进行交互式变基

```sh
git rebase -i HEAD~3
```

或者指定 `1` 这个提交之前的提交哈希值作为起点：

```sh
git rebase -i <1的哈希值>
```

在弹出的编辑器中，你会看到这样的列表：

```sh
pick 1xxxxx Commit message for 1
pick 2xxxxx Commit message for 2
pick 3xxxxx Commit message for 3
# 将 2 这一行前面的 pick 改为 drop 或直接删除该行。
drop 2xxxxx Commit message for 2
```

### 四、避免重复下单的几种解决方案？

1. **使用唯一性约束**:
   - 在数据库层面上通过设置唯一性约束来避免插入重复的订单。例如，你可以根据业务需求将订单相关的一个或多个字段（如用户ID、商品ID和下单时间）组合成一个唯一索引。
2. **令牌桶算法**:
   - 生成一个唯一的令牌（Token）并在客户端随请求发送，下单操作必须携带该令牌，服务器在处理前会检查令牌的有效性，并确保同一个令牌只能被使用一次，这样即使用户点击了多次提交按钮，也只有第一次点击能够创建订单。
3. **幂等性设计**:
   - 设计接口以支持幂等操作，即多次执行相同操作的效果与执行一次相同。可以通过检查历史数据或使用状态机来确保即使多次收到相同的下单指令，也只会执行一次创建订单的操作。
4. **分布式锁**:
   - 在分布式系统中，可以使用分布式锁（如基于 Redis 或 ZooKeeper 的锁）来确保同时只有一个请求能够进行下单操作。当一个下单请求在处理时，其他具有相同锁定条件的请求将被阻止直至当前请求完成。
5. **订单请求队列**:
   - 将下单请求放入消息队列，并确保队列消费者按顺序处理消息，这样即使多个下单请求同时到达，也能逐一处理它们，避免重复下单。

```markdown
## 如果用户没有一个唯一标识或者说用户不需要登陆就能下单，该如何避免重复下单?

对特定 IP 地址或基于设备指纹的下单请求设置速率限制，防止短时间内发生大量请求。
利用 Cookies、Session 或 Local Storage 在客户端生成一个临时的唯一标示（如 UUID）。这样即使用户没有登录，系统也能通过这个标识来跟踪订单。
针对每次请求生成一个唯一的请求令牌，该令牌在使用后立即失效，确保同一个请求不会被执行两次。
```

### 五、在大文件进入到内存之前如何避免一次性传入过大的文件

1. 使用流式上传

   在客户端和服务器之间建立一个数据流，这样文件可以分片（chunk）进行传输。客户端不需要将整个文件读入内存，而是将其划分为小块，逐块发送到服务器。

2. 分块上传

   客户端程序中实现文件的分块上传。每个块单独上传，并由服务器重新组合。

```javascript
// 前端
file = open('large_file', 'rb')
chunk_size = 1024 * 1024  # 假设每块1MB
while not end_of_file:
    chunk = file.read(chunk_size)
    # 发送HTTP POST请求上传这个块
    send_chunk_to_server(chunk)
file.close()
```

```python
# 后端
on_chunk_received(chunk, file_id, chunk_index):
    temp_file_name = f'{file_id}_part_{chunk_index}'
    write_chunk_to_temp_file(chunk, temp_file_name)
    
on_upload_completed(file_id, total_chunks):
    with open(f'{file_id}_complete', 'wb') as complete_file:
        for i in range(total_chunks):
            temp_file_name = f'{file_id}_part_{i}'
            chunk_data = read_temp_file(temp_file_name)
            complete_file.write(chunk_data)
            delete_temp_file(temp_file_name)
```

### 六、Double存储小数，为什么不精确，怎么解决？

Double结构

符号位

- **1 位**用来表示数字的正负，0 表示正数，1 表示负数。

指数位

- **11 位**用来表示指数。IEEE 754 使用 "偏移量"（或称为 "偏移二进制表示法"）来存储指数，以使它能够表示正负指数。对于 double 类型，指数的偏移量是 1023，所以实际存储的时候会将指数值加上1023后再进行存储。

尾数位

- **52 位**用来表示尾数。尾数表示数字的有效数字（不包括整数部分的最高位，因为除了 0 外，它总是 1，所以可以省略，这被称为隐含位）。

```
[S][Exponent 11 bits][Mantissa 52 bits]
// 例如：
110.1 (二进制) = 1.101 x 2^2 (科学计数法)
表示为：
符号位：由于 6.5 是正数，所以符号位为 0。
指数位：科学计数法中的指数是 2，加上偏移量1023得到最终存储的指数值1025，即 10000000001（二进制）。
尾数位：有效数字 1.101 去掉整数部分的 1 后剩下 .101，后面补充0直到满足52位。
```

由于部分十进制转二进制后是超过52位，产生截断，无法精确表示

我们使用deicmal库解决这个问题

`decimal` 数据类型使用固定的小数点和足够数量的十进制位来直接表示数字，这样就能准确地存储十进制数，例如货币值。`decimal` 的设计意图是保留小数点后固定位数的精度，而无需进行二进制到十进制的转换，这意味着无论整数部分有多大，小数部分都能被精确保存。

### 七、为什么要使用中间件

中间件是位于客户端和服务器之间的软件层，它提供了一种抽象，使得应用程序开发更加简单和高效。中间件通常处理数据管理、服务协调、消息传递、认证和API管理等功能。

- **解耦：**中间件允许应用程序组件彼此独立运行，从而降低了系统各部分之间的依赖性，中间件促进了不同应用程序和服务的集成，包括遗留系统和新开发的服务，从而允许它们共享数据和业务逻辑。
- **提高效率：**中间件通常包含优化的算法和过程来处理诸如数据传输、缓存和加载平衡等任务。这有助于提高整体系统性能，并隐藏了底层技术的复杂性

### 八、项目架构包含哪些模块

> ### 视图层 (View Layer)
>
> 视图层负责展示数据和接收用户输入。它通常包括用户界面(UI)元素如页面、窗口、按钮、文本框等，是用户与系统交互的直接界面。在 MVC（Model-View-Controller）架构中，视图层只负责显示数据，不处理任何业务逻辑。
>
> ### 控制层 (Controller Layer)
>
> 控制层作为请求的协调者，接收来自视图层的输入，并决定调用哪些业务逻辑或模型方法来处理这些输入。控制器解析用户的输入，然后将其转换为对模型层和业务层的调用。在 Web 应用程序中，控制层通常由一组控制器组成，这些控制器定义了如何响应 HTTP 请求。
>
> ### 业务层 (Business Layer)
>
> 业务层包含处理具体业务规则、计算和数据处理逻辑的代码。这一层决定数据如何被创建、存储或改变。业务层可以进一步被分解为服务层和领域层，其中服务层包含业务逻辑的执行流程，以及事务管理，而领域层包含业务实体和领域服务。
>
> - 领域层：用于创建复杂的领域对象，领域层专注于表达业务概念、业务状态信息和业务规则，而不应该关心其他层如展现层或数据访问层的实现细节。
> - 服务层：编排和协调对领域层的调用，以处理更复杂的业务流程。服务层通常暴露出一组服务API，这些API封装了应用程序的核心业务逻辑，为客户端提供了操作的入口点，同时隐藏了背后领域模型的复杂性。
>
> ### 模型层 (Model Layer)
>
> 模型层代表数据结构和业务实体，这是应用程序状态和业务逻辑的核心。在很多架构风格中，如 MVC，模型对象负责在数据库和业务层之间传输数据。它们通常与数据库中的表直接映射，并且可以包含数据验证、业务规则和逻辑。
>
> - 通常包含私有成员变量和公共的 getter 和 setter 方法。
> - 可以有构造函数、业务方法或业务逻辑。
> - 不包含任何与数据库操作直接相关的代码。
>
> ### 数据访问层 (Data Access Layer)
>
> 数据访问层负责与持久化存储（通常是数据库）进行交互。它提供了一个抽象层用于访问数据，屏蔽了底层数据库操作的复杂性。通过数据访问层，其他层不需要知道如何查询数据库或者如何实现特定的数据操作。它可能会使用 ORM（对象关系映射器）这样的工具来简化数据操作。
>
> - 定义了应用程序需要的数据库操作，如增删改查等。
> - 每个方法通常都对应于 SQL 语句。
> - 方法不包含实现细节，实现细节由 MyBatis 的 XML 映射文件提供。

通过上述这种分层设计的模式，我们可以更改一层的实现而不影响其他层。例如，你可以更换前端的技术栈（视图层）而不需要重新编写后端代码，或者更改数据库类型（数据访问层）同时保持业务逻辑不变。这种分层架构使得应用程序更加灵活，易于调整和维护。

领域层和服务层示例

```java
public class Account {
    private String accountId;
    private BigDecimal balance;
    
    public Account(String accountId, BigDecimal balance) {
        this.accountId = accountId;
        this.balance = balance;
    }

    // ... 省略 getter 和 setter ...

    // 领域逻辑 - 存款操作
    public void deposit(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be greater than zero");
        }
        this.balance = this.balance.add(amount);
    }

    // 领域逻辑 - 取款操作
    public boolean withdraw(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be greater than zero");
        }
        if (this.balance.compareTo(amount) >= 0) {
            this.balance = this.balance.subtract(amount);
            return true;
        }
        return false; // 余额不足
    }

    // 其他领域逻辑...
}
```

```java
public class AccountService {
    private AccountRepository accountRepository;

    // 构造函数注入依赖的仓库
    public AccountService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }
    
    // 服务层方法 - 处理存款业务逻辑
    public void depositToAccount(String accountId, BigDecimal amount) {
        // 这里可以添加跨多个领域对象的业务逻辑，如记录交易日志、发送通知等
        
        // 从仓库获取账户
        Account account = accountRepository.findById(accountId);
        
        // 执行存款操作
        account.deposit(amount);
        
        // 持久化更改
        accountRepository.update(account);
    }

    // 服务层方法 - 处理取款业务逻辑
    public boolean withdrawFromAccount(String accountId, BigDecimal amount) {
        // 从仓库获取账户
        Account account = accountRepository.findById(accountId);
        
        // 尝试执行取款操作
        boolean result = account.withdraw(amount);
        
        // 如果取款成功，则持久化更改
        if (result) {
            accountRepository.update(account);
        }
        
        return result;
    }
    
    // 其他与账户相关的业务逻辑...
}
```

领域层 和 模型层：

领域层更侧重于面向对象设计，强调通过对象和它们之间的交互来反映现实世界的业务情景。模型代表着数据模型，即应用程序的状态以及与这些数据相关的操作。

### 九、Linux上编译的软件为什么不能在windows上运行？

1. **系统调用不同**：每个操作系统提供给应用程序的系统调用（System Calls）集是不一样的。系统调用是应用程序与内核交互的接口，用于进行诸如文件操作、网络通信、内存管理等底层操作。由于Windows和Linux具有不同的内核，其系统调用的接口和行为也就不同。
2. **二进制格式不同**：Linux和Windows使用不同的可执行文件格式。Linux通常使用ELF (Executable and Linkable Format)格式，而Windows则使用PE (Portable Executable)格式。操作系统需要能够解析这些格式才能加载和执行程序，因此针对一个系统编译的程序在另一个系统上无法直接运行。
3. **链接库不同**：程序在运行时往往会依赖一些动态链接库（Dynamic Link Libraries, 在Windows中称为DLLs，在Linux中称为shared objects，[扩展名为.so](http://xn--siqu5ly1h2pg.so/)）。由于这些库在不同平台间实现和接口都可能不同，所以即使是相同功能的库也不能互换使用。

### 十、二维数组按行读更快还是按列读更快？

```go
二维数组：
[][]int{
  {1 2 3}
  {4 5 6}
  {7 8 9}
}
的实际存储方式为：1 2 3 4 5 6 7 8 9
```

由于现代CPU通常会利用缓存来加速数据的读取，连续的内存位置可以提高缓存命中率。按行访问（先读取1,2,3，然后是4,5,6，最后是7,8,9）往往比按列访问（先读取1,4,7，然后是2,5,8，最后是3,6,9）更快，因为按行访问可以更好地利用空间局部性原理，减少缓存失效。

### 十一、Java和Go的区别

##### 1. 并发模型

- **Go**：
  - Go的并发模型建立在协程（称为goroutines）之上，这些协程是轻量级的线程，可以高效地进行上下文切换。
  - Go中的通道（Channels）和`select`语句为并发执行提供了内置的通信机制。
- **Java**：
  - Java使用传统的线程模型，与操作系统线程直接映射，并且通常比Go的goroutines重量级。
  - Java提供多种并发工具，如`java.util.concurrent`包中的锁、同步器等。

##### 2. 性能

- **Go**：
  - Go编译为本机代码，执行速度快，内存使用通常更高效。
  - Go支持静态链接，可以生成不依赖于外部库的独立二进制文件。
- **Java**：
  - Java代码编译为字节码，在JVM（Java虚拟机）上运行，因此具有优秀的跨平台能力。
  - JVM通过即时编译（JIT）可以接近原生代码的性能，但启动时间和基本内存占用通常高于Go。

**3. 语法特性：**

- Go的语法简洁明了，它采用了类似C语言的语法风格，但去掉了一些复杂的特性，如类继承和构造函数。使用结构体实现面向对象。
- Java的语法较为复杂，它是一种完全面向对象的语言，支持类、继承、接口等概念。

##### 4. 应用领域

- Go注重并发编程和高性能，适合构建网络服务、分布式系统和云计算相关的应用。
- Java则是一种通用的编程语言，广泛应用于企业级应用、桌面应用程序、移动应用程序和嵌入式系统等领域。

### 十二、是否一定要使用外键约束？

外键约束的缺点：

1. **性能开销**：外键约束可能增加数据库的性能开销。在插入、更新或删除操作时，数据库必须检查外键约束，这可能导致额外的查询和计算，增加延迟。
2. **复杂的数据操作**：处理包含外键约束的表的数据操作可能更加复杂，特别是涉及到多表和大量数据时。
3. **分布式系统的挑战**：在分布式数据库系统中，跨多个数据库节点维护外键约束可能变得复杂和低效。
4. **锁和并发问题**：外键约束可能导致数据库锁定行为增加，影响并发操作的性能。

如何使用：

- 对于需要高数据完整性和标准化的应用（如金融系统、医疗信息系统等），使用外键约束通常是推荐的。
- 如果性能是一个重要考量，尤其是在读写密集型或高并发的环境下，某些系统可能会选择在应用层而不是数据库层实施数据完整性规则。

### 十三、抖音、快手之类的短视频服务 优化方案有哪些

- 内容分发网络，根据大数据决策视频存储在CDN的哪个节点（算法）
- 自适应比特率流，开始加载时使用最低分辨率，加快加载速度（视频）
- 高效编码格式，提高压缩率（视频）
- 预加载策略，预先加载用户感兴趣的内容（算法）
- 边缘计算，将计算任务从中心服务器转移到网络边缘的设备，以减少数据处理和响应的延迟。（架构）
- 大规模分布式架构，采用分布式架构来实现高可用性、高伸缩性和故障容错（架构）

### 十四、UTF-8编码和Unicode字符集

Unicode为每个字符分配了一个唯一的编号（U+4E2D），而UTF-8则指定了将这些编号转换为字节序列的具体方法（0xE4 0xB8 0xAD）。因此，UTF-8可以被看作是Unicode标准的一种实现方式，用于实际存储和传输数据。

为什么要用utf-8编码？

1. **向下兼容性**：UTF-8与传统的ASCII编码兼容。在UTF-8编码中，ASCII字符范围（0-127）内的字符与其ASCII表示完全相同。这意味着原本以ASCII编码的文本文件，可以被视作UTF-8编码而不需要任何转换。
2. **节省空间**：由于UTF-8是可变长编码（1至4个字节），它对于编码ASCII字符非常高效，只使用一个字节。对于许多使用拉丁字母书写系统的语言来说，大量文本会用到ASCII字符，因此UTF-8可以在这些情况下节约空间。
3. **灵活性**：UTF-8可以表示Unicode标准中定义的所有字符，并且随着新字符的加入，UTF-8不需要调整现有的编码。相比之下，使用固定长度的编码（例如UTF-32，每个字符使用4个字节）会浪费更多的空间，特别是当文本主要由ASCII字符组成时。

十五、场景冲突

- 手动重启：查看是哪个服务或应用占用了该端口，然后确定是否可以安全地停止该服务或将该服务移动到其他端口

  - 如果是开发环境，或许可以简单地停止相关服务。
  - 如果是生产环境，需要考虑到服务中断对用户的影响，并且可能需要安排在访问量低的时段进行操作。

- 防火墙：在某些情况下，你可能无法更改服务的端口（例如，它可能是由第三方管理的）。此时，可以考虑设置防火墙规则来重定向流量。

  ```bash
  sudo iptables -t nat -A PREROUTING -p tcp --dport <OLD_PORT> -j REDIRECT --to-port <NEW_PORT>
  ```

- 容器化：如果频繁遇到端口冲突的问题，可能需要考虑使用容器化技术（如Docker）来隔离你的服务，这样每个服务都可以在各自独立的环境中运行，相互之间不会因为端口冲突而干扰。

### 一、分布式系统

#### CAP 理论

CAP 理论是分布式系统设计中的一个基本原则，它提供了一个思考和权衡一致性、可用性和分区容错性之间关系的框架。 CAP 理论的三个要素如下：

1. **一致性（Consistency）**：在分布式系统中的多个副本或节点之间，保持数据的一致性。也就是说，如果有多个客户端并发地读取数据，在任何时间点上，它们都应该能够观察到相同的数据。
2. **可用性（Availability**）：系统在任何时间点都能正常响应用户请求，即使部分节点挂了，如果一个系统不能提供响应或响应时间过长，则认为系统不可用。
3. **分区容忍性（Partition tolerance）**：指系统在遇到网络分区或节点失效的情况下，仍能够继续工作并保持数据的一致性和可用性。

CAP 理论指出，在分布式系统中，不能同时满足一致性、可用性和分区容错性这三个特性，只能是 CP 或者是 AP（在分布式系统中，分区是无法避免的，当分区发生时，我们必须在一致性和可用性之间做出选择）。

- CP：强一致性和分区容错性设计。这样的系统要求保持数据的一致性，并能够容忍分区故障，但可用性较低，例如在分区故障期间无法提供服务。
- AP：高可用性和分区容错性设计。这样的系统追求高可用性，而对一致性的要求较低。在分区故障期间，它可以继续提供服务，但数据可能会出现部分不一致。

```markdown
在 C 一致性要求下，就必须要拒绝用户的请求，而拒绝了用户的请求就违背了 A 可用性，所以 C 和 A 在分布式环境下是永无无法同时满足的，分布式系统要么是 CP 模式，要么是 AP 模式。
```

#### BASE理论

BASE 理论是对分布式系统CAP理论中一致性与可用性权衡的进一步解释，它更注重实际业务中如何通过放松一致性来获得高可用性。 BASE 是指：

1. **基本可用性（Basically Available）**：系统保证在出现故障或异常情况下依然能够正常对外提供服务，尽管可能会有一定的性能损失或功能缺失。在分布式系统中，为了保证系统的可用性，有时会牺牲一致性。
2. **软状态（Soft State）**：系统中的数据的状态并不是强一致的，而是柔性的。在分布式系统中，由于网络延迟、节点故障等因素，数据可能存在一段时间的不一致。
3. **最终一致性（Eventually Consistent）**：系统会保证在一段时间内对数据的访问最终会达到一致的状态。即系统允许数据副本在一段时间内存在不一致的状态，但最终会在某个时间点达到一致。

BASE 理论强调系统的可用性和性能，尽可能保证系统持续提供服务，而不是追求强一致性。在实际应用中，为了降低分布式系统的复杂性和提高性能，可以采用一些方法来实现最终一致性，如**版本管理、异步复制**等技术手段。

CAP理论常被用于说明分布式系统设计的极限和理论上的权衡，而BASE理论则更多地指导具体实践，如何在CAP理论所描述的限制下构建灵活且健壮的系统。

#### 分布式共识理论

共识算法如Paxos、Raft和Zab等，解决分布式系统中多节点间如何就某个值（如配置信息、状态）达成一致性的问题。

**Raft算法：**"任期号"（Term）和"索引"（Index）是维护一致性和日志顺序的关键概念。

任期号：是一个单调递增的整数，它标记了集群领导权变动的时间段。每次选举都会产生一个新的任期号，并且任期号随着时间推移只会增加不会减少。这个机制有助于防止“脑裂”现象，即防止多个节点同时认为自己是合法的领导者。

```
在Raft算法中，当一个Follower节点在一段时间内没有收到当前Leader的心跳包时，它会成为Candidate并开始新一轮的选举，此时任期号加一。如果该节点获得大多数节点的投票，那么它就会成为新的Leader，并以新的任期号开始发送心跳和日志条目给其他节点。

任期号也用于解决网络分区和消息延迟问题。例如，一个过时的Leader（其身份属于旧任期）尝试向集群中的其他节点发送命令，但由于任期号比当前任期低，这些节点会拒绝执行这些命令并告知该Leader其任期已经过时。
```

索引：是日志条目在日志中的位置，表征了特定日志条目在整个日志序列中的顺序。索引保证了日志条目可以按照严格的顺序进行复制和应用到状态机上。

```
当一个Leader接收到客户端的请求时，它会生成一个带有当前任期号和唯一索引的日志条目。然后，Leader会将包含此日志条目的信息复制到集群中的其他节点。一旦条目被成功复制到大多数节点，它就可以被提交并应用到状态机上。

Leader可以使用索引和任期号来确定不一致的位置，并通过发送缺失的条目来恢复日志的一致性。
```

日志同步的概念：服务器接收客户的数据更新/删除请求，这些请求会落地为命令日志。只要输入状态机的日志命令相同，状态机的执行结果就相同。所以Raft的核心就是leader发出日志同步请求，follower接收并同步日志，最终保证整个集群的日志一致性。

核心流程：

- 首先选出leader，leader节点负责接收外部的数据更新/删除请求；
- 然后日志复制到其他follower节点，同时通过安全性的准则来保证整个日志复制的一致性；
- 如果遇到leader故障，followers会重新发起选举出新的leader；

具体流程：

Leader接收所有客户端请求，然后转化为log复制命令，发送通知其他节点完成日志复制请求。每个日志复制请求包括状态机命令 & 任期号，同时还有前一个日志的任期号和日志索引。状态机命令表示客户端请求的数据操作指令，任期号表示leader的当前任期。

**follower收到日志复制请求的处理流程：**

（1）follower会使用前一个日志的任期号和日志索引来对比自己的数据：

- 如果相同，接收复制请求，回复ok；
- 否则回拒绝复制当前日志，回复error；

（2）leader收到拒绝复制的回复后，继续发送节点日志复制请求，不过这次会带上更前面的一个日志任期号和索引；

（3）如此循环往复，直到找到一个共同的任期号&日志索引。此时follower从这个索引值开始复制，最终和leader节点日志保持一致；

（4）日志复制过程中，Leader会无限重试直到成功。如果超过半数的节点复制日志成功，就可以任务当前数据请求达成了共识，即日志可以commite提交了；

**两个特点：**

（1）如果在不同日志中的两个条目有着相同索引和任期号，则所存储的命令是相同的，这点是由leader来保证的；

（2）如果在不同日志中的两个条目有着相同索引和任期号，则它们之间所有条目完全一样，这点是由日志复制的规则来保证的；

参考：https://zhuanlan.zhihu.com/p/610671151

#### 应用

在设计分布式系统时，根据具体的场景和需求，可能会结合这两种理论。例如，一个电商平台可能会在订单处理系统中优先考虑一致性（CAP的C），而在商品浏览中优先保证可用性和最终一致性（BASE）。这样，即使在面对网络问题和服务器故障时，用户仍能够浏览商品，而订单处理则采取措施确保交易数据的准确性。

### 二、百万级别用户系统

- 尽可能地缓存数据
- 采用无状态Web层
- 支持多个数据中心
- 在 CDN 中托管静态资源
- 通过分片扩展数据层
- 将层级拆分为独立的服务

#### 负载均衡器

负载均衡器会将传入的流量均匀分配给在负载均衡集合中定义的Web服务器，用户直接连接负载均衡器的公共IP。通过这种设置，Web服务器不再能直接被客户端访问，负载均衡器通过私有IP与Web服务器进行通信。

- 如果服务器1下线，所有流量将被路由到服务器2。这样可以防止网站宕机。我们还可以向服务器池中添加一个新的健康Web服务器来平衡负载。
- 如果网站流量迅速增长，两个服务器无法处理流量，负载均衡器可以优雅地解决这个问题。您只需要向Web服务器池添加更多服务器，负载均衡器将自动开始将请求发送给它们。

#### 数据库复制

![image-20230517205239480](https://gitee.com/xu_zuyun/picgo/raw/master/img/d1c591324a6a471d9cd088fd5a2577b4.png)

- 更好的性能：在主从模型中，所有的写操作和更新操作都发生在主节点上，而读操作分布在从节点上。这种模型改善了性能，因为它允许更多的查询并行处理。
- 可靠性：如果你的数据库服务器之一被自然灾害（如台风或地震）摧毁，数据仍然得以保留。你不需要担心数据丢失，因为数据被复制到多个位置。
- 高可用性：通过在不同的位置复制数据，即使一个数据库离线，你的网站仍然可以运行，因为你可以访问存储在另一个数据库服务器中的数据。

#### 无状态Web层

`有状态服务器会记住从一个请求到下一个请求的客户端数据（状态）。无状态服务器不保存任何状态信息。`

有状态Web层的问题在于同一客户端的每个请求必须路由到同一台服务器，我们将状态（例如用户会话数据）从Web层中移出,做法是将会话数据存储在持久性存储中，如关系型数据库或NoSQL数据库。用户的HTTP请求可以发送到任何Web服务器，这些服务器从共享数据存储中获取状态数据。状态数据存储在共享数据存储中，并且不保存在Web服务器中。无状态系统更简单、更健壮和可扩展。


![image-20230517205815284](https://gitee.com/xu_zuyun/picgo/raw/master/img/47721c05473f496e858cae1acfc2a12c.png)

#### 内容分发网络（CDN）

CDN是一个由地理分布的服务器组成的网络，用于传送静态内容。CDN服务器缓存像图像、视频、CSS、JavaScript文件等静态内容。静态资源不再由 Web 服务器提供。它们从 CDN 获取以获得更好的性能。

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在的运营商网络，找相同网络的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/89a91b28f6344ba39f14775f99b4e7f8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

##### 流程

- 如果CDN服务器没有image.png的缓存，CDN服务器会从源请求文件。
- 源将image.png返回给CDN服务器，其中包括可选的HTTP头部Time-to-Live（TTL），描述图像被缓存的时间。
- CDN缓存图像并将其返回给用户A。图像会在CDN中缓存，直到TTL过期。
- 用户B发送请求以获取相同的图像。
- 只要TTL未过期，图像将从缓存中返回。

其中有两个衡量`CDN`服务质量的指标：

- 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

#### 消息队列

![image-20230517205941209](https://gitee.com/xu_zuyun/picgo/raw/master/img/00f77e49e8214447b4a64e3de5d77e92.png)

消息队列是一种持久性组件，存储在内存中，用于支持异步通信。它作为缓冲区并分发异步请求。消息队列的基本架构很简单。称为生产者/发布者的输入服务创建消息，并将其发布到消息队列中。其他服务或服务器，称为消费者/订阅者，连接到队列并执行消息定义的操作。

#### 数据中心

在正常运行时，用户会根据地理位置通过geoDNS路由到最近的数据中心，其中在美国东部的流量占*x%*，在美国西部的流量占*(100 - x)%*。geoDNS是一种DNS服务，根据用户所在地将域名解析为IP地址。

![image-20230517205854112](https://gitee.com/xu_zuyun/picgo/raw/master/img/bd932f243e7c4b71b78e69c33ac3d783.png)

如果发生任何重大数据中心故障，我们会将所有流量引导到一个正常运行的数据中心。

技术挑战：

- 流量重定向：需要有效的工具将流量引导到正确的数据中心。根据用户所在地，可以使用geoDNS将流量引导到最近的数据中心。
- 数据同步：来自不同地区的用户可能使用不同的本地数据库或缓存。在故障转移情况下，流量可能会路由到一个数据中心，该数据中心的数据不可用。一种常见的策略是在多个数据中心之间复制数据。一项先前的研究展示了Netflix如何实现异步多数据中心复制[11]。

### 三、新闻订阅系统的设计和实现

- Web 服务器：Web 服务器将流量重定向到不同的内部服务。
- Post 服务：在数据库和缓存中持久化帖子。
- Fanout 服务：将新内容推送到朋友的新闻订阅中。新闻订阅数据存储在缓存中以便快速检索。
- 通知服务：通知朋友新内容可用，并发送推送通知。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-25860a774fb7d6adebbfd1053f489f87_1440w.webp)

#### Web 服务器

除了与客户端进行通信，Web 服务器还执行身份验证和速率限制。只有使用有效的 *auth_token* 登录的用户才能发布帖子。系统限制用户在一定时间内可以发布的帖子数量，这对于防止垃圾邮件和恶意内容至关重要。

#### 扩散服务

扩散是将帖子传递给所有朋友的过程。有两种类型的扩散模型：写时扩散（也称为推送模型）和读时扩散（也称为拉取模型）。

1. 从图数据库获取朋友ID。图数据库适合管理朋友关系和朋友推荐。有兴趣了解更多关于这个概念的读者，可以参考参考资料[2]。
2. 从用户缓存获取朋友信息。然后系统根据用户设置过滤朋友。例如，如果你屏蔽了某人，即使你们仍然是朋友，她的帖子也不会出现在你的新闻订阅中。帖子可能不显示的另一个原因是，用户可能选择性地与特定朋友分享信息，或者从其他人那里隐藏信息。
3. 将朋友列表和新帖子ID发送到消息队列。
4. 扩散工作器从消息队列获取数据，并将新闻订阅数据存储在新闻订阅缓存中。你可以将新闻订阅缓存看作是一个  映射表。每当发布一个新帖子，它都会被添加到图 11-6  中显示的新闻订阅表中。如果我们在缓存中存储整个用户和帖子对象，内存消耗可能会变得非常大。因此，只存储ID。为了保持内存大小小，我们设置了一个可配置的限制。用户在新闻订阅中浏览成千上万的帖子的机会很小。大多数用户只对最新的内容感兴趣，所以缓存未命中率很低。
5. 在新闻订阅缓存中存储 。图 11-6 显示了缓存中的新闻订阅的样子。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-503dac08322b09338aa46f78f45ee5c3_1440w.webp)

**写时扩散**：在这种方法中，新闻订阅在写入时预先计算。新帖子发布后立即发送到朋友的缓存。

```markdown
## 优点：
- 新闻订阅是实时生成的，可以立即推送给朋友。
- 因为新闻订阅在写入时就预先计算，所以获取新闻订阅非常快。
## 缺点：
- 对于明星用户来说，获取朋友列表并为他们所有人生成新闻订阅是缓慢且耗时的。这就是所谓的热键问题。
- 对于不活跃的用户或者很少登录的用户，预先计算新闻订阅会浪费计算资源。
```

**读时扩散：** 在读取时生成新闻订阅，这是一个按需模型。用户加载主页时，会拉取最近的帖子。

```markdown
## 优点：
- 对于不活跃的用户或者很少登录的用户，读时扩散效果更好，因为它不会在他们身上浪费计算资源。
- 数据不会推送给朋友，所以没有热键问题。
## 缺点：
- 获取新闻订阅速度慢，因为新闻订阅没有预先计算。
```

**混合扩散：**由于快速获取新闻订阅很关键，所以我们对大部分用户使用推送模型。对于那些有许多朋友/粉丝的名人或用户，我们让粉丝按需拉取新闻内容，以避免系统过载。

#### 新闻获取服务

- 网络服务器调用新闻订阅服务获取新闻订阅。
- 新闻订阅服务从新闻订阅缓存获取帖子 ID 列表。
- 新闻订阅服务从缓存（用户缓存和帖子缓存）中获取完整的用户和帖子对象，以构建完全填充的新闻订阅。
- 完全填充的新闻订阅以 JSON 格式返回给客户端进行渲染。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-b6f9b7e908664645289ae4ae7c088d85_1440w.webp)

#### 新闻缓存结构设计

- 新闻订阅：存储新闻订阅的 ID。
- 内容：存储每个帖子的数据。热门内容存储在热缓存中。
- 社交图：存储用户关系数据。
- 行动：存储用户是否喜欢一篇帖子，回复一篇帖子，或对一篇帖子进行其他操作的信息。
- 计数器：存储点赞、回复、关注者、正在关注等的计数器。

![img](https://gitee.com/xu_zuyun/picgo/raw/master/img/v2-9b6d18db000ad6d6a72970490b0ae784_1440w.webp)

### 四、设计类似Youtube的视频分享平台

三个部分组成：

- **客户端**：你可以在电脑、手机和智能电视上观看YouTube。
- **CDN**：视频存储在CDN中。当你按下播放键时，视频将从CDN中流出。
- **API服务器**：除视频流外的所有其他事情都通过API服务器。这包括推荐提要，生成视频上传URL，更新元数据数据库和缓存，用户注册等。

主要有两个流程：**视频上传流程** 和 **视频流式传输流程**

#### 视频上传流程

```markdown
1. 视频被上传到原始存储。
2. 转码服务器从原始存储中获取视频并开始转码。
3. 一旦转码完成，以下两个步骤并行执行：
3a. 转码的视频被发送到转码存储。
3b. 转码完成的事件被排入完成队列。
3a.1. 转码的视频被分发到CDN。
3b.1. 完成处理器包含一群持续从队列中拉取事件数据的工作人员。
3b.1.a. 和 3b.1.b. 当视频转码完成时，完成处理器会更新元数据数据库和缓存。
4. API服务器通知客户端视频已成功上传并准备好进行流媒体播放。
```



![image-20230525204553936](https://gitee.com/xu_zuyun/picgo/raw/master/img/445b619351344cecaf1587cb929f1157.png)

- 用户：用户在电脑、手机或智能电视等设备上观看YouTube。

- 负载均衡器：负载均衡器在API服务器之间均匀分配请求。

- API服务器：除视频流外，所有用户请求都通过API服务器。

- 元数据数据库：视频元数据存储在元数据数据库中。为了满足性能和高可用性的要求，它被分片和复制。

- 元数据缓存：为了更好的性能，视频元数据和用户对象被缓存。

- 原始存储：使用一个blob存储系统来存储原始视频。**blob存储**：“二进制大对象（BLOB）是数据库管理系统中作为单一实体存储的二进制数据集合”。

- 转码服务器：视频转码也称为视频编码。它是将视频格式转换为其他格式（如MPEG，HLS等）的过程，这些格式为不同的设备和带宽能力提供最佳的视频流。

- 转码存储：它是一个存储转码视频文件的blob存储。

- CDN：视频被缓存在CDN中。当你点击播放按钮时，视频将从CDN中流出。

- 完成队列：它是一个消息队列，存储关于视频转码完成事件的信息。

- 完成处理器：这包括从完成队列中提取事件数据并更新元数据缓存和数据库的工作列表。

#### 视频流媒体播放流程

- 流媒体播放表示设备不断从远程源视频接收视频流。观看流媒体视频时，客户端一次只加载一小部分数据。
- 视频是直接从CDN流媒体播放的。离你最近的边缘服务器将会传送视频。

#### 视频转码

##### 1. 有向无环图（DAG）模型

为了支持不同的视频处理流程并保持高并行性，重要的是增加一些抽象层次，并让客户端程序员定义要执行的任务。模型在阶段中定义任务，因此它们可以顺序执行或并行执行，通过DAG模型来实现灵活性和并行性。

![image-20230525204747146](https://gitee.com/xu_zuyun/picgo/raw/master/img/a5da35e5b9a743628b9eb34f95e56539.png)

- 检查：确保视频质量好且格式正常。
- 视频编码：将视频转换以支持不同的分辨率、编解码器、比特率等。图14-9显示了一个编码视频文件的例子。
- 缩略图。缩略图可以由用户上传，也可以由系统自动生成。
- 水印：视频顶部的图像叠加层，包含关于你的视频的识别信息。

2. ##### 视频转码架构

![image-20230525204821824](https://gitee.com/xu_zuyun/picgo/raw/master/img/1ff58e6aade842ab8460c1faa6464829.png)

###### 预处理器

- 视频分割：视频流被分割或进一步分割为更小的图像组（GOP）对齐。GOP是一组/一块按照特定顺序排列的帧。每块都是一个可以独立播放的单元，通常长度为几秒钟。
- DAG生成：处理器根据客户端程序员编写的配置文件生成DAG。
- 缓存数据：预处理器是分段视频的缓存。为了提高可靠性，预处理器将GOP和元数据存储在临时存储中。如果视频编码失败，系统可以使用持久化数据进行重试操作。

![image-20230525204856379](https://gitee.com/xu_zuyun/picgo/raw/master/img/974046d00b3841739cc0c184719ba8d6.png)

###### DAG调度器

DAG调度器将DAG图分割为任务阶段，并将它们放入资源管理器的任务队列中。

![image-20230525204922154](https://gitee.com/xu_zuyun/picgo/raw/master/img/3ef82442b1a74071af1ec0c0445353ea.png)

###### 资源管理器

- 任务调度器从任务队列中获取最高优先级的任务。
- 任务调度器从工作队列中获取最优的任务工作者来运行任务。
- 任务调度器指示选定的任务工作者运行任务。
- 任务调度器将任务/工作者信息绑定，并将其放入运行队列。
- 一旦任务完成，任务调度器会从运行队列中移除该任务。

![image-20230525204946262](https://gitee.com/xu_zuyun/picgo/raw/master/img/da5d0e265dc04dd6bb0154c1df8c7074.png)

###### 任务工作器

任务工作器执行在DAG中定义的任务。如图14-19所示，不同的任务工作者可能会执行不同的任务

###### 临时存储

这里使用了多种存储系统。选择哪种存储系统取决于数据类型、数据大小、访问频率、数据寿命等因素。例如，元数据经常被工作者访问，数据大小通常较小。因此，将元数据缓存在内存中是个好主意。对于视频或音频数据，我们将它们放入Blob存储中。一旦相应的视频处理完成，临时存储中的数据就会被清理掉。

#### 系统优化

##### 速度优化：并行化视频上传

这样可以在之前的上传失败时实现快速可恢复的上传。由客户端实现通过GOP分割视频文件的工作，可以提高上传速度，

![image-20230525205050100](https://gitee.com/xu_zuyun/picgo/raw/master/img/0f3a448ca4704077bdb419df0da11b26.png)

##### 速度优化：将上传中心设置得靠近用户

在全球范围内设置多个上传中心（图14-24）。美国的人可以将视频上传到北美的上传中心，中国的人可以将视频上传到亚洲的上传中心。为了实现这一点，我们使用CDN作为上传中心。

##### 速度优化：消息队列解耦

- 在引入消息队列之前，编码模块必须等待下载模块的输出。
- 在引入消息队列之后，编码模块不再需要等待下载模块的输出。如果消息队列中有事件，编码模块可以并行执行这些任务。

![image-20230525205122600](https://gitee.com/xu_zuyun/picgo/raw/master/img/97808c74a4b541fd9f3343788d9cf738.png)

##### 安全性优化：预签名上传URL

客户端向API服务器发起HTTP请求，以获取预签名URL，该URL给予访问URL中标识的对象的访问权限。
API服务器返回一个预签名URL。
一旦客户端收到响应，它就可以使用预签名URL上传视频。

##### 成本的优化

- 只从CDN提供最热门的视频，其他视频从我们的高容量存储视频服务器提供。
- 对于不太热门的内容，我们可能不需要存储许多编码后的视频版本。短视频可以按需编码。
- 一些视频只在某些地区受欢迎。没有必要将这些视频分发到其他地区。

### 五、设计一个日活5000万的聊天系统

- 聊天服务器促进消息的发送/接收。
- 在线状态服务器管理在线/离线状态。
- API服务器处理所有事情，包括用户登录、注册、更改个人资料等。
- 通知服务器发送推送通知。
- 最后，键值存储被用来存储聊天历史。当一个离线用户上线时，她将看到所有以前的聊天历史。

![image-20230525203007564](https://gitee.com/xu_zuyun/picgo/raw/master/img/5c95b1f3f11b4ab781d5ac1bd84ae17a.png)

#### 数据存储

第一种是通用数据，如用户资料、设置、用户好友列表。这些数据存储在稳健和可靠的关系数据库中。复制和分片是常用的技术，用来满足可用性和可扩展性的需求。

第二种是聊天系统独特的数据：聊天历史数据，采用键值存储。

- 键值存储允许轻松的水平扩展。
- 键值存储提供非常低的数据访问延迟。
- 关系数据库不能很好地处理数据的长尾[3]。当索引变大时，随机访问变得昂贵。

#### 数据模型

1对1聊天的消息表，主键是 *message_id* ，群聊的消息表。复合主键是 *(channel_id, message_id)*，message_id的责任：

- ID必须是唯一的。
- ID应该按时间排序，意味着新行的ID比旧的更高。

```markdown
## 如何实现消息ID自增？
MySql 中的“ auto_increment ”关键字。然而，NoSQL数据库通常不提供这样的特性。
Snowflake 全局64位序列号生成器
本地序列号生成器。本地意味着ID只在一个组内是唯一的。本地ID起作用的原因是，只需维护一对一频道或群组频道内的消息顺序就足够了。与全局ID实现相比，这种方法更容易实现。
```



![image-20230525203030794](https://gitee.com/xu_zuyun/picgo/raw/master/img/439d4595927b49c3b4bd47c243a87374.png)

#### 服务发现

根据诸如地理位置、服务器容量等标准，为客户端推荐最好的聊天服务器。Apache Zookeeper是一个流行的开源服务发现解决方案。它注册所有可用的聊天服务器，并根据预定的标准为客户端选择最好的聊天服务器。

#### 1对1消息流程

- 用户A向聊天服务器1发送聊天消息。
- 聊天服务器1从ID生成器获取消息ID。
- 聊天服务器1将消息发送到消息同步队列。
- 消息存储在键值存储中。
  5.a. 如果用户B在线，消息将转发到用户B连接的聊天服务器2。
  5.b. 如果用户B离线，推送通知（PN）服务器会发送推送通知。
- 聊天服务器2将消息转发给用户B。用户B和聊天服务器2之间存在持久的WebSocket连接。

![image-20230525203124205](https://gitee.com/xu_zuyun/picgo/raw/master/img/549b8a0d050a46b59e3a52e2fd3b2879.png)

#### 消息跨设备同步

每个设备都维护了一个名为cur_max_message_id的变量，该变量跟踪设备上最新的消息ID。满足以下两个条件的消息被认为是新消息：

接收方ID等于当前登录的用户ID。
键值存储中的消息ID大于cur_max_message_id

由于每个设备上的cur_max_message_id都不同，每个设备都可以从KV存储中获取新消息，因此消息同步很容易。

![image-20230525203139220](https://gitee.com/xu_zuyun/picgo/raw/master/img/342d50e168d34bb788cc5bab6e5dab5b.png)

#### 群聊消息流程

消息被复制到每个群成员的消息同步队列，可以看作是接收者的收件箱。这种设计选择对小群聊很有好处：

- 它简化了消息同步流程，因为每个客户端只需要检查自己的收件箱就可以获取新消息。
- 当群数量较小时，将副本存储在每个接收者的收件箱中并不太昂贵。（微信500人）

![image-20230525203156340](https://gitee.com/xu_zuyun/picgo/raw/master/img/71a15c78cde1442895c32c3a006d5d6b.png)

#### 在线状态

在客户端和实时服务之间建立WebSocket连接后，用户A的在线状态和*last_active_at*时间戳会保存在KV存储中。用户登录后，状态指示器会显示用户在线。

心跳机制：定期地，在线客户端向状态服务器发送一个心跳事件。如果状态服务器在一定时间内，比如从客户端开始的x秒内，接收到一个心跳事件，用户就被认为是在线的。否则，就是离线的。

状态服务器使用发布-订阅模型，其中每对朋友都维持一个通道。当用户A的在线状态发生变化时，它将事件发布到所有的通道，朋友们很容易获得在线状态的更新，对于小用户群体是有效的。大群体的解决方案是只有当用户进入一个群或手动刷新好友列表时才获取在线状态
